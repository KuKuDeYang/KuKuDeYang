<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>小邵醉酒记</title>
      <link href="/2025/01/30/%E5%B0%8F%E9%82%B5%E9%86%89%E9%85%92%E8%AE%B0/"/>
      <url>/2025/01/30/%E5%B0%8F%E9%82%B5%E9%86%89%E9%85%92%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p> 2025-01-25 </p><p>小邵今晚醉的不省人事</p><p>当然 ，首先说明 ，并不是我灌得，我可舍不得！！！</p><p>他们放假前的年会，大家一起去吃饭，和同事们喝的不省人事。</p><p>幸好，还记得给我发消息去接她。</p><p>刚接到她的时候，她已经站不稳了，后来越来越不清醒，据她的描述，那段时间快要死了一样的难受。她第一次喝这么多。</p><p>心疼~</p><p>可能也是因为我前一天晚上也喝到了两点，没有和她打电话，她那晚哭了，失眠了，我第二天才知道。</p><p>我不应该喝那么多，喝那么晚的。小邵也不应该喝那么多。</p><p>我们约定以后能少喝就少喝。</p><p>喜欢小邵！</p><p>嘿嘿。</p>]]></content>
      
      
      <categories>
          
          <category> 小日常 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>小邵拉屎记</title>
      <link href="/2025/01/21/%E5%B0%8F%E9%82%B5%E6%8B%89%E5%B1%8E%E8%AE%B0/"/>
      <url>/2025/01/21/%E5%B0%8F%E9%82%B5%E6%8B%89%E5%B1%8E%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="2025-01-21"><a href="#2025-01-21" class="headerlink" title="2025-01-21"></a>2025-01-21</h2><p>前情回顾是小邵说拉屎时间太长了，以后不能拉这么久了，对身体不好，以后控制在五分钟以内；</p><p>直接上图：</p><p><img src="/2025/01/21/%E5%B0%8F%E9%82%B5%E6%8B%89%E5%B1%8E%E8%AE%B0/cover.jpg"></p><p>哈哈哈哈哈哈哈</p><p>早上一睁眼</p><p>看到小邵给我发的消息</p><p>简直要笑死了</p><p>太可爱了</p><p>小邵</p><p>爱你</p>]]></content>
      
      
      <categories>
          
          <category> 小日常 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>讨论下人格的缺陷</title>
      <link href="/2025/01/17/%E8%AE%A8%E8%AE%BA%E4%B8%8B%E4%BA%BA%E6%A0%BC%E7%9A%84%E7%BC%BA%E9%99%B7/"/>
      <url>/2025/01/17/%E8%AE%A8%E8%AE%BA%E4%B8%8B%E4%BA%BA%E6%A0%BC%E7%9A%84%E7%BC%BA%E9%99%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="2025年1月17日"><a href="#2025年1月17日" class="headerlink" title="2025年1月17日"></a>2025年1月17日</h2><p>今天心情极其复杂！！！！</p><p>我没有吵架，我也没有表现出来，但是我的心情不太好。</p><p>我是个软弱的人，我必须承认。但是小邵，你为什么和我这么像，你为什么没那么强势，我认为这不是一件好事。</p><p>人善被人欺、马善被人骑。</p><p>从前的我认为 ，我真心对其他人好，其他人也会真心对我好。但事实上，我越来越发现，这个社会并非如此。你百依百顺，其他人就会越来越放肆。我有个新来的同事和我们也很像，不会拒绝，领导让干啥干啥  ，换来的是什么呢？是坐大巴车27个小时出差山西！！！27个小时！这tm是有脑子的人能说出来的话？？虽然最后抢到了高铁票，但是运气没这么好  ，没抢到票，那他真的会坐27个小时的大巴车。我是真的看不下去，但是转头一想，如果是让我去的话，以我这懦弱的性格，八成也会和他一样真的去坐大巴。所以我现在非常难受，我应该变得强势一点，你也应该变得强势一点，我们都应该学会拒绝。</p><p>一步步的退让，换来的是人权的一点点丧失。</p><p>我没有你那么喜欢你老板，我承认我在吃醋，我对他只有尊重。你经常说你老板多么厉害，思想多么高，每天跟他在一起都可以学到很多，他对你多好多好之类的。你说的是事实，我没法反驳，现在我给不了你这些，所以我从来没有因为这事表现出来多么不满，我不能阻止你去追求你喜欢的事情，你喜欢的音乐，你喜欢讨论的人生哲理。</p><p>我有一种错觉，我认为对你来说你老板是更重要的那个。你对老板言听计从，你会因为老板晚上吃不上饭每天陪他，你会因为老板在和你讨论大道理而不舍离开，你会和他们出去吃饭甚至他们在生理期让你喝酒你也觉得无所谓，反正你也蛮喜欢喝酒的。甚至你有时会照顾我的感受跟我一起抱怨老板，但是仅仅是抱怨，这不会改变任何事实。让你五点起床去知音开门，你也只是抱怨，因为你觉得老板需要你了，你能被他需要感觉很满足。我甚至认为，谈恋爱一开始不告诉老板，是不是也是觉得他会不高兴呢。你总说你被你老板拿捏的死死的，是啊，在我看来，确实是这样。</p><p>我觉得你老板占用了你太多的私人时间，但是你可能觉得并非如此，我不能阻止你去追求你喜欢的东西。</p><p>我非常喜欢你，我也知道你非常喜欢我，你说我没有安全感，我之前一直在狡辩，但是现在看来，我好像真的挺没有安全感的。我发现我会一直想你，我知道这是一种内耗，我尽可能的找其他事情让自己忙起来，我甚至有时在想能成成，不能成散，让自己别那么喜欢你。但是做不到啊，我这些话都不敢当面和你说，我怕你会不高兴，我怕我们的关系会有裂痕。</p><p>我只是吐露一下我的想法，我不能阻止你去追求你喜欢的东西。</p><p>我写这段文字，只是为了让自己以后变得强势一点，我认为你也应该变得强势一点，太软弱只会受欺负，甚至根本察觉不出来自己受了欺负。我很羡慕我姐姐的性格，他对人很好，但也够强势，他这种人在职场上人缘很好，并且不会吃亏。</p><p>正在我编辑文字的时候，你给我发消息问我到哪了。是啊，我们今晚还约了吃饭，但是你因为要排练耽误了些。没关系，我理解，我也可以等，我不能阻止你去追求你喜欢的东西。</p><p>爱你，小邵。</p><p>我要换一下心情去找你了，今晚的情绪不可以带到你那里，那会影响你的。</p><p>这些文字你以后应该会看到，但你要相信，我是爱你的。我不会强迫你做出选择，我不能阻止你去追求你喜欢的东西，我需要自己做出改变，变得有安全感，变得不在内耗。</p><p>我没有在装可怜，可怜之人必有可恨之处，我觉得这句话说的很对，我只想让自己做出改变。我们以后可能会吵架，但绝不会是因为这种无理的事情，我理解你，你也理解我，我们都是理性的人。</p><p>爱你，小邵。</p><hr><p>嘿嘿</p><p>现在是第二天</p><p>果然见面才是调节情绪的最好办法，我已经完全好了，我认为昨天我的情绪有点过于激动了，写的东西有些极端了，但目的还是没有变，为了让我自己做出改变，我认为我一定可以的，加油。</p><p>这些东西我认为不能让你看到，会影响到我们之间的感情，也会影响到你的事业，你的爱好的。我认为一直当作草稿也是个不错的选择。</p><p>爱你，小邵。</p><p>想你。</p>]]></content>
      
      
      <categories>
          
          <category> 小日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 谈心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>梦里失恋</title>
      <link href="/2025/01/15/%E6%A2%A6%E9%87%8C%E5%A4%B1%E6%81%8B/"/>
      <url>/2025/01/15/%E6%A2%A6%E9%87%8C%E5%A4%B1%E6%81%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="2024-01-05"><a href="#2024-01-05" class="headerlink" title="2024-01-05"></a>2024-01-05</h2><p>昨晚梦里失恋了。</p><p>昨晚做梦，梦到小邵和另一个男生在一起了，梦里伤心的要死，醒了之后仍然很久没有缓过来，太难受了。准备记录一下昨晚的梦，时刻回忆这种痛苦，以此更加珍惜当下生活，更加珍惜小邵。</p><p>在梦里，我和她在一个大学里上学，我们都住校。有一天，我同学让我喊他出来，然后我就给她发消息，但是她一直没有回。同学建议给小邵打一个微信语音，微信语音响了很久，终于有人接了，不是小邵，是小邵室友。室友说，小邵现在生气了，不想接我的电话。我听了之后，虽然不知道为什么生气，但是马上穿睡衣就跑去女生宿舍楼下。因为，我认为，小邵不会真的生气不见我的，我想当面问清楚是怎么回事。事与愿违，我在楼下等了很久，没有等到小邵。然后，突然来了一群人，脑海里告诉我他们是摄影社团的人，小邵在这群人里面，在一个又高又帅又白的男生旁边。我刚要叫他，发现小邵和那个男生很亲密，我呆住了，没有进一步动作。我看到他们社团在拍合照，大家都往中间凑，我歪着脑袋看小邵在哪个位置，发现那个男生半蹲在前面，小邵在后面搂住男生的脖子，脑袋贴在一起很亲密。我更加伤心，更加心痛，感觉心脏都有点不舒服了。</p><p>再后面，我变成了一个摄影师，一路跟拍他们社团的人，我可以跳的很高，我背着身一下就跳到了二层楼的电影院门口（或者是戏剧院？忘记了 ，场景就是电影院里面的场景），然后这一群人也进来了，就坐在离我不远处的地方。我开始四处寻找小邵，发现他和那个男生坐在一起。他们两个很正常的坐在那，什么都没干。我很欣慰，我认为之前是因为要拍合照，要求那个拍照姿势，他们才会搂在一起的。但是，我刚感慨完，就看见小邵把胳膊伸向了那个男生。</p><p>我醒了，不知道后面是忘记了还是正好在伸胳膊的时候醒了，总之我醒了。</p><p>醒了之后，我的心还是好痛，梦里的情绪带到了现实生活中。我不知道为什么会做这种梦，我也知道这只是个梦，我不应该有这种情绪，但是就是一时之间难以平复。</p><p>可能是因为之前小邵给我说她做过脚踏两条船的梦，或多或少对我是有影响的吧，可能让我自我怀疑是不是做的不够好。当然小邵那也是梦，我相信小邵不会脚踏两条船，我也相信我们可以走到最后。</p><p>有问题及时交流才是最好的选择，小邵不用担心我会因为一些无端的原因生气，我们都是理性的人，不会莫名其妙的无理取闹。</p><p>第一次体验到失恋的感觉，原来这么难受。之前龙哥说羡慕我这种没体验过恋爱分离，每天乐呵呵的人，当时我不理解，现在稍微有些懂了。</p><p>小邵是个很好的女孩，小杨要珍惜小邵，小杨和小邵要努力走到最后！！！</p>]]></content>
      
      
      <categories>
          
          <category> 小日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小笼包 </tag>
            
            <tag> 失恋 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>官宣喽！</title>
      <link href="/2025/01/09/%E5%AE%98%E5%AE%A3%E5%96%BD%EF%BC%81/"/>
      <url>/2025/01/09/%E5%AE%98%E5%AE%A3%E5%96%BD%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<h2 id="2024年1月8日"><a href="#2024年1月8日" class="headerlink" title="2024年1月8日"></a>2024年1月8日</h2><p>和小邵在一起已经一百天啦！！！！</p><p>时间过得真快，刚开始在一起的时候，还在害怕新鲜感过去的太快，害怕会吵架生气，甚至想过三个月会不会因为吵架而就此分开。事实证明这一切都是我胡思乱想。这一百天里，有过流泪，有过生气，有过不安，但从没有萌生过一丝分开的想法，我希望我们会一直在一起。吵架是不可避免地，我希望以后所有吵架过后，我们都会更爱彼此。</p><p>小邵真是全世界最可爱的女孩子！！！！！</p><p>香香软软   吸溜吸溜~~嘿嘿</p><p><img src="/2025/01/09/%E5%AE%98%E5%AE%A3%E5%96%BD%EF%BC%81/100%E5%A4%A9.jpg" alt="100天"></p><p><img src="/2025/01/09/%E5%AE%98%E5%AE%A3%E5%96%BD%EF%BC%81/%E8%9B%8B%E7%B3%95.jpg" alt="蛋糕"></p><p><img src="/2025/01/09/%E5%AE%98%E5%AE%A3%E5%96%BD%EF%BC%81/%E5%B9%B2%E8%8A%B1.jpg" alt="干花"></p><p><img src="/2025/01/09/%E5%AE%98%E5%AE%A3%E5%96%BD%EF%BC%81/%E8%8A%B1.jpg" alt="花"></p><p><img src="/2025/01/09/%E5%AE%98%E5%AE%A3%E5%96%BD%EF%BC%81/%E7%A4%BC%E7%89%A9.jpg" alt="礼物"></p><p><img src="/2025/01/09/%E5%AE%98%E5%AE%A3%E5%96%BD%EF%BC%81/%E6%83%85%E4%BE%A3%E5%8D%AB%E8%A1%A3.jpg" alt="情侣卫衣"></p><p><img src="/2025/01/09/%E5%AE%98%E5%AE%A3%E5%96%BD%EF%BC%81/%E4%BF%A1.jpg" alt="信"></p><p><img src="/2025/01/09/%E5%AE%98%E5%AE%A3%E5%96%BD%EF%BC%81/%E7%90%83%E5%8C%85.jpg" alt="球包"></p>]]></content>
      
      
      <categories>
          
          <category> 小日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小笼包 </tag>
            
            <tag> 官宣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>这里发日常</title>
      <link href="/2025/01/06/%E8%BF%99%E9%87%8C%E5%8F%91%E6%97%A5%E5%B8%B8/"/>
      <url>/2025/01/06/%E8%BF%99%E9%87%8C%E5%8F%91%E6%97%A5%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<p> 以后，这里用来发我和小邵的日常。</p><p>当然，这篇文章只是引子，并非全部发在这里，而是创建一个小日常的标签，以后点击标签就可以看到所有小日常啦。</p><p>我不爱发朋友圈，不爱拍照，不爱记录生活，但是我现在觉得是有记录的必要的，因为回味起来真的很甜！</p><p>为什么不发在朋友圈？</p><p>一是占用其他人的公共资源；</p><p>二是确实有些东西没法发朋友圈哈哈，小邵也是用小号来发的，那我也用我的博客来记录吧。</p><p>附一张小邵蹦高图哈哈</p><p><img src="/2025/01/06/%E8%BF%99%E9%87%8C%E5%8F%91%E6%97%A5%E5%B8%B8/cover.jpg" alt="小邵蹦高图"></p><p>这个人为什么能蹦这么高？？？（这个人舌头也好长嘿嘿）。</p>]]></content>
      
      
      <categories>
          
          <category> 小日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小笼包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git同时上传gitee和github</title>
      <link href="/2024/10/25/git%E5%90%8C%E6%97%B6%E4%B8%8A%E4%BC%A0gitee%E5%92%8Cgithub/"/>
      <url>/2024/10/25/git%E5%90%8C%E6%97%B6%E4%B8%8A%E4%BC%A0gitee%E5%92%8Cgithub/</url>
      
        <content type="html"><![CDATA[<h1 id="git同时上传gitee和github平台"><a href="#git同时上传gitee和github平台" class="headerlink" title="git同时上传gitee和github平台"></a><center>git同时上传gitee和github平台</center></h1><p>转自：<a href="https://segmentfault.com/a/1190000044950335">前端 - 将本地仓库项目上传github和gitee仓库中 - 个人文章 - SegmentFault 思否</a></p><h1 id="一、Gitee创建代码仓库"><a href="#一、Gitee创建代码仓库" class="headerlink" title="一、Gitee创建代码仓库"></a>一、Gitee创建代码仓库</h1><h2 id="1、创建仓库"><a href="#1、创建仓库" class="headerlink" title="1、创建仓库"></a>1、创建仓库</h2><p>点击右上角 + 处，选择新建仓库</p><p><img src="/2024/10/25/git%E5%90%8C%E6%97%B6%E4%B8%8A%E4%BC%A0gitee%E5%92%8Cgithub/Gitee%E5%88%9B%E5%BB%BA%E4%BB%93%E5%BA%93.png" alt="Gitee创建仓库"></p><h2 id="2、填写仓库信息"><a href="#2、填写仓库信息" class="headerlink" title="2、填写仓库信息"></a>2、填写仓库信息</h2><p>根据提示，填写仓库的名称、描述信息、是否公开等，来完成下图所示的创建仓库过程。</p><p><img src="/2024/10/25/git%E5%90%8C%E6%97%B6%E4%B8%8A%E4%BC%A0gitee%E5%92%8Cgithub/Gitee%E5%A1%AB%E5%86%99%E4%BB%93%E5%BA%93%E4%BF%A1%E6%81%AF.png" alt="Gitee填写仓库信息"></p><h2 id="3、查看创建的代码仓库"><a href="#3、查看创建的代码仓库" class="headerlink" title="3、查看创建的代码仓库"></a>3、查看创建的代码仓库</h2><p>直接进入代码查库查看是否创建成功：</p><p><img src="/2024/10/25/git%E5%90%8C%E6%97%B6%E4%B8%8A%E4%BC%A0gitee%E5%92%8Cgithub/Gitee%E6%9F%A5%E7%9C%8B%E5%88%9B%E5%BB%BA%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93.png" alt="Gitee查看创建的代码仓库"></p><h1 id="二、Github创建代码仓库"><a href="#二、Github创建代码仓库" class="headerlink" title="二、Github创建代码仓库"></a>二、Github创建代码仓库</h1><h2 id="1、创建仓库（Repository）"><a href="#1、创建仓库（Repository）" class="headerlink" title="1、创建仓库（Repository）"></a>1、创建仓库（Repository）</h2><p>点击右上角+，选择 New repository，来创建仓库：</p><p><img src="/2024/10/25/git%E5%90%8C%E6%97%B6%E4%B8%8A%E4%BC%A0gitee%E5%92%8Cgithub/Github%E5%88%9B%E5%BB%BA%E4%BB%93%E5%BA%93.png" alt="Github创建仓库"></p><h2 id="2、填写仓库信息-1"><a href="#2、填写仓库信息-1" class="headerlink" title="2、填写仓库信息"></a>2、填写仓库信息</h2><p>根据提示，填写仓库的名称、描述信息、是否公开等，来完成下图所示的创建仓库过程。</p><p><img src="/2024/10/25/git%E5%90%8C%E6%97%B6%E4%B8%8A%E4%BC%A0gitee%E5%92%8Cgithub/Github%E5%A1%AB%E5%86%99%E4%BB%93%E5%BA%93%E4%BF%A1%E6%81%AF.png" alt="Github填写仓库信息"></p><h3 id="3、查看创建的代码仓库-1"><a href="#3、查看创建的代码仓库-1" class="headerlink" title="3、查看创建的代码仓库"></a>3、查看创建的代码仓库</h3><p>直接进入代码查库查看是否创建成功：</p><p><img src="/2024/10/25/git%E5%90%8C%E6%97%B6%E4%B8%8A%E4%BC%A0gitee%E5%92%8Cgithub/Github%E6%9F%A5%E7%9C%8B%E5%88%9B%E5%BB%BA%E7%9A%84%E4%BB%A3%E7%A0%81%E5%BA%93.png" alt="Github查看创建的代码库"></p><h1 id="三、生成SSH公钥"><a href="#三、生成SSH公钥" class="headerlink" title="三、生成SSH公钥"></a>三、生成SSH公钥</h1><h2 id="1、清除Git全局设置"><a href="#1、清除Git全局设置" class="headerlink" title="1、清除Git全局设置"></a>1、清除Git全局设置</h2><p>通过git config –global –list指令来查看git是否全局设置（我前期使用过Gitee所以有设置，git新用户一般没有）：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git config --<span class="variable language_">global</span> --list</span><br><span class="line">safe.<span class="property">directory</span>=<span class="regexp">/opt/</span>homebrew</span><br><span class="line">user.<span class="property">name</span>=<span class="title class_">China</span>-quanda</span><br><span class="line">user.<span class="property">email</span>=<span class="number">877880098</span>@qq.<span class="property">com</span></span><br></pre></td></tr></table></figure><h2 id="2、通过下列指令来清除git的全局设置，将youName与youEmail替换成自己的用户名及邮箱："><a href="#2、通过下列指令来清除git的全局设置，将youName与youEmail替换成自己的用户名及邮箱：" class="headerlink" title="2、通过下列指令来清除git的全局设置，将youName与youEmail替换成自己的用户名及邮箱："></a>2、通过下列指令来清除git的全局设置，将youName与youEmail替换成自己的用户名及邮箱：</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git config --<span class="variable language_">global</span> --unset user.<span class="property">name</span> <span class="string">&quot;youName&quot;</span></span><br><span class="line">git config --<span class="variable language_">global</span> --unset user.<span class="property">email</span> <span class="string">&quot;youEmail&quot;</span></span><br></pre></td></tr></table></figure><h2 id="3、SSH-key的生成"><a href="#3、SSH-key的生成" class="headerlink" title="3、SSH key的生成"></a>3、SSH key的生成</h2><h3 id="3-1、生成Github的SSH-Key："><a href="#3-1、生成Github的SSH-Key：" class="headerlink" title="3.1、生成Github的SSH Key："></a>3.1、生成Github的SSH Key：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -f ~<span class="regexp">/.ssh/i</span>d_rsa.<span class="property">github</span> -C <span class="string">&quot;877880098@qq.com&quot;</span></span><br></pre></td></tr></table></figure><h3 id="3-2、生成Gitee的SSH-Key："><a href="#3-2、生成Gitee的SSH-Key：" class="headerlink" title="3.2、生成Gitee的SSH Key："></a>3.2、生成Gitee的SSH Key：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -f ~<span class="regexp">/.ssh/i</span>d_rsa.<span class="property">gitee</span> -C <span class="string">&quot;877880098@qq.com&quot;</span></span><br></pre></td></tr></table></figure><h2 id="4、查看生成的SSH-Key"><a href="#4、查看生成的SSH-Key" class="headerlink" title="4、查看生成的SSH Key"></a>4、查看生成的SSH Key</h2><p>windows在c盘的~&#x2F;.ssh &#x2F; 路径下</p><p>mac系统是在 用户下的 ：</p><p>![查看生成的SSH Key](查看生成的SSH Key.png)</p><h2 id="5、配置SSH识别新的私钥"><a href="#5、配置SSH识别新的私钥" class="headerlink" title="5、配置SSH识别新的私钥"></a>5、配置SSH识别新的私钥</h2><p>由于默认只读取 id_rsa，为了让 SSH 识别新的私钥，需要将新的私钥加入到 SSH agent 中</p><p>需要在终端依次执行：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ssh-agent bash</span><br><span class="line">ssh-add ~<span class="regexp">/.ssh/i</span>d_rsa.<span class="property">github</span></span><br><span class="line">ssh-add ~<span class="regexp">/.ssh/i</span>d_rsa.<span class="property">gitee</span></span><br></pre></td></tr></table></figure><p>![新的私钥加入到 SSH agent](新的私钥加入到 SSH agent.png)</p><h2 id="6、多账号配置"><a href="#6、多账号配置" class="headerlink" title="6、多账号配置"></a>6、多账号配置</h2><p>为了便于Github与Gitee都能使用git，需要进行多账号配置：</p><p>查看您的.ssh文件中是否存在 config 文件，如果不存在则创建生成config文件： touch ~&#x2F;.ssh&#x2F;config</p><p>作者这边目录下是有这个config配置文件的 所以不需要创建了，直接打开文件进行修改</p><p>在该文件（config）中填写下列内容：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#<span class="title class_">Default</span> gitHub user <span class="title class_">Self</span></span><br><span class="line"><span class="title class_">Host</span> github.<span class="property">com</span></span><br><span class="line">    <span class="title class_">HostName</span> github.<span class="property">com</span></span><br><span class="line">    <span class="title class_">User</span> git</span><br><span class="line">    <span class="title class_">IdentityFile</span> ~<span class="regexp">/.ssh/i</span>d_rsa.<span class="property">github</span></span><br><span class="line"></span><br><span class="line"># gitee</span><br><span class="line"><span class="title class_">Host</span> gitee.<span class="property">com</span></span><br><span class="line">    <span class="title class_">Port</span> <span class="number">22</span></span><br><span class="line">    <span class="title class_">HostName</span> gitee.<span class="property">com</span></span><br><span class="line">    <span class="title class_">User</span> git</span><br><span class="line">    <span class="title class_">IdentityFile</span> ~<span class="regexp">/.ssh/i</span>d_rsa.<span class="property">gitee</span></span><br></pre></td></tr></table></figure><h1 id="四、添加SSH"><a href="#四、添加SSH" class="headerlink" title="四、添加SSH"></a>四、添加SSH</h1><h2 id="1、Gitee添加SSH"><a href="#1、Gitee添加SSH" class="headerlink" title="1、Gitee添加SSH"></a>1、Gitee添加SSH</h2><p>将文件id_rsa.gitee.pub内容复制到SSH Key中，成功后如下图所示：</p><p><img src="/2024/10/25/git%E5%90%8C%E6%97%B6%E4%B8%8A%E4%BC%A0gitee%E5%92%8Cgithub/Gitee%E6%B7%BB%E5%8A%A0SSH.png" alt="Gitee添加SSH"></p><h2 id="2、Github添加SSH"><a href="#2、Github添加SSH" class="headerlink" title="2、Github添加SSH"></a>2、Github添加SSH</h2><p>将文件id_rsa.github.pub内容复制到SSH Key中，成功后如下图所示：</p><p><img src="/2024/10/25/git%E5%90%8C%E6%97%B6%E4%B8%8A%E4%BC%A0gitee%E5%92%8Cgithub/Github%E6%B7%BB%E5%8A%A0SSH.png" alt="Github添加SSH"></p><h2 id="3、测试"><a href="#3、测试" class="headerlink" title="3、测试"></a>3、测试</h2><p>分别使用下列指令进行链接测试，直接yes，红框处出现Hi表示公钥添加成功：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ssh -T git@gitee.<span class="property">com</span></span><br><span class="line">ssh -T git@github.<span class="property">com</span></span><br></pre></td></tr></table></figure><p><img src="/2024/10/25/git%E5%90%8C%E6%97%B6%E4%B8%8A%E4%BC%A0gitee%E5%92%8Cgithub/%E6%B5%8B%E8%AF%95.png" alt="测试"></p><h1 id="五、代码上传仓库"><a href="#五、代码上传仓库" class="headerlink" title="五、代码上传仓库"></a>五、代码上传仓库</h1><h2 id="1、创建本地仓库-打开项目文件夹作为Git的本地仓库"><a href="#1、创建本地仓库-打开项目文件夹作为Git的本地仓库" class="headerlink" title="1、创建本地仓库 打开项目文件夹作为Git的本地仓库"></a>1、创建本地仓库 打开项目文件夹作为Git的本地仓库</h2><p><img src="/2024/10/25/git%E5%90%8C%E6%97%B6%E4%B8%8A%E4%BC%A0gitee%E5%92%8Cgithub/%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93.png" alt="本地仓库"></p><h2 id="2、在终端打开项目文件夹执行git-init-指令，把文件qd-batteryOptimize项目变成Git可以管理的仓库，生成-git文件表示创建成功："><a href="#2、在终端打开项目文件夹执行git-init-指令，把文件qd-batteryOptimize项目变成Git可以管理的仓库，生成-git文件表示创建成功：" class="headerlink" title="2、在终端打开项目文件夹执行git init 指令，把文件qd-batteryOptimize项目变成Git可以管理的仓库，生成.git文件表示创建成功："></a>2、在终端打开项目文件夹执行git init 指令，把文件qd-batteryOptimize项目变成Git可以管理的仓库，生成.git文件表示创建成功：</h2><p><img src="/2024/10/25/git%E5%90%8C%E6%97%B6%E4%B8%8A%E4%BC%A0gitee%E5%92%8Cgithub/%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93.png" alt="初始化本地仓库"></p><h2 id="3、关联远程仓库"><a href="#3、关联远程仓库" class="headerlink" title="3、关联远程仓库"></a>3、关联远程仓库</h2><h3 id="3-1、关联github仓库"><a href="#3-1、关联github仓库" class="headerlink" title="3.1、关联github仓库"></a>3.1、关联github仓库</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git remote add github git@github.<span class="property">com</span>:<span class="title class_">China</span>-quanda/qd-batteryOptimize.<span class="property">git</span>    </span><br></pre></td></tr></table></figure><h3 id="3-2、关联gitee仓库"><a href="#3-2、关联gitee仓库" class="headerlink" title="3.2、关联gitee仓库"></a>3.2、关联gitee仓库</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git remote add gitee <span class="attr">https</span>:<span class="comment">//gitee.com/china-quanda/qd-battery-optimize.git</span></span><br></pre></td></tr></table></figure><h3 id="3-3、查看本地仓库关联的远程仓库"><a href="#3-3、查看本地仓库关联的远程仓库" class="headerlink" title="3.3、查看本地仓库关联的远程仓库"></a>3.3、查看本地仓库关联的远程仓库</h3><p>使用 <code>git remote -v</code> 查看本地仓库关联了哪些远程仓库</p><p>可以看到关联了 github 和 gitee 仓库</p><p><img src="/2024/10/25/git%E5%90%8C%E6%97%B6%E4%B8%8A%E4%BC%A0gitee%E5%92%8Cgithub/%E6%9F%A5%E7%9C%8B%E5%85%B3%E8%81%94.png" alt="查看关联"></p><h2 id="4、将项目所有文件添加为暂存区"><a href="#4、将项目所有文件添加为暂存区" class="headerlink" title="4、将项目所有文件添加为暂存区"></a>4、将项目所有文件添加为暂存区</h2><p>使用<code> git add .</code> 将本地仓库项目添加为暂存区中</p><h2 id="5、提交本地暂存区文件到本地仓库"><a href="#5、提交本地暂存区文件到本地仓库" class="headerlink" title="5、提交本地暂存区文件到本地仓库"></a>5、提交本地暂存区文件到本地仓库</h2><p>使用 <code>git commit -m</code> “忽略电池优化功能” 命令提交到本地仓库中</p><h2 id="6、将本地仓库提交到远程Gitee仓库中"><a href="#6、将本地仓库提交到远程Gitee仓库中" class="headerlink" title="6、将本地仓库提交到远程Gitee仓库中"></a>6、将本地仓库提交到远程Gitee仓库中</h2><p>使用 <code>git push -u gitee master</code> 命令将本地仓库提交到远程仓库</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">quanda@<span class="number">192</span> qd-batteryOptimize % git push -u gitee master                   </span><br><span class="line">枚举对象中: <span class="number">15</span>, 完成.</span><br><span class="line">对象计数中: <span class="number">100</span>% (<span class="number">15</span>/<span class="number">15</span>), 完成.</span><br><span class="line">使用 <span class="number">8</span> 个线程进行压缩</span><br><span class="line">压缩对象中: <span class="number">100</span>% (<span class="number">13</span>/<span class="number">13</span>), 完成.</span><br><span class="line">写入对象中: <span class="number">100</span>% (<span class="number">15</span>/<span class="number">15</span>), <span class="number">5.66</span> <span class="title class_">KiB</span> | <span class="number">5.66</span> <span class="title class_">MiB</span>/s, 完成.</span><br><span class="line">总共 <span class="number">15</span>（差异 <span class="number">0</span>），复用 <span class="number">0</span>（差异 <span class="number">0</span>），包复用 <span class="number">0</span>（来自  <span class="number">0</span> 个包）</span><br><span class="line"><span class="attr">remote</span>: <span class="title class_">Powered</span> by <span class="variable constant_">GITEE</span>.<span class="property">COM</span> [<span class="variable constant_">GNK</span>-<span class="number">6.4</span>]</span><br><span class="line"><span class="title class_">To</span> <span class="attr">https</span>:<span class="comment">//gitee.com/china-quanda/qd-battery-optimize.git</span></span><br><span class="line"> * [<span class="keyword">new</span> branch]      master -&gt; master</span><br><span class="line">分支 <span class="string">&#x27;master&#x27;</span> 设置为跟踪 <span class="string">&#x27;gitee/master&#x27;</span>。</span><br></pre></td></tr></table></figure><p>刷新仓库可以看到本地仓库提交到远程仓库成功了：</p><p><img src="/2024/10/25/git%E5%90%8C%E6%97%B6%E4%B8%8A%E4%BC%A0gitee%E5%92%8Cgithub/%E6%8F%90%E4%BA%A4Gitee%E4%BB%93%E5%BA%93.png" alt="提交Gitee仓库"></p><h2 id="7、将本地仓库提交到远程Github仓库中"><a href="#7、将本地仓库提交到远程Github仓库中" class="headerlink" title="7、将本地仓库提交到远程Github仓库中"></a>7、将本地仓库提交到远程Github仓库中</h2><p>使用 <code>git push -u github master</code> 命令将本地仓库提交到远程仓库</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">quanda@<span class="number">192</span> qd-batteryOptimize % git push -u github master                                                  </span><br><span class="line">枚举对象中: <span class="number">15</span>, 完成.</span><br><span class="line">对象计数中: <span class="number">100</span>% (<span class="number">15</span>/<span class="number">15</span>), 完成.</span><br><span class="line">使用 <span class="number">8</span> 个线程进行压缩</span><br><span class="line">压缩对象中: <span class="number">100</span>% (<span class="number">13</span>/<span class="number">13</span>), 完成.</span><br><span class="line">写入对象中: <span class="number">100</span>% (<span class="number">15</span>/<span class="number">15</span>), <span class="number">5.66</span> <span class="title class_">KiB</span> | <span class="number">5.66</span> <span class="title class_">MiB</span>/s, 完成.</span><br><span class="line">总共 <span class="number">15</span>（差异 <span class="number">0</span>），复用 <span class="number">0</span>（差异 <span class="number">0</span>），包复用 <span class="number">0</span>（来自  <span class="number">0</span> 个包）</span><br><span class="line"><span class="attr">remote</span>: </span><br><span class="line"><span class="attr">remote</span>: <span class="title class_">Create</span> a pull request <span class="keyword">for</span> <span class="string">&#x27;master&#x27;</span> on <span class="title class_">GitHub</span> by <span class="attr">visiting</span>:</span><br><span class="line"><span class="attr">remote</span>:      <span class="attr">https</span>:<span class="comment">//github.com/China-quanda/qd-batteryOptimize/pull/new/master</span></span><br><span class="line"><span class="attr">remote</span>: </span><br><span class="line"><span class="title class_">To</span> <span class="attr">https</span>:<span class="comment">//github.com/China-quanda/qd-batteryOptimize.git</span></span><br><span class="line"> * [<span class="keyword">new</span> branch]      master -&gt; master</span><br><span class="line">分支 <span class="string">&#x27;master&#x27;</span> 设置为跟踪 <span class="string">&#x27;github/master&#x27;</span>。</span><br></pre></td></tr></table></figure><p>刷新仓库可以看到本地仓库提交到远程仓库成功了：</p><p><img src="/2024/10/25/git%E5%90%8C%E6%97%B6%E4%B8%8A%E4%BC%A0gitee%E5%92%8Cgithub/%E6%8F%90%E4%BA%A4Github%E4%BB%93%E5%BA%93.png" alt="提交Github仓库"></p><p>THE   END</p>]]></content>
      
      
      <categories>
          
          <category> 技术连连看 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小笼包查收</title>
      <link href="/2024/10/19/%E5%B0%8F%E7%AC%BC%E5%8C%85%E6%9F%A5%E6%94%B6/"/>
      <url>/2024/10/19/%E5%B0%8F%E7%AC%BC%E5%8C%85%E6%9F%A5%E6%94%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="交作业时间！"><a href="#交作业时间！" class="headerlink" title="交作业时间！"></a><center>交作业时间！</center></h1><h2 id="观后感"><a href="#观后感" class="headerlink" title="观后感"></a>观后感</h2><p>时间太久</p><p>忘记了</p><p>下次一定！！</p><p>嘿嘿~</p><h2 id="接下来是其他东西"><a href="#接下来是其他东西" class="headerlink" title="接下来是其他东西"></a>接下来是其他东西</h2><p>我是个俗人，没什么理想，也没什么抱负，没什么不良嗜好，也没什么高雅爱好。你之前说过的事我都干过，考研、考公、考编，我比较佛系，比较摆烂，但这并不影响我喜欢有上进心，有想法的人。他们会影响我，带动我。我很乐意陪他们一起变好，主打一个陪伴。我不喜欢一个人，做什么都喜欢让人陪着，也愿意陪着别人一起做事。</p><p>我一直认为，每个人都有每个人的想法，他这么做一定有这么做的道理。所以我很少会去跟别人讲大道理，反驳别人的观点，而是去附和。这就出现一个问题，一直附和会显得不够真诚，在敷衍。解决办法也有，就是在听的同时，发表自己的观点，我这点做的不好，也需要改。你经常有提到，要提升思想境界，要先进，像蓝老师一样，看得很通透。我十分认可，我也很崇拜思想境界很高的人，我也很想变成这样的人。不过我觉得，伟人毕竟是极少数，先进有先进的活法，俗人也有俗人的活法，不分对错，也没有高低贵贱之分，平等对待就好。有天晚上你说过，底层人无法跨越阶级，底层人的孩子还会是底层人，给不了孩子优质生活就不应该生孩子。有道理，但不完全有道理，这句话很对，社会就是这么一个社会，共产主义目前来看实现起来很困难，资本主义社会就是会有阶级，而阶级也注定很难跨越。但是，底层人也有生孩子的权利，底层人的孩子，也未必都过得不幸福。</p><p>我认为，你既然能够意识到给不了孩子优质生活就不如不生，那也一定可以当好一个母亲的角色。我更倾向于有孩子，且只有一个孩子，你应该也可以察觉出来我的想法。不生的理由很多，让人无法反驳，但是生的理由也有很多，今天看见一段话，问为什么要生孩子，答案是，当你过了三十岁，人生就只剩一次次的告别，目睹亲人，朋友不断离开，包括自己也在老去，但是有了孩子，就会有新生的力量，看着最亲近的人成长，会给你带来更多希望。这句话漏洞很多，可以用无数种理由去反驳，但是我对这句话还是表示认可。我说过，我尊重每个人的想法，别人这么做一定是有他自己的道理。女人不是一个生育机器，所以，要不要有一个孩子取决于你，而不是别人的想法，无关乎家里人的催促和要求，因为十月怀胎的是你，忍痛分娩的也是你，没人有资格去要求你。</p><p>​关于安全感</p><p>以前我没什么感觉 ，我觉得缺乏安全感这个标签不会出现在我身上，但现在我发现我错了。这看起来很矫情，但我好像确实挺缺乏安全感的。我有时会胡思乱想，会自己搁这里内耗，会觉得你这么笨，在外边受欺负了怎么办哈哈。我现在十分理解你妈妈为什么给你说要保护好自己了。我也怕时间长了，就腻了。我知道这样想是不健康的恋爱关系，我会改的。</p><p>除了感情上，生活上我好像也没好到哪去。怕说错话，怕办错事，不会拒绝，讨好型人格。在别人看来这叫老好人，也叫好欺负，实际上这些都是缺乏安全感的表现。以前都没有注意过这些，现在想想，真的有大问题了。虽然总是口头上说“那咋了那咋啦”，但实际上都会往心里去，都会觉得是不是自己做的不好啊啥啥的。嗯，这心态不健康，果然还是要改。</p><p>​关于独立</p><p>你总是问的问题，我独立么。我不喜欢一个人，做什么事都喜欢别人陪着，你说我这叫不独立。以前我觉得我还挺独立的啊，自己一个人在外面上学，自己能够照顾好自己，这不就是很独立么。但是现在我发现没那么简单。依赖别人才会缺乏安全感，不独立才会总是需要看别人眼色，考虑别人想法。这么看，我真的十分不独立啊。实际上，就算不按别人想法来又能怎样呢，别人不高兴又能怎样呢，不需要努力让所有人都喜欢你的。</p><p>太乱了，想到什么写什么，语句不通，逻辑不通就不要去纠结了。</p><p>说了这么多，都是关于我自己的，我没办法很正经的去和你讨论这些东西，脑子会转不过来，会一片空白，也会说不出口。未来谁也不知道，我们能走到哪一步也不知道，我不想给你画饼，所以也没给出过什么承诺，我会努力的发展这段关系，至于结果是什么我也都可以接受。我对我们还是很有信心的！</p><p>最后，我真的好想你啊，每天都在想你，想和你见面，想和你打电话，想和你一直呆在一块。</p><p>爱你~</p><p>爱你！</p>]]></content>
      
      
      <categories>
          
          <category> 小日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小笼包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux语法</title>
      <link href="/2024/01/10/linux%E8%AF%AD%E6%B3%95/"/>
      <url>/2024/01/10/linux%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="linux基本语法"><a href="#linux基本语法" class="headerlink" title="linux基本语法"></a>linux基本语法</h1><h2 id="文件目录指令"><a href="#文件目录指令" class="headerlink" title="文件目录指令"></a>文件目录指令</h2><h3 id="pwd指令"><a href="#pwd指令" class="headerlink" title="pwd指令"></a>pwd指令</h3><p>用于显示当前目录的路径</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# pwd</span><br><span class="line">/root</span><br><span class="line">[root@localhost ~]#</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="ls指令"><a href="#ls指令" class="headerlink" title="ls指令"></a>ls指令</h3><p>列出当前目录下所有的文件和目录</p><ul><li>ls <code>[选项][目录或文件]</code></li><li>-a ：显示当前目录所有的文件和目录，包括隐藏的</li><li>-l ：以列表的方式显示信息，相当于ll</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost /]# ls</span><br><span class="line">bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">[root@localhost /]#</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h3><p>切换到指定目录</p><ul><li>cd [参数]</li><li>cd~或cd ：回到自己的主目录</li><li>cd.. ：回到当前目录的上一级目录</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost /]# cd</span><br><span class="line">[root@localhost ~]# ls</span><br><span class="line">anaconda-ks.cfg  initial-setup-ks.cfg  公共  模板  视频  图片  文档  下载  音乐  桌面</span><br><span class="line">[root@localhost ~]# cd ..</span><br><span class="line">[root@localhost /]# ls</span><br><span class="line">bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">[root@localhost /]#</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h3><p>创建目录</p><ul><li>mkdir [选项] 要创建的目录</li><li>-p ：创建多级目录</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost opt]# mkdir temp</span><br><span class="line">[root@localhost opt]# ll</span><br><span class="line">总用量 0</span><br><span class="line">drwxr-xr-x. 2 root root 6 10月 31 2018 rh</span><br><span class="line">drwxr-xr-x. 2 root root 6 1月  11 12:35 temp</span><br><span class="line">[root@localhost opt]#</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="rmdir指令"><a href="#rmdir指令" class="headerlink" title="rmdir指令"></a>rmdir指令</h3><p>删除一个空目录</p><ul><li>rmdir 目录</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost opt]# cd tem</span><br><span class="line">[root@localhost tem]# ls</span><br><span class="line">tem</span><br><span class="line">[root@localhost tem]# rmdir tem</span><br><span class="line">[root@localhost tem]# ll</span><br><span class="line">总用量 0</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="touch指令"><a href="#touch指令" class="headerlink" title="touch指令"></a>touch指令</h3><p>创建一个或多个空文件</p><ul><li>touch 文件名称或列表</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost temp]# touch temp.txt</span><br><span class="line">[root@localhost temp]# ll</span><br><span class="line">总用量 0</span><br><span class="line">-rw-r--r--. 1 root root 0 1月  11 12:57 temp.txt</span><br><span class="line">[root@localhost temp]#</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h3><p>复制文件或目录</p><ul><li>cp [选项] 源文件 目标文件</li><li>-r  递归复制整个文件夹</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost opt]# cd temp</span><br><span class="line">[root@localhost temp]# ll</span><br><span class="line">总用量 0</span><br><span class="line">-rw-r--r--. 1 root root 0 1月  11 12:57 temp.txt</span><br><span class="line">[root@localhost temp]# cp temp.txt ../</span><br><span class="line">[root@localhost temp]# ll</span><br><span class="line">总用量 0</span><br><span class="line">-rw-r--r--. 1 root root 0 1月  11 12:57 temp.txt</span><br><span class="line">[root@localhost temp]# cd ../</span><br><span class="line">[root@localhost opt]# ll</span><br><span class="line">总用量 0</span><br><span class="line">drwxr-xr-x. 2 root root  6 10月 31 2018 rh</span><br><span class="line">drwxr-xr-x. 2 root root 22 1月  11 12:57 temp</span><br><span class="line">-rw-r--r--. 1 root root  0 1月  11 13:45 temp.txt</span><br><span class="line">[root@localhost opt]#</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="rm指令"><a href="#rm指令" class="headerlink" title="rm指令"></a>rm指令</h3><p>删除文件或目录</p><ul><li>rm [选项] 要删除的文件或目录</li><li>-r ：递归删除整个文件夹</li><li>-f ：强制删除不提示</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost opt]# rm temp</span><br><span class="line">rm: 无法删除&quot;temp&quot;: 是一个目录</span><br><span class="line">[root@localhost opt]# rm temp -r</span><br><span class="line">rm：是否进入目录&quot;temp&quot;? y</span><br><span class="line">rm：是否删除普通空文件 &quot;temp/temp.txt&quot;？y</span><br><span class="line">rm：是否删除目录 &quot;temp&quot;？y</span><br><span class="line">[root@localhost opt]# ll</span><br><span class="line">总用量 0</span><br><span class="line">drwxr-xr-x. 2 root root 6 10月 31 2018 rh</span><br><span class="line">-rw-r--r--. 1 root root 0 1月  11 13:45 temp.txt</span><br><span class="line">[root@localhost opt]#</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="mv指令"><a href="#mv指令" class="headerlink" title="mv指令"></a>mv指令</h3><p>为文件或目录改名、或将文件或目录移入其他位置</p><ul><li>mv 源文件 目标文件  将源文件名改为目标文件名</li><li>mv 源文件 目标目录         将源文件移动到目标目录</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost opt]# ll</span><br><span class="line">总用量 0</span><br><span class="line">drwxr-xr-x. 2 root root 6 10月 31 2018 rh</span><br><span class="line">-rw-r--r--. 1 root root 0 1月  11 13:45 temp.txt</span><br><span class="line">[root@localhost opt]# mv temp.txt temp_new.txt</span><br><span class="line">[root@localhost opt]# ll</span><br><span class="line">总用量 0</span><br><span class="line">drwxr-xr-x. 2 root root 6 10月 31 2018 rh</span><br><span class="line">-rw-r--r--. 1 root root 0 1月  11 13:45 temp_new.txt</span><br><span class="line">[root@localhost opt]#</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="cat指令"><a href="#cat指令" class="headerlink" title="cat指令"></a>cat指令</h3><p>查看文件内容</p><ul><li>cat [选项] 目标文件</li><li>-n ：显示行号</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost opt]# cat -n  temp_new.txt</span><br><span class="line">     1  wudiyang</span><br><span class="line">     2  yangwudi</span><br><span class="line">     3  yangdiwu</span><br><span class="line">     4  diwuyang</span><br><span class="line">     5  yangxiaosa</span><br><span class="line">     6</span><br><span class="line">[root@localhost opt]#</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="more指令"><a href="#more指令" class="headerlink" title="more指令"></a>more指令</h3><p>查看文件内容（分页）</p><ul><li>more  目标文件</li></ul><table><thead><tr><th>操作</th><th>功能说明</th></tr></thead><tbody><tr><td>空格</td><td>下一页</td></tr><tr><td>enter</td><td>下一行</td></tr><tr><td>q</td><td>退出more</td></tr><tr><td>ctrl+f</td><td>向下滚动一屏</td></tr><tr><td>ctrl+b</td><td>返回上一屏</td></tr><tr><td>&#x3D;</td><td>输出当前行的行号</td></tr><tr><td>:f</td><td>输出文件名和当前行行号</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost opt]# more 1.txt temp_new.txt</span><br><span class="line">::::::::::::::</span><br><span class="line">1.txt</span><br><span class="line">::::::::::::::</span><br><span class="line">wudiyang</span><br><span class="line">yangwudi</span><br><span class="line">yangdiwu</span><br><span class="line">diwuyang</span><br><span class="line">yangxiaosa</span><br><span class="line"></span><br><span class="line">::::::::::::::</span><br><span class="line">temp_new.txt</span><br><span class="line">::::::::::::::</span><br><span class="line">wudiyang</span><br><span class="line">yangwudi</span><br><span class="line">yangdiwu</span><br><span class="line">diwuyang</span><br><span class="line">yangxiaosa</span><br><span class="line"></span><br><span class="line">[root@localhost opt]#</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="less指令"><a href="#less指令" class="headerlink" title="less指令"></a>less指令</h3><p>分页查看文件内容（比more更强大）</p><ul><li>less  目标文件</li></ul><p>与more类似，可以随意浏览文件</p><table><thead><tr><th>操作</th><th>功能说明</th></tr></thead><tbody><tr><td>空格键</td><td>向下翻动一页</td></tr><tr><td>[pagedown]</td><td>向下翻动一页</td></tr><tr><td>[pageup]</td><td>向上翻动一页</td></tr><tr><td>&#x2F;字串</td><td>向下搜寻【字串】的功能；n：向下查找；N：向上查找；</td></tr><tr><td>？字串</td><td>向上搜寻【字串】的功能；n：向上查找；N：向下查找；</td></tr><tr><td>q</td><td>离开这个less程序</td></tr></tbody></table><h3 id="head指令"><a href="#head指令" class="headerlink" title="head指令"></a>head指令</h3><p>head 命令可用于查看文件的开头部分的内容</p><ul><li>head 文件（默认查看文件头10行内容）</li><li>head -n 5 文件（查看文件头5行内容，5可以是任意数）</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost /]# head -n 2 /opt/temp_new.txt</span><br><span class="line">wudiyang</span><br><span class="line">yangwudi</span><br><span class="line">[root@localhost /]#</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="tail指令"><a href="#tail指令" class="headerlink" title="tail指令"></a>tail指令</h3><p>tail 命令可用于查看文件的内容，有一个常用的参数 -f 常用于查阅正在改变的日志文件。</p><ul><li>tail [参数] 文件</li><li>-f ：把文件最尾部的内容显示在屏幕上，并不断刷新</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost /]# tail -f /opt/temp_new.txt</span><br><span class="line">wudiyang</span><br><span class="line">yangwudi</span><br><span class="line">yangdiwu</span><br><span class="line">diwuyang</span><br><span class="line">yangxiaosa</span><br><span class="line"></span><br><span class="line">^C</span><br><span class="line">[root@localhost /]# </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="echo指令"><a href="#echo指令" class="headerlink" title="echo指令"></a>echo指令</h3><p>echo命令用于输出变量或常量内容到控制台</p><ul><li>echo 选项  输出内容</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost /]# echo &quot;woxiangshangan&quot;</span><br><span class="line">woxiangshangan</span><br><span class="line">[root@localhost /]#</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="gt-指令"><a href="#gt-指令" class="headerlink" title="&gt;指令"></a>&gt;指令</h3><p>将前一个查看指令中的结果覆盖写入到目标文件中，如果目标文件不存在，则新建。</p><ul><li>查看指令 &gt; 目标文件</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost opt]# cat 1.txt</span><br><span class="line">wudiyang</span><br><span class="line">yangwudi</span><br><span class="line">yangdiwu</span><br><span class="line">diwuyang</span><br><span class="line">yangxiaosa</span><br><span class="line"></span><br><span class="line">[root@localhost opt]# cat 1.txt &gt; 2.txt</span><br><span class="line">[root@localhost opt]# cat 2.txt</span><br><span class="line">wudiyang</span><br><span class="line">yangwudi</span><br><span class="line">yangdiwu</span><br><span class="line">diwuyang</span><br><span class="line">yangxiaosa</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="gt-gt-指令"><a href="#gt-gt-指令" class="headerlink" title="&gt;&gt;指令"></a>&gt;&gt;指令</h3><p>  将前一个查看指令中的结果追加写入到目标文件中，如果目标文件不存在，则新建。</p><ul><li>查看指令 &gt;&gt; 目标文件</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost opt]# cat 1.txt</span><br><span class="line">wudiyang</span><br><span class="line">yangwudi</span><br><span class="line">yangdiwu</span><br><span class="line">diwuyang</span><br><span class="line">yangxiaosa</span><br><span class="line"></span><br><span class="line">[root@localhost opt]# cat 1.txt &gt;&gt; 2.txt</span><br><span class="line">[root@localhost opt]# cat 2.txt</span><br><span class="line">wudiyang</span><br><span class="line">yangwudi</span><br><span class="line">yangdiwu</span><br><span class="line">diwuyang</span><br><span class="line">yangxiaosa</span><br><span class="line"></span><br><span class="line">wudiyang</span><br><span class="line">yangwudi</span><br><span class="line">yangdiwu</span><br><span class="line">diwuyang</span><br><span class="line">yangxiaosa</span><br><span class="line"></span><br><span class="line">[root@localhost opt]#</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="时间日期指令"><a href="#时间日期指令" class="headerlink" title="时间日期指令"></a>时间日期指令</h2><h3 id="date指令"><a href="#date指令" class="headerlink" title="date指令"></a>date指令</h3><p>Linux <strong>date</strong> 命令可以用来显示或设定系统的日期与时间。</p><ul><li>date（显示当前时间）</li><li>date + %Y（显示当前年份）</li><li>date + %m（显示当前月份）</li><li>date + %d（显示当前是哪一天）</li><li>date + “%Y-%m-%d %H:%M:%S”（显示年月日时分秒）</li><li>date -s 字符串时间（设置当前时间）</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost opt]# date &quot;+%Y-%m-%d %H:%M:%S&quot;</span><br><span class="line">2024-01-22 11:23:55</span><br><span class="line">[root@localhost opt]#</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="cal指令"><a href="#cal指令" class="headerlink" title="cal指令"></a>cal指令</h3><p>显示日历</p><ul><li>cal  参数  月份  年份</li><li>-1 显示一个月的月历</li><li>-3 显示系统前一个月、当前月、下一个月的月历</li><li>-y 显示当前年的日历</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost opt]# cal -1 9 2022</span><br><span class="line">      九月 2022</span><br><span class="line">日 一 二 三 四 五 六</span><br><span class="line">             1  2  3</span><br><span class="line"> 4  5  6  7  8  9 10</span><br><span class="line">11 12 13 14 15 16 17</span><br><span class="line">18 19 20 21 22 23 24</span><br><span class="line">25 26 27 28 29 30</span><br><span class="line"></span><br><span class="line">[root@localhost opt]#</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="搜索查找指令"><a href="#搜索查找指令" class="headerlink" title="搜索查找指令"></a>搜索查找指令</h2><h3 id="find指令"><a href="#find指令" class="headerlink" title="find指令"></a>find指令</h3><p>find指令将从指定目录向下递归地遍历其各个子目录，将满足条件的文件或者目录显示在终端。</p><ul><li>find  搜索范围  选项</li><li>-name ：按名称查找，支持通配符。</li><li>-user：按用户名查找。</li><li>-size ：按文件大小查找。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost opt]# find -name 1.txt</span><br><span class="line">./1.txt</span><br><span class="line">[root@localhost opt]#</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="grep指令"><a href="#grep指令" class="headerlink" title="grep指令"></a>grep指令</h3><p>Linux grep (global regular expression) 命令用于查找文件里符合条件的字符串或正则表达式。</p><ul><li>grep  options  pattern  files</li><li>pattern :表示要查找的字符串或正则表达式</li><li>files ：表示要查找的文件名，可以同时查找多个文件，如果忽略files参数，则默认从标准输入中读取数据</li><li>-i：忽略大小写进行匹配</li><li>-v：反向查找，只打印不匹配的行</li><li>-n：显示匹配行的行号</li><li>-r：递归查找子目录中的文件</li><li>-l：只打印匹配的文件名</li><li>-c：只打印匹配的行数</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost opt]# cat 1.txt | grep -i yang</span><br><span class="line">wudiyang</span><br><span class="line">yangwudi</span><br><span class="line">yangdiwu</span><br><span class="line">diwuyang</span><br><span class="line">yangxiaosa</span><br><span class="line">[root@localhost opt]#</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  说明：grep 过滤查找，管道符，“|”，表示将前一个命令的处理结果输出传递给后面的命令处理。</p><h2 id="压缩和解压指令"><a href="#压缩和解压指令" class="headerlink" title="压缩和解压指令"></a>压缩和解压指令</h2><h3 id="gzip指令"><a href="#gzip指令" class="headerlink" title="gzip指令"></a>gzip指令</h3><p>压缩文件，将文件压缩为*.gz文件存放在原文件所在目录，压缩成功后会把原文件删除。用于压缩单个文件。</p><ul><li>gzip 文件名</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost opt]# gzip 1.txt</span><br><span class="line">[root@localhost opt]# ll</span><br><span class="line">总用量 12</span><br><span class="line">-rw-r--r--. 1 root root 57 1月  11 14:51 1.txt.gz</span><br><span class="line">-rw-r--r--. 1 root root 96 1月  22 10:39 2.txt</span><br><span class="line">drwxr-xr-x. 2 root root  6 10月 31 2018 rh</span><br><span class="line">-rw-r--r--. 1 root root 48 1月  11 14:28 temp_new.txt</span><br><span class="line">[root@localhost opt]#</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="gunzip指令"><a href="#gunzip指令" class="headerlink" title="gunzip指令"></a>gunzip指令</h3><p>解压缩文件命令，解压成功后存放在原压缩文件所在目录，并且把原压缩文件删除。</p><ul><li>gunzip  压缩文件名</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost opt]# ll</span><br><span class="line">总用量 12</span><br><span class="line">-rw-r--r--. 1 root root 57 1月  11 14:51 1.txt.gz</span><br><span class="line">-rw-r--r--. 1 root root 96 1月  22 10:39 2.txt</span><br><span class="line">drwxr-xr-x. 2 root root  6 10月 31 2018 rh</span><br><span class="line">-rw-r--r--. 1 root root 48 1月  11 14:28 temp_new.txt</span><br><span class="line">[root@localhost opt]# gunzip 1.txt.gz</span><br><span class="line">[root@localhost opt]# ll</span><br><span class="line">总用量 12</span><br><span class="line">-rw-r--r--. 1 root root 48 1月  11 14:51 1.txt</span><br><span class="line">-rw-r--r--. 1 root root 96 1月  22 10:39 2.txt</span><br><span class="line">drwxr-xr-x. 2 root root  6 10月 31 2018 rh</span><br><span class="line">-rw-r--r--. 1 root root 48 1月  11 14:28 temp_new.txt</span><br><span class="line">[root@localhost opt]#</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="zip指令"><a href="#zip指令" class="headerlink" title="zip指令"></a>zip指令</h3><p>将指定文件或目录压缩成XXX.zip文件，用于压缩所有文件结构</p><ul><li>zip  [选项] XXX.zip 将要压缩的内容</li><li>-r：递归压缩，即压缩目录</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost opt]# ll</span><br><span class="line">总用量 12</span><br><span class="line">-rw-r--r--. 1 root root 48 1月  11 14:51 1.txt</span><br><span class="line">-rw-r--r--. 1 root root 96 1月  22 10:39 2.txt</span><br><span class="line">drwxr-xr-x. 2 root root  6 10月 31 2018 rh</span><br><span class="line">-rw-r--r--. 1 root root 48 1月  11 14:28 temp_new.txt</span><br><span class="line">[root@localhost opt]# zip -r 666.zip rh</span><br><span class="line">  adding: rh/ (stored 0%)</span><br><span class="line">[root@localhost opt]# ll</span><br><span class="line">总用量 16</span><br><span class="line">-rw-r--r--. 1 root root  48 1月  11 14:51 1.txt</span><br><span class="line">-rw-r--r--. 1 root root  96 1月  22 10:39 2.txt</span><br><span class="line">-rw-r--r--. 1 root root 156 1月  22 15:01 666.zip</span><br><span class="line">drwxr-xr-x. 2 root root   6 10月 31 2018 rh</span><br><span class="line">-rw-r--r--. 1 root root  48 1月  11 14:28 temp_new.txt</span><br><span class="line">[root@localhost opt]#</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="unzip指令"><a href="#unzip指令" class="headerlink" title="unzip指令"></a>unzip指令</h3><p>Linux unzip命令用于解压缩zip文件</p><ul><li>unzip zip文件</li><li>-d：指定解压后文件的存放目录</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost opt]# ll</span><br><span class="line">总用量 16</span><br><span class="line">-rw-r--r--. 1 root root  48 1月  11 14:51 1.txt</span><br><span class="line">-rw-r--r--. 1 root root  96 1月  22 10:39 2.txt</span><br><span class="line">-rw-r--r--. 1 root root 156 1月  22 15:01 666.zip</span><br><span class="line">drwxr-xr-x. 2 root root   6 10月 31 2018 rh</span><br><span class="line">-rw-r--r--. 1 root root  48 1月  11 14:28 temp_new.txt</span><br><span class="line">[root@localhost opt]# unzip -d ./rh 666.zip</span><br><span class="line">Archive:  666.zip</span><br><span class="line">   creating: ./rh/rh/</span><br><span class="line">[root@localhost opt]# ll</span><br><span class="line">总用量 16</span><br><span class="line">-rw-r--r--. 1 root root  48 1月  11 14:51 1.txt</span><br><span class="line">-rw-r--r--. 1 root root  96 1月  22 10:39 2.txt</span><br><span class="line">-rw-r--r--. 1 root root 156 1月  22 15:01 666.zip</span><br><span class="line">drwxr-xr-x. 3 root root  16 1月  22 15:11 rh</span><br><span class="line">-rw-r--r--. 1 root root  48 1月  11 14:28 temp_new.txt</span><br><span class="line">[root@localhost opt]# cd rh</span><br><span class="line">[root@localhost rh]# ll</span><br><span class="line">总用量 0</span><br><span class="line">drwxr-xr-x. 2 root root 6 10月 31 2018 rh</span><br><span class="line">[root@localhost rh]#</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="tar指令"><a href="#tar指令" class="headerlink" title="tar指令"></a>tar指令</h3><p>打包或者解压文件</p><ul><li>tar [选项] XXX.tar.gz [打包的内容]</li><li>-c：产生.tar.gz打包文件</li><li>-v：显示详情信息</li><li>-f：指定压缩后的文件名</li><li>-z：通过gzip指令处理备份文件</li><li>-x：解压.tar.gz文件</li><li>-C：指定解压到哪个目录</li><li>-t：列出文件内容</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//打包并压缩一个文件</span><br><span class="line">[root@localhost opt]# ll</span><br><span class="line">总用量 16</span><br><span class="line">-rw-r--r--. 1 root root  48 1月  11 14:51 1.txt</span><br><span class="line">-rw-r--r--. 1 root root  96 1月  22 10:39 2.txt</span><br><span class="line">-rw-r--r--. 1 root root 156 1月  22 15:01 666.zip</span><br><span class="line">drwxr-xr-x. 3 root root  16 1月  22 15:11 rh</span><br><span class="line">-rw-r--r--. 1 root root  48 1月  11 14:28 temp_new.txt</span><br><span class="line">[root@localhost opt]# tar -zcvf yang.tar.gz 1.txt 2.txt</span><br><span class="line">1.txt</span><br><span class="line">2.txt</span><br><span class="line">[root@localhost opt]# ll</span><br><span class="line">总用量 20</span><br><span class="line">-rw-r--r--. 1 root root  48 1月  11 14:51 1.txt</span><br><span class="line">-rw-r--r--. 1 root root  96 1月  22 10:39 2.txt</span><br><span class="line">-rw-r--r--. 1 root root 156 1月  22 15:01 666.zip</span><br><span class="line">drwxr-xr-x. 3 root root  16 1月  22 15:11 rh</span><br><span class="line">-rw-r--r--. 1 root root  48 1月  11 14:28 temp_new.txt</span><br><span class="line">-rw-r--r--. 1 root root 172 1月  22 16:04 yang.tar.gz</span><br><span class="line">[root@localhost opt]#</span><br><span class="line"></span><br><span class="line">//查看一个压缩文件</span><br><span class="line">[root@localhost opt]# ll</span><br><span class="line">总用量 20</span><br><span class="line">-rw-r--r--. 1 root root  48 1月  11 14:51 1.txt</span><br><span class="line">-rw-r--r--. 1 root root  96 1月  22 10:39 2.txt</span><br><span class="line">-rw-r--r--. 1 root root 156 1月  22 15:01 666.zip</span><br><span class="line">drwxr-xr-x. 3 root root  16 1月  22 15:11 rh</span><br><span class="line">-rw-r--r--. 1 root root  48 1月  11 14:28 temp_new.txt</span><br><span class="line">-rw-r--r--. 1 root root 172 1月  22 16:04 yang.tar.gz</span><br><span class="line">[root@localhost opt]# tar -ztvf yang.tar.gz</span><br><span class="line">-rw-r--r-- root/root        48 2024-01-11 14:51 1.txt</span><br><span class="line">-rw-r--r-- root/root        96 2024-01-22 10:39 2.txt</span><br><span class="line">[root@localhost opt]#</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//解压一个压缩文件</span><br><span class="line">[root@localhost opt]# tar -zxvf yang.tar.gz -C ./rh/</span><br><span class="line">1.txt</span><br><span class="line">2.txt</span><br><span class="line">[root@localhost opt]# ll</span><br><span class="line">总用量 20</span><br><span class="line">-rw-r--r--. 1 root root  48 1月  11 14:51 1.txt</span><br><span class="line">-rw-r--r--. 1 root root  96 1月  22 10:39 2.txt</span><br><span class="line">-rw-r--r--. 1 root root 156 1月  22 15:01 666.zip</span><br><span class="line">drwxr-xr-x. 3 root root  42 1月  22 16:10 rh</span><br><span class="line">-rw-r--r--. 1 root root  48 1月  11 14:28 temp_new.txt</span><br><span class="line">-rw-r--r--. 1 root root 172 1月  22 16:04 yang.tar.gz</span><br><span class="line">[root@localhost opt]# cd rh</span><br><span class="line">[root@localhost rh]# ll</span><br><span class="line">总用量 8</span><br><span class="line">-rw-r--r--. 1 root root 48 1月  11 14:51 1.txt</span><br><span class="line">-rw-r--r--. 1 root root 96 1月  22 10:39 2.txt</span><br><span class="line">drwxr-xr-x. 2 root root  6 10月 31 2018 rh</span><br><span class="line">[root@localhost rh]#</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="组管理指令"><a href="#组管理指令" class="headerlink" title="组管理指令"></a>组管理指令</h2><h3 id="Linux组的基本介绍"><a href="#Linux组的基本介绍" class="headerlink" title="Linux组的基本介绍"></a>Linux组的基本介绍</h3><p>在linux中每个用户必须属于一个组，不能独立与组外，可以改变用户所属组</p><p>在linux中每个文件有所有者、所在的组、其他组，也可以改变文件所在组</p><h3 id="文件-x2F-目录的所有者"><a href="#文件-x2F-目录的所有者" class="headerlink" title="文件&#x2F;目录的所有者"></a>文件&#x2F;目录的所有者</h3><p>一般为文件的创建者，谁创建了该文件，就自然地成为该文件的所有者，默认情况下所有者所在的组也是该文件所在的组</p><h3 id="查看文件所有者和所在组指令"><a href="#查看文件所有者和所在组指令" class="headerlink" title="查看文件所有者和所在组指令"></a>查看文件所有者和所在组指令</h3><ul><li>ls -ahl 文件名</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost rh]# ls -ahl</span><br><span class="line">总用量 8.0K</span><br><span class="line">drwxr-xr-x. 3 root root 42 1月  22 16:10 .</span><br><span class="line">drwxr-xr-x. 3 root root 96 1月  22 16:04 ..</span><br><span class="line">-rw-r--r--. 1 root root 48 1月  11 14:51 1.txt</span><br><span class="line">-rw-r--r--. 1 root root 96 1月  22 10:39 2.txt</span><br><span class="line">drwxr-xr-x. 2 root root  6 10月 31 2018 rh</span><br><span class="line">[root@localhost rh]# ls -ahl 1.txt</span><br><span class="line">-rw-r--r--. 1 root root 48 1月  11 14:51 1.txt</span><br><span class="line">[root@localhost rh]#</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="修改文件所有者指令"><a href="#修改文件所有者指令" class="headerlink" title="修改文件所有者指令"></a>修改文件所有者指令</h3><ul><li>chown  新所有者 文件名</li><li>chown  新所有者:新组  文件名</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost rh]# ls -ahl</span><br><span class="line">总用量 8.0K</span><br><span class="line">drwxr-xr-x. 3 root root 42 1月  22 16:10 .</span><br><span class="line">drwxr-xr-x. 3 root root 96 1月  22 16:04 ..</span><br><span class="line">-rw-r--r--. 1 root root 48 1月  11 14:51 1.txt</span><br><span class="line">-rw-r--r--. 1 root root 96 1月  22 10:39 2.txt</span><br><span class="line">drwxr-xr-x. 2 root root  6 10月 31 2018 rh</span><br><span class="line">[root@localhost rh]# chown admin:admin 1.txt</span><br><span class="line">[root@localhost rh]# ls -ahl</span><br><span class="line">总用量 8.0K</span><br><span class="line">drwxr-xr-x. 3 root  root  42 1月  22 16:10 .</span><br><span class="line">drwxr-xr-x. 3 root  root  96 1月  22 16:04 ..</span><br><span class="line">-rw-r--r--. 1 admin admin 48 1月  11 14:51 1.txt</span><br><span class="line">-rw-r--r--. 1 root  root  96 1月  22 10:39 2.txt</span><br><span class="line">drwxr-xr-x. 2 root  root   6 10月 31 2018 rh</span><br><span class="line">[root@localhost rh]#</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="修改文件所在组指令"><a href="#修改文件所在组指令" class="headerlink" title="修改文件所在组指令"></a>修改文件所在组指令</h3><ul><li>chgrp 新组名  文件名</li><li>-R：如果是目录则使其下所有子文件或目录递归生效</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost rh]# ls -ahl</span><br><span class="line">总用量 8.0K</span><br><span class="line">drwxr-xr-x. 3 root  root  42 1月  22 16:10 .</span><br><span class="line">drwxr-xr-x. 3 root  root  96 1月  22 16:04 ..</span><br><span class="line">-rw-r--r--. 1 admin admin 48 1月  11 14:51 1.txt</span><br><span class="line">-rw-r--r--. 1 root  root  96 1月  22 10:39 2.txt</span><br><span class="line">drwxr-xr-x. 2 root  root   6 10月 31 2018 rh</span><br><span class="line">[root@localhost rh]# chgrp admin 2.txt</span><br><span class="line">[root@localhost rh]# ls -ahl</span><br><span class="line">总用量 8.0K</span><br><span class="line">drwxr-xr-x. 3 root  root  42 1月  22 16:10 .</span><br><span class="line">drwxr-xr-x. 3 root  root  96 1月  22 16:04 ..</span><br><span class="line">-rw-r--r--. 1 admin admin 48 1月  11 14:51 1.txt</span><br><span class="line">-rw-r--r--. 1 root  admin 96 1月  22 10:39 2.txt</span><br><span class="line">drwxr-xr-x. 2 root  root   6 10月 31 2018 rh</span><br><span class="line">[root@localhost rh]#</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="权限管理指令"><a href="#权限管理指令" class="headerlink" title="权限管理指令"></a>权限管理指令</h2><h3 id="权限管理介绍"><a href="#权限管理介绍" class="headerlink" title="权限管理介绍"></a>权限管理介绍</h3><p>这里所说的权限都是文件和目录的权限。在linux中，每一个文件和目录都有自己的访问权限，通过文件列表可以查看到。</p><h3 id="RWX权限详解"><a href="#RWX权限详解" class="headerlink" title="RWX权限详解"></a>RWX权限详解</h3><h4 id="rwx作用到文件"><a href="#rwx作用到文件" class="headerlink" title="rwx作用到文件"></a>rwx作用到文件</h4><ol><li>[r]代表可读（read）：可以读取，查看</li><li>[w]代表可写（write）：可以修改，但是不代表可以删除文件，删除一个文件的前提条件是对该文件所在的目录有写权限，才能删除该文件。</li><li>[x]代表可是执行（execute）：可以被执行</li></ol><h4 id="rwx作用到目录"><a href="#rwx作用到目录" class="headerlink" title="rwx作用到目录"></a>rwx作用到目录</h4><ol><li>[r]代表可读（read）：可以读取，ls查看目录内容</li><li>[w]代表可写（write）：可以修改，目录内创建+删除+重命名目录</li><li>[x]代表可执行（execute）：可以进入该目录</li></ol><h4 id="rwx用数字表示"><a href="#rwx用数字表示" class="headerlink" title="rwx用数字表示"></a>rwx用数字表示</h4><p>r&#x3D;4(即 2^2^),w&#x3D;2(即2^1^),x&#x3D;1(即2^0^)</p><h2 id="权限管理指令-1"><a href="#权限管理指令-1" class="headerlink" title="权限管理指令"></a>权限管理指令</h2><h3 id="修改文件-x2F-目录权限的指令chmod"><a href="#修改文件-x2F-目录权限的指令chmod" class="headerlink" title="修改文件&#x2F;目录权限的指令chmod"></a>修改文件&#x2F;目录权限的指令chmod</h3><h4 id="通过r、w、x变更权限"><a href="#通过r、w、x变更权限" class="headerlink" title="通过r、w、x变更权限"></a>通过r、w、x变更权限</h4><ol><li>chmod u&#x3D;rwx,g&#x3D;rx,0&#x3D;x 文件目录名</li><li>chmod o+w 文件目录名</li><li>chmod a-x 文件目录名</li></ol><p>说明：u、g、o、a分别代表文件所有者、文件所在组用户、其他组用户、所有用户；&#x3D;、+、- 分别代表设置权限、增加权限、去掉权限</p><h4 id="通过数字变更权限"><a href="#通过数字变更权限" class="headerlink" title="通过数字变更权限"></a>通过数字变更权限</h4><p>chomd  一组三个数字  文件目录名</p><p>说明：r&#x3D;4 w&#x3D;2 x&#x3D;1 rwx&#x3D;4+2+1&#x3D;7</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost rh]# ls -ahl</span><br><span class="line">总用量 8.0K</span><br><span class="line">drwxr-xr-x. 3 root  root  42 1月  22 16:10 .</span><br><span class="line">drwxr-xr-x. 3 root  root  96 1月  22 16:04 ..</span><br><span class="line">-rw-r--r--. 1 admin admin 48 1月  11 14:51 1.txt</span><br><span class="line">-rw-r--r--. 1 root  admin 96 1月  22 10:39 2.txt</span><br><span class="line">drwxr-xr-x. 2 root  root   6 10月 31 2018 rh</span><br><span class="line">[root@localhost rh]# chmod 777 1.txt</span><br><span class="line">[root@localhost rh]# ls -ahl</span><br><span class="line">总用量 8.0K</span><br><span class="line">drwxr-xr-x. 3 root  root  42 1月  22 16:10 .</span><br><span class="line">drwxr-xr-x. 3 root  root  96 1月  22 16:04 ..</span><br><span class="line">-rwxrwxrwx. 1 admin admin 48 1月  11 14:51 1.txt</span><br><span class="line">-rw-r--r--. 1 root  admin 96 1月  22 10:39 2.txt</span><br><span class="line">drwxr-xr-x. 2 root  root   6 10月 31 2018 rh</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术连连看 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客移动后重新部署</title>
      <link href="/2023/12/25/%E5%8D%9A%E5%AE%A2%E7%A7%BB%E5%8A%A8%E5%90%8E%E9%87%8D%E6%96%B0%E9%83%A8%E7%BD%B2/"/>
      <url>/2023/12/25/%E5%8D%9A%E5%AE%A2%E7%A7%BB%E5%8A%A8%E5%90%8E%E9%87%8D%E6%96%B0%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="更换电脑或者多电脑同时维护博客"><a href="#更换电脑或者多电脑同时维护博客" class="headerlink" title="更换电脑或者多电脑同时维护博客"></a><center>更换电脑或者多电脑同时维护博客</center></h2><ol><li><p>在git上拉取代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone &lt;代码地址&gt;</span><br></pre></td></tr></table></figure></li><li><p>在博客路径下，下载npm包</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wudiyang@LAPTOP-KPI0GRB3 MINGW64 /e/YangFengLiu (hexo)</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure></li><li><p>进行博客的基本操作</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo n &quot;文章标题&quot;  //新建文章</span><br><span class="line">hexo g           //生成网站静态文件到默认设置的 public 文件夹</span><br><span class="line">hexo s           //启动本地服务器</span><br><span class="line">hexo clean       //清除缓存文件和已生成的静态文件</span><br><span class="line">hexo d           //部署网站</span><br><span class="line">hexo new draft &quot;文章标题&quot; //新建草稿</span><br><span class="line">hexo p &lt;草稿名称&gt;   //发布草稿</span><br><span class="line">hexo s --draft    //本机预览草稿</span><br></pre></td></tr></table></figure></li><li><p>上传代码到git</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add -A </span><br><span class="line">git commit -m &quot;备注&quot;</span><br><span class="line">git push origin 分支名  // 可简写为 git push;   origin为远程主机名 默认为origin  可使用git remote 命令查看已添加的远程主机名</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术连连看 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机配置固定ip</title>
      <link href="/2023/12/22/%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%85%8D%E7%BD%AE%E5%9B%BA%E5%AE%9Aip/"/>
      <url>/2023/12/22/%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%85%8D%E7%BD%AE%E5%9B%BA%E5%AE%9Aip/</url>
      
        <content type="html"><![CDATA[<p>​    使用的虚拟机为vm17，装入linux系统CentOS7，创建好虚拟机后IP总是自动改变，于是想要配置固定ip。</p><ol><li><p>首先cd到<code>/etc/sysconfig/network-scripts</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost /]# cd /etc/sysconfig/network-scripts</span><br><span class="line">[root@localhost network-scripts]# </span><br></pre></td></tr></table></figure></li><li><p>修改<code>ifcdf-ens33</code>文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost network-scripts]# vim ifcif-ens33</span><br><span class="line"></span><br><span class="line">//文件内容</span><br><span class="line">PROXY_METHOD=none</span><br><span class="line">BROWSER_ONLY=no</span><br><span class="line">BOTTPROTO=static//将ip改为静态获取</span><br><span class="line">#BOOTPROTO=dhcp</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=yes</span><br><span class="line">IPV6_AUTOCONF=yes</span><br><span class="line">IPV6_DEFROUTE=yes</span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class="line">NAME=ens33</span><br><span class="line">UUID=661d2508-8d73-4d5c-b1b4-4f2f6d7100c4</span><br><span class="line">DEVICE=ens33</span><br><span class="line">ONBOOT=yes//开启自启</span><br><span class="line">//以下内容新增</span><br><span class="line">ZONE=public</span><br><span class="line">IPADDR=192.168.33.131//需要配置的静态ip</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">GETEWAY=192.168.33.2//网关</span><br><span class="line">DNS1=114.114.114.114</span><br><span class="line">DNS2=8.8.8.8</span><br><span class="line">NM_CONTROLLED=no//必须配置，将网络设备脱离NetworkManager服务的管理</span><br><span class="line"></span><br><span class="line">//点击ESC，输入“:wq”保存退出vim编辑器</span><br></pre></td></tr></table></figure></li><li><p>配置永久路由，修改（新建）route-ens33文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost network-scripts]# vim route-ens33</span><br><span class="line"></span><br><span class="line">//修改为以下内容</span><br><span class="line">192.168.33.0/24 via 192.168.33.2</span><br><span class="line">0.0.0.0/0 via 192.168.33.2</span><br><span class="line"></span><br><span class="line">//点击ESC，输入“:wq”保存退出vim编辑器</span><br></pre></td></tr></table></figure></li><li><p>重启网络服务<code>service network restart</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost network-scripts]# vim route-ens33</span><br><span class="line">[root@localhost network-scripts]# service network restart</span><br><span class="line">Restarting network (via systemctl):                        [  确定  ]</span><br><span class="line">[root@localhost network-scripts]# </span><br></pre></td></tr></table></figure></li><li><p>点击虚拟机 工具栏-编辑-虚拟网络编辑器，点击更改设置，赋予管理员权限，根据图片配置信息</p><p><img src="/2023/12/22/%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%85%8D%E7%BD%AE%E5%9B%BA%E5%AE%9Aip/%E7%AC%AC%E4%B8%80%E6%AD%A5.png" alt="第一步"></p><p><img src="/2023/12/22/%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%85%8D%E7%BD%AE%E5%9B%BA%E5%AE%9Aip/%E7%AC%AC%E4%BA%8C%E6%AD%A5.png" alt="第二步"></p><p><img src="/2023/12/22/%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%85%8D%E7%BD%AE%E5%9B%BA%E5%AE%9Aip/%E7%AC%AC%E4%B8%89%E6%AD%A5.png" alt="第三步"></p></li><li><p>测试是否可以联网，联网成功，<code>Ctrl + C </code>取消<code>ping</code>命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost network-scripts]# ping www.baidu.com</span><br><span class="line">PING www.a.shifen.com (110.242.68.4) 56(84) bytes of data.</span><br><span class="line">64 bytes from 110.242.68.4 (110.242.68.4): icmp_seq=1 ttl=128 time=17.2 ms</span><br><span class="line">64 bytes from 110.242.68.4 (110.242.68.4): icmp_seq=2 ttl=128 time=17.6 ms</span><br><span class="line">64 bytes from 110.242.68.4 (110.242.68.4): icmp_seq=3 ttl=128 time=17.7 ms</span><br><span class="line">64 bytes from 110.242.68.4 (110.242.68.4): icmp_seq=4 ttl=128 time=17.8 ms</span><br><span class="line">^C</span><br><span class="line">--- www.a.shifen.com ping statistics ---</span><br><span class="line">4 packets transmitted, 4 received, 0% packet loss, time 7075ms</span><br><span class="line">rtt min/avg/max/mdev = 17.243/17.620/17.897/0.239 ms</span><br><span class="line">[root@localhost network-scripts]# </span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术连连看 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟机 </tag>
            
            <tag> CentOS7 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>综合写作</title>
      <link href="/2023/07/11/%E7%BB%BC%E5%90%88%E5%86%99%E4%BD%9C/"/>
      <url>/2023/07/11/%E7%BB%BC%E5%90%88%E5%86%99%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h3 id="开头万能句式："><a href="#开头万能句式：" class="headerlink" title="开头万能句式："></a>开头万能句式：</h3><ol><li>“九层高台起于垒土，千里之行始于足下”</li><li>概括积极方面+描述消极方面+综合分析（原因、影响、重要性、必要性）+亮明总论点；</li><li>“民之所望， 政之所向。”无论是…..；还是…【好】….；亦或是…【好】….，无不彰显出……….的巨大进步&#x2F;的发展&#x2F;的力量&#x2F;取得了骄人佳绩。但是…….的问题亦不容忽视&#x2F;依旧存在&#x2F;值得引起警惕。“千里之体溃于蚁穴”，若听之任之，必将对导致…【危害】….，成为…..之路的“绊脚石”。因此+【中心论点】</li><li>在…背景…的今天。关于…主题…，在社会产生了各种各样的声音。有人说…观点 1…；有人说…观点 2…；还有人说…观点 3…。而我要说，…总论点…。</li><li>君不见时下中国，…问题…；君不见当前社会，…问题…。…核心问题…已经威胁国之根本，动摇社会之根基，突破…核心问题…困局已经时不我待，迫在眉睫。那么如何才能破解…核心问题…难题？关键在于…总论点…</li></ol><h3 id="结尾万能句式："><a href="#结尾万能句式：" class="headerlink" title="结尾万能句式："></a>结尾万能句式：</h3><ol><li>…是历史车轮不断向前的助力；… 是推进体制改革的关键；… 是完善政府职能的核心，因此更要奋勇争先，所向披靡，才能战无不胜；</li><li>筑牢信仰之基，不足精神之钙，把稳思想之舵；</li><li>只有… ，才能谱写壮丽诗篇，书写理想的伟大；只有… ，才能奏响华彩乐章，讴歌实干的壮美；只有…，才能会就璀璨蓝图，编织愿景的美好；</li><li>忆往昔，“雄关漫道真如铁”，依靠… 我们实现了站起来；看今朝，“人间正道是沧桑”，依靠… 我们实现了富起来；待明日，”长风破浪会有时”，依靠… ，我们定会实现强起来；</li><li>唯有… ，我们才能成为过往历史的守护者；唯有… ，我们才能成为今日安康的践行者；唯有… ，我们才能成为未来辉煌的引导者；</li></ol><h3 id="论证素材："><a href="#论证素材：" class="headerlink" title="论证素材："></a>论证素材：</h3><h4 id="杂交水稻之父袁隆平"><a href="#杂交水稻之父袁隆平" class="headerlink" title="杂交水稻之父袁隆平"></a>杂交水稻之父袁隆平</h4><p>中国杂交水稻之父，中国工程院院士，“共和国勋章获得者”；研究水稻百折不挠，造福百姓甘为人梯。脚下浸泥土，心中怀大爱。国之人士为国为民的情怀，可入学生心田，实施代代相传；</p><p>袁隆平用一生践行为国家和人民服务的目标，也用自己的行动感染了无数青年人；</p><h4 id="布衣院士卢永根"><a href="#布衣院士卢永根" class="headerlink" title="布衣院士卢永根"></a>布衣院士卢永根</h4><p>一生家国情，桃李满天下</p><p>中国科学院院士，一辈子研究学术，保存了华南最大的野生水稻基因库。捐出毕生积蓄800多万扶持农业教育事业。</p><p>他以“科学无国界，科学家有祖国”的爱国情怀献身于农业教育和科研事业，为我国农业的教育和发展做出了杰出的贡献。</p><h4 id="物理泰斗杨振宁"><a href="#物理泰斗杨振宁" class="headerlink" title="物理泰斗杨振宁"></a>物理泰斗杨振宁</h4><p>清华大学高等研究院名誉院长、教授、著名物理学家，诺贝尔物理学奖获得者。他心系祖国科教事业，用自己的学术影响力吸引大批优秀科学家回国效力，为国家的客家发展、中外科技文化交流做出了重要贡献，推动了多所高校成立高等学术研究中心。</p><p>杨先生前前后后给祖国捐款上千万美金，连同诺贝尔奖金等全部捐献给中国教育事业。他站在科学和传统的交叉点上，惊才绝艳，心系家国，引领未来；</p><h4 id="中国好校长莫振高"><a href="#中国好校长莫振高" class="headerlink" title="中国好校长莫振高"></a>中国好校长莫振高</h4><p>广西都安高中的原校长，将“让瑶乡儿女走向世界”作为自己的座右铭。任教三十多年来跑遍每一位贫困生的家，万里“化缘”路圆了1.8万贫困学子的大学梦。爱是教育的灵魂，他将一生所爱化作不倒的脊梁，托起了家乡的教育事业，它将毕生心血化作不灭明烛，点亮了万计贫困孩子的命运之路；</p><h4 id="最美教师支月英"><a href="#最美教师支月英" class="headerlink" title="最美教师支月英"></a>最美教师支月英</h4><p>19岁远离家乡，不顾家人反对，到条件艰苦的山区支教，一干就是三十多年，坚守在偏远的山村讲台，从“支姐姐”到“支妈妈”，教育了大山深处的两代人。他用自身行动践行着初心和使命，在平凡岗位做出不平凡的业绩；</p><h4 id="燃灯校长张桂梅"><a href="#燃灯校长张桂梅" class="headerlink" title="燃灯校长张桂梅"></a>燃灯校长张桂梅</h4><p>三寸粉笔系深山，烛光千里耀云岭</p><p>坚守那个“只要还有一口气，就要站在讲台上”的诺言，建立起中国贫瘠大山里第一所免费的女子高中，凭一己之力，改变千位贫困女孩的命运；云山苍苍，江水泱泱；先生之风，山高水长。这10多年来，张桂梅忘记了折磨他的病痛和不幸。忘记了年龄和生死，用自己瘦小的肩膀为千名女孩撑开了一片天，让他们和其他孩子一样享受教育的公平，像更远的地方翱翔；</p><h4 id="两弹一星孙家栋"><a href="#两弹一星孙家栋" class="headerlink" title="两弹一星孙家栋"></a>两弹一星孙家栋</h4><p>著名航天技术专家，我国人造卫星技术和深空探测技术的开创者之一。几十年如一日，时刻以共产党员的标准严格要求自己和激励自己，在重大工程中国发挥先锋模范作用。用一辈子造“中国星”，古稀出征只为圆民族梦想。他用自己的坚守，在太空筑出一条属于中国的天路；</p><h4 id="大国工匠张东伟"><a href="#大国工匠张东伟" class="headerlink" title="大国工匠张东伟"></a>大国工匠张东伟</h4><p>超薄钢板焊接绣花，具有高超技艺，具备精湛技能，一丝不苟，精益求精，追求极致；对待工作凝神聚力，对每一个焊接精雕细刻，对每一道工序精心打磨，近乎完美。凭借的是传承和钻研，靠的是专注于磨砺，追求的是民族认可的责任感。他用焊枪书写殷瓦钢上的“绣花”，让“中国荣耀”远航；</p><h4 id="道德模范温金娥"><a href="#道德模范温金娥" class="headerlink" title="道德模范温金娥"></a>道德模范温金娥</h4><p>孝老爱亲温金娥，在平凡岗位中书写人生价值，用真情走向和美动人的家庭乐章。小学教师的她，勇于直面丈夫去世的困境，以柔弱之力照顾年迈的公婆和5岁的儿子，担起了整个家庭的重担。他没有创造惊天动地的伟业，但他孝老爱亲、勇于担当的大爱，在平凡中我们看到了一个平凡的个体，在社会上用品德扛起的责任、履行的义务、彰显的价值；</p><h4 id="失聪学霸江梦南"><a href="#失聪学霸江梦南" class="headerlink" title="失聪学霸江梦南"></a>失聪学霸江梦南</h4><p>失聪26年，考唇语考上清华博士。他是中国版的海伦凯勒，更是中国青年一代的榜样力量。为了从小的医生梦，她克服常人难以想象的困难，坚持学习。在他心中，不做弱者，靠的是“心有目标脚踏实地，不必患得患失”。他顽强拼搏的精神和不服输的毅力，激励着新一代的年轻人，为梦想风雨兼程；</p><h4 id="亚洲飞人苏炳添"><a href="#亚洲飞人苏炳添" class="headerlink" title="亚洲飞人苏炳添"></a>亚洲飞人苏炳添</h4><p>2012年苏炳添与博尔特同场竞技，感受到差距的他给自己立下目标：跑进百米九秒区。为此他反复训练摸索，大胆决定更换起跑脚，“重新学习跑步”。在东京奥运会，他跑出9秒83的成绩，打破亚洲纪录，成为首位闯进奥运会男子百米决赛的亚洲飞人。它超越了年龄和伤病，更超越了自己；</p><h4 id="郎平和女排精神"><a href="#郎平和女排精神" class="headerlink" title="郎平和女排精神"></a>郎平和女排精神</h4><p>中国女排主教练郎平，他因排球而生，为荣誉而战。把拼搏精神如钉子般砸进人生。他点燃几代青春，唤醒大国梦想。女排精神，是女排姑娘们的团结拼搏，是女排三十多年的精神传承，更是不忘初心、永不言弃的精神赞歌；</p><h3 id="名人名言"><a href="#名人名言" class="headerlink" title="名人名言"></a>名人名言</h3><ol><li>聪明处于勤奋，天才在于积累。——华罗庚</li><li>绳锯木断，水滴石穿。——《汉书》</li><li>政之所兴，在顺民心。——《左传》</li><li>国以民为本，社稷亦为民而立。——《论语》</li></ol>]]></content>
      
      
      <categories>
          
          <category> 死记硬背 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于文化常识</title>
      <link href="/2023/05/11/%E5%85%B3%E4%BA%8E%E6%96%87%E5%8C%96%E5%B8%B8%E8%AF%86/"/>
      <url>/2023/05/11/%E5%85%B3%E4%BA%8E%E6%96%87%E5%8C%96%E5%B8%B8%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p> <img src="/2023/05/11/%E5%85%B3%E4%BA%8E%E6%96%87%E5%8C%96%E5%B8%B8%E8%AF%86/%E7%9C%81%E4%BB%BD%E5%9C%B0%E5%9B%BE.jpg" alt="省份地图"></p><p><img src="/2023/05/11/%E5%85%B3%E4%BA%8E%E6%96%87%E5%8C%96%E5%B8%B8%E8%AF%86/%E5%B1%B1%E4%B8%9C%E7%9C%81%E5%9C%B0%E5%9B%BE.jpg" alt="山东省地图"></p><p> <strong>五岳</strong>：东岳泰山、西岳华山、南岳衡山、北岳恒山、中岳嵩山</p><p><strong>二十四节气</strong>：春雨惊春清谷天，夏满芒夏暑相连。秋处露秋寒霜降，冬雪雪冬小大寒。</p><p>立春、雨水、惊蛰、春分、清明、谷雨、立夏、小满、芒种、夏至、小暑、大暑、立秋、处暑、白露、秋分、寒露、霜降、立冬、小雪、大雪、冬至、小寒、大寒</p><p>8-14岁：<strong>总角</strong>之年；女子13岁<strong>豆蔻</strong>之年；男子15岁束<strong>发</strong>之年；20岁<strong>弱冠</strong>之年；30岁<strong>而立</strong>之年；四十岁<strong>不惑</strong>、强壮；五十岁<strong>年逾半百</strong>、<strong>知非</strong>之年、<strong>知命</strong>之年、艾服之年、大衍之年；60岁<strong>花甲</strong>之年、<strong>平头甲子</strong>、<strong>耳顺</strong>之年、<strong>杖乡</strong>之年；70岁<strong>古稀</strong>之年、<strong>杖国</strong>之年、<strong>致事</strong>之年、<strong>致政</strong>之年；80岁<strong>仗朝</strong>之年；80-90岁<strong>耄耋</strong>之年；90岁<strong>鲐背</strong>之年；100岁<strong>期颐</strong>之年；</p><p>海上邻国（<strong>6个</strong>）：印度尼西亚、马来西亚、文莱、菲律宾、日本、韩国</p><p>陆上邻国（<strong>14个</strong>）：朝鲜、俄罗斯、蒙古、哈萨克斯坦、吉尔吉斯斯坦、塔吉克斯坦、阿富汗、巴基斯坦、印度、尼泊尔、不丹、缅甸、老挝、越南</p><p>以少胜多的战役：长勺之战、官渡之战、赤壁之战、巨鹿之战、肥水之战、城濮之战、牧野之战</p><p>百家争鸣：<strong>儒家</strong>（孔子《论语》，孟子《孟子》性善论，荀子《荀子》性恶论）民贵君轻，提倡仁政；<strong>道家</strong>（老子《道德经》，庄子《庄子》）道是万物的本源，无为而治；<strong>墨家</strong>（墨子《墨子》）兼爱非攻；<strong>法家</strong>（韩非《韩非子》，李斯，商鞅）以法治国；<strong>名家</strong>（邓析，公孙龙）；<strong>阴阳家</strong>（邹衍）阴阳五行学说；<strong>纵横家</strong>（苏秦，张仪，鬼谷子）；<strong>杂家</strong>（吕不韦）；<strong>农家</strong>；<strong>小说家</strong>；<strong>兵家</strong>（孙武，孙膑）；<strong>医家</strong>（扁鹊）</p>]]></content>
      
      
      <categories>
          
          <category> 死记硬背 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文化常识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于管理</title>
      <link href="/2023/05/09/%E5%85%B3%E4%BA%8E%E7%AE%A1%E7%90%86/"/>
      <url>/2023/05/09/%E5%85%B3%E4%BA%8E%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="管理学效应"><a href="#管理学效应" class="headerlink" title="管理学效应"></a>管理学效应</h3><p>蝴蝶效应：初始条件十分微小的变化经过不断放大，对其未来状态会造成极其巨大的差别</p><p>青蛙现象：一些突变事件，往往容易引起人们的警觉，而易致人于死地的却是在自我感觉良好的情况下，对实际情况的逐渐恶化，没有清醒的察觉</p><p>鳄鱼法则：你发现自己的交易背离了市场的方向，必须立即止损，不得有任何延误，不得存有任何侥幸</p><p>羊群效应：就是比喻人都有一种从众心理，从众心理很容易导致盲从，而盲从往往会陷入骗局或遭到失败</p><p>手表定律：不能同时设置两个目标，不能同时被两个人领导</p><p>破窗效应：窗户破了不去修补，其他窗户也会莫名其妙被人打破，恶性循环</p><p>二八定律：80的财富在20的人手中</p><p>木桶理论：能装多少水取决于最短的木板</p><p>马太效应：强者越来越强，弱者越来越弱</p><p>鸟笼逻辑：人们绝大部分时间采用惯性思维</p><p>帕金森定律：没能力的人任用两个水平更低的人，使得机构臃肿，效率低下</p><p>晕轮效应：人际交往中，人身上表现出的某一方面特种会掩盖其他特征，造成认知障碍</p><p>霍桑效用：备受关注时生产效率会大大提高</p><p>责任分散效应：一个和尚挑水喝，两个和尚抬水喝，三个和尚没水喝；责任一定要具体到人</p><p>合成谬误：对于个体而言正确的事情，对于整体而言不一定正确</p><p>搭便车：一些人需要某种公共财产时，一开始说不需要，等别人付出代价取得后在不劳而获</p><p>机会成本：企业为了从事某项经营活动而放弃另一项经营活动的机会</p><h3 id="管理学基本原理"><a href="#管理学基本原理" class="headerlink" title="管理学基本原理"></a>管理学基本原理</h3><p>人本原理：1.人是社会人而不是经济人 2. 企业中存在着非正式组织 3. 新的管理能力在于提高工人满意度</p><p>系统原理：整体性、动态性、开放性、综合性、层次性、环境适应性</p><p>能级原理：1. 能级与职级配置，使能者有其位 2. 能级与岗位配置，使能者有其岗 3. 与待遇配置，使能者有其利 4. 能给予能级交叉配置，实现能力优化组合</p><p>效益原理：获取效益是管理的根本目的，重视经济效益，追求长期稳定的效益</p><p>信息原理：管理信息的三大基本特征1. 价值的不确定性2. 内容的可干扰性 3. 形式和内容的更替性</p><p>权变原理：有效的领导力措施是随机的，随时间、地点、空间、环境的变化而变化</p><h3 id="政府职能"><a href="#政府职能" class="headerlink" title="政府职能"></a>政府职能</h3><p>政治职能：国家最为核心的基本职能</p><p>经济职能：政策指导职能；宏观调控职能；检查监督职能；公共服务职能；完善市场机制职能</p><p>文化职能：发展科学技术职能；发展教育的职能；发展文化事业的职能；发展体育、卫生的职能</p><p>社会职能：社会福利职能；社会救济职能；社会保险职能；环境保护职能；社会服务职能</p><h3 id="行政组织具体结构类型"><a href="#行政组织具体结构类型" class="headerlink" title="行政组织具体结构类型"></a>行政组织具体结构类型</h3><p>直线型：从上至下垂直领导，呈金字塔结构；结构简单，联系便捷，管理成本低；权力集中，易造成权力滥用</p><p>职能型：将承担相同职能的管理业务和人员放在一起，可以有效地开发和使用技能，提高工作效率；分工较细，减轻管理者负担；不利于统一指挥</p><p>直线-职能参谋型（绝大多数企业）：两种结构的综合；既保证了统一指挥，有充分发挥各个业务作用；集权式结构，下级缺乏自主权，容易产生矛盾</p><p>矩阵型：加强了横向联系，具有较大的机动性，相互帮助；成员不固定在一个位置，难以分清责任</p><h3 id="行政监督"><a href="#行政监督" class="headerlink" title="行政监督"></a>行政监督</h3><p>内部监督：自我行政监督和专门行政监督、审计监督</p><p>外部监督：立法监督、司法监督、政党监督、社会监督</p><p>社会监督：社会团体、新闻媒体、公民个人</p><p>政党监督：共产党和民主党的监督</p>]]></content>
      
      
      <categories>
          
          <category> 死记硬背 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于中国历史</title>
      <link href="/2023/05/08/%E5%85%B3%E4%BA%8E%E4%B8%AD%E5%9B%BD%E5%8E%86%E5%8F%B2/"/>
      <url>/2023/05/08/%E5%85%B3%E4%BA%8E%E4%B8%AD%E5%9B%BD%E5%8E%86%E5%8F%B2/</url>
      
        <content type="html"><![CDATA[<p>夏 -&gt; 商 -&gt; 西周 -&gt; 东周（春秋战国） -&gt; 秦 -&gt; 西汉 -&gt; 东汉 -&gt; 三国 -&gt; 两晋 -&gt; 南北朝 -&gt; 隋 -&gt; 唐 -&gt; 北宋 -&gt; 南宋 -&gt; 元 -&gt; 明 -&gt; 清</p><p>夏朝（公元前2070年）：<strong>禹</strong>建立夏朝，中国最早的<strong>奴隶制</strong>国家，王位世袭制代替禅让制</p><p>商朝（公元前1600年）：<strong>商汤</strong>灭夏，商朝建立；商王盘庚迁<strong>殷</strong>，也叫<strong>殷朝</strong>；文字可考的历史开始于<strong>商</strong>朝，最早的文字是<strong>甲骨文</strong>；</p><p>西周（公元前1064年）：<strong>周武王姬发</strong>建立周朝，定都<strong>镐京</strong></p><p>春秋（公元前770年-公元前476年）：<strong>齐桓公</strong>即位，认<strong>管仲</strong>为相，春秋第一个霸主，最早出现铁农具；孙武著有《孙子兵法》</p><p>战国（公元前475年-公元前221年）：<strong>战国七雄</strong>（北燕南楚、西秦东齐、上中下是赵魏韩）；<strong>成都</strong>成为天府之国，孙膑著有《孙膑兵法》</p><p>秦朝（公元前221年）：秦王嬴政灭六国，建立中国历史上第一个统一王朝<strong>秦朝</strong>；郡县制，书同文（<strong>小篆</strong>），统一货币（<strong>圆形方孔钱</strong>），焚书坑儒；中国历史上第一次大规模农民起义（陈胜吴广领导大泽乡发起）</p><p>西汉（公元前202年）：刘邦（汉高祖）建立西汉，定都长安；卫青霍去病抗击匈奴；张骞出使西域；司马迁著《史记》，第一部<strong>纪传体</strong>通史，叙述从皇帝到汉武帝时期3000多年历史</p><p>东汉（公元25年）：刘秀（光武帝）建立东汉，定都洛阳；班超出使西域；官渡之战（曹操以弱胜强败袁绍）；赤壁之战；张仲景（伤寒杂病论）；蔡伦改进造纸术；张衡发明地动仪；前四史（《汉书》《后汉书》《史记》《三国志》）</p><p>三国时期（公元220年）：曹丕建魏，刘备建蜀，孙权建吴，三国鼎立；</p><p>两晋时期（公元280年）：西晋统一全国，结束东汉分裂局面</p><p>南北朝（公元420年）：贾思勰著有《齐民要术》，我国现存<strong>最早的，内容最完整</strong>的农书</p><p>隋朝（公元581年）：杨坚（隋文帝）建立，定都长安；三省六部制；杨广（隋炀帝）开通大运河；首创<strong>科举制</strong></p><p>唐朝（公元618年）：李渊(唐高祖)建立唐朝，定都长安；李世民（唐太宗）开创<strong>贞观之治</strong>；李隆基（唐玄宗）进入<strong>开元盛世</strong>；安史之乱-由盛转衰的转折点；</p><p>北宋（公元960年）：赵匡胤（宋太祖）发动陈桥兵变建立北宋，定都开封；王安石变法；发明活字印刷术；四川地区出现世界上最早的纸币-<strong>交子</strong></p><p>南宋（公元1127年）：靖康之变；苏湖熟，天下足</p><p>元朝（公元1271年）：忽必烈（元世祖）改国号元，迁都燕京（北京），改名大都；设置澎湖巡检司，管辖澎湖和琉球，最早将台湾纳入行政管辖范围</p><p>明朝（公元1368年）：朱元璋（明太祖）建立明朝，定都应天府（南京），明成祖迁都北京；开始修建长城；郑和七次下西洋；郑成功收复台湾；<strong>白银</strong>成为流通的货币</p><p>清朝（公元1683年）：康熙收复台湾；清朝设置台湾府，属<strong>福建</strong>省管辖；<strong>林则徐</strong>虎门销烟</p><hr><p>鸦片战争 -&gt; 第二次鸦片战争 -&gt; 甲午中法战争 -&gt; 中日战争 -&gt; 八国联军侵华战争</p><p>鸦片战争（1840年-1842年）：《南京条约》，割香港岛给英国；中美《望厦条约》；中法《黄埔条约》；<strong>开始沦为</strong>半殖民地半封建社会，中国近代史的<strong>开端</strong></p><p>第二次鸦片战争（1856年-1860年）：英法俄美签订《天津条约》，中俄《瑷珲条约》；英法俄《北京条约》</p><p>中法战争（1883年12月-1885年4月）：《中法新约》</p><p>甲午中日战争（1894年-1895年）：北洋水师全军覆没；中日《马关条约》；加深了中国社会半殖民地半封建化程度，帝国主义掀起瓜分中国的狂潮</p><p>八国联军侵华战争（1900年）：英美日俄法德意奥《辛丑条约》；中国近代史上赔款数目最庞大，主权丧失<strong>最</strong>严重的不平等条约，标志着中国<strong>完全沦为</strong>半殖民地半封建社会</p><hr><p>太平天国运动 -&gt; 洋务运动 -&gt; 戊戌变法 -&gt; 辛亥革命 -&gt; 新文化运动 -&gt; 五四运动</p><p>太平天国运动（1851年-1864年）：中国最大的一场农民反清运动；资本主义色彩的《<strong>资政新篇</strong>》</p><p>洋务运动（19史记60-90年代）：晚清洋务派进行的一场自救运动，前期口号“<strong>自强</strong>”，后期口号“<strong>求富</strong>”；师夷长技以制夷，中体西用；建立北洋海军；甲午中日战争中北洋海军全军覆没，标志着洋务运动宣告破产</p><p>戊戌变法（1898.6.11-1898.9.21）：百日维新，维新变法；公车上书（康有为梁启超反对签订《马关条约》）；<strong>戊戌六君子</strong>（谭嗣同、康广仁、林旭、杨深秀、刘光第、杨锐）</p><p>辛亥革命（资产阶级民主革命）：三民主义（<strong>民族、民生、民权</strong>）；1912.1.1 中华民国成立；近代中国比较完全意义上的资产阶级民主革命，推翻了清朝统治，结束了两千多年的封建帝制，建立共和国，是民主共和观念深入人心</p><p>新文化运动（1915年）：陈独秀主编《青年杂志》（后改为《新青年》）；主要阵地（《新青年》，北京大学）；提倡<strong>民主</strong>和<strong>科学</strong>（德先生和赛先生）；中国现代文学史上第一步白话小说《<strong>狂人日记</strong>》；沉重打击了统治中国2000多年的传统礼数，启发了人们的民主觉悟，为马克思主义在中国的传播和五四运动的爆发奠定了<strong>思想基础</strong></p><p>五四运动（1919.1）：巴黎和会中国外交失败；中国<strong>无产阶级</strong>开始登上历史舞台，标志着中国<strong>新民主主义革命</strong>的开始</p>]]></content>
      
      
      <categories>
          
          <category> 死记硬背 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中国历史 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于中共党史</title>
      <link href="/2023/05/07/%E5%85%B3%E4%BA%8E%E4%B8%AD%E5%85%B1%E5%85%9A%E5%8F%B2/"/>
      <url>/2023/05/07/%E5%85%B3%E4%BA%8E%E4%B8%AD%E5%85%B1%E5%85%9A%E5%8F%B2/</url>
      
        <content type="html"><![CDATA[<p>毛泽东思想 -&gt; 邓小平理论 -&gt; 三个代表重要思想 -&gt; 科学发展观 -&gt; 习近平新时代中国特色社会主义思想</p><p>毛泽东<strong>三大法宝</strong>：统一战线、武装斗争、党的建设</p><p>毛泽东思想<strong>活的灵魂</strong>：群众路线、实事求是、独立自主</p><p>毛泽东思想具有：科学性（科学的世界观和方法论）、独创性（以马列为指导又不拘泥于马列）、完整性（深入分析了中国现状，会发了各种问题，覆盖了各个方面）</p><p>毛泽东思想<strong>根本点，出发点，精髓</strong>：实事求是；<strong>落脚点</strong>是独立自主；<strong>根本路线和领导方法</strong>是群众路线；</p><p>三大作风：理论联系实际、密切联系群众、批评与自我批评</p><p>邓小平理论<strong>活的灵魂</strong>：解放思想、实事求是</p><p>习近平新时代中国特色社会主义<strong>活的灵魂</strong>：解放思想、实事求是、与时俱进</p><p>马克思<strong>活的灵魂</strong>是：具体问题，具体分析；</p><p>马克思主义<strong>根本观点</strong>是：实事求是；</p><p>马克思主义<strong>精髓</strong>是：解放思想，实事求是，与时俱进；</p><p>三个代表重要思想：<strong>关键</strong>在坚持与时俱进；<strong>本质</strong>在坚持执政为民；<strong>核心</strong>在保持党的先进性；<strong>精髓</strong>是解放思想，实事求是，与时俱进； </p><p>八七会议（1927.8.7）：清算陈独秀<strong>右倾主义</strong>错误，确立<strong>土地革命</strong>和<strong>武装反抗国民党总方针</strong>；<strong>枪杆子里出政权</strong>；</p><p>南昌起义（1927.8.1）：打响武装反抗国民党反动统治第一枪，中国共产党独立领导革命战争，创建人民军队的开始；党对军队绝对领导的<strong>开端</strong>。</p><p>秋收起义（1927.9.9）：工农革命军的旗号，第一个农村革命根据地—井冈山</p><p>三湾改编（1927.9）：党对军队绝对领导的<strong>奠基</strong>，毛泽东建设人民军队思想的开始</p><p>古田会议（1929.12）：党对军队绝对领导的<strong>定型</strong>，思想建党、政治建军</p><p>遵义会议（1935.1）：生死攸关转折点，确立毛泽东为代表的马克思正确路线，集中解决<strong>军事</strong>问题和<strong>组织</strong>问题</p><p>瓦窑堡会议（1935.12）：抗日民族统一战线</p><p>洛川会议（1937.8）：开辟敌后战场，建立敌后抗日根据地</p><p>中共一大（1921.7.23）：上海召开；确定党的名称（<strong>中国共产党</strong>），确定党的纲领（《中国共产党纲领》），奋斗目标是推翻资产阶级政权，建立<strong>无产阶级</strong>专政，废除私有制，直至消灭阶级差别</p><p>中共二大（1922.7）：通过《<strong>中国共产党章程</strong>》，制定最高纲领和最低纲领；</p><p>中共三大（1923）：四个现代化，共产党以个人名义加入国民党</p><p>六届六中全会（1938.9）：毛泽东《论新阶段》，毛泽东明确提出马克思主义中国化</p><p>中共七大（1945.4）：毛泽东《论联合政府》，<strong>确立了毛泽东思想</strong>并写入党章；三大作风</p><p>十一届三中全会（1978.12）：彻底否定两个凡是的方针；<strong>改革开放</strong>；进入改革开放和社会主义现代化建设新时期</p><p>十一届六中全会（1981.6）：《关于建国以后党的若干历史问题的决议》，科学评价毛泽东和毛泽东思想</p><p>十二大（1982）：中国特色社会主义</p><p>十三大（1987）：<strong>社会主义初级阶段</strong>；一个中心两个基本点</p><p>十四大（1992）：社会主义市场经济体制</p><p>十五大（1997）：确立邓小平理论指导的地位；<strong>邓小平理论</strong>写入党章（什么是社会主义，怎样建设社会主义）；依法治国</p><p>十六大（2002）：三个代表重要思想（江泽民，建设怎样的党，怎么建设党）</p><p>十七大（2007）：科学发展观写入党章（胡锦涛）</p><p>十九大（2017）：习近平新时代中国特色社会主义思想，科学发展观<strong>作为党的指导思想</strong>写入党章，<strong>乡村振兴</strong></p><hr><p><strong>毛泽东思想萌芽阶段</strong>：新民主主义理论的提出</p><p><strong>毛泽东思想初步形成</strong>：《中国红色政权为什么能够存在》《井冈山斗争》《反对本本主义》（理论与实际相结合）《星星之火，可以燎原》（中心从城市转移到农村）；农村包围城市，武装夺取政权道路的提出，标志着毛泽东思想<strong>初步</strong>形成；</p><p><strong>毛泽东思想走向成熟</strong>：《共产党人发刊词》（<strong>三大法宝</strong>）中国革命和中国共产党（新民主主义革命）《新民主主义论》《论联合政府》；新民主主义革命理论科学体系的完整形成，标志着毛泽东思想走向<strong>成熟</strong>；</p><p>毛泽东思想继续发展：《在晋绥干部会议上的讲话》（完整表述总路线）《论人民民主专政》（工农阶级领导的以<strong>工农联盟</strong>为基础的人民民主专政）《论十大关系》（<strong>长期共存，互相监督</strong>）《关于处理人民内部矛盾的问题》（政治领域要<strong>团结批评团结</strong>，利益分配要<strong>统筹兼顾适当安排</strong>，科学文化要<strong>百花齐放百家争鸣</strong>，与民主党派要<strong>长期共存互相监督</strong>）</p><p>关于抗日战争的文章：《论持久战》（战略<strong>防御、相持、反攻</strong>阶段）《战争与战略问题》（长期武装斗争，先占乡村，后取城市）</p><p>关于马克思主义中国化的文章：《实践论》《矛盾论》（主观主义尤其是教条主义错误）《论新阶段》（首次提出马克思主义中国化）</p><p>关于整风运动文章：《改造我们的学习》（实事求是；标志整风运动的开始；首先在党的高级干部中中进行）《整顿党的作风》《反对党八股》（反对主观主义、宗派主义、党八股）</p><p>《共产党宣言》第一次以单行本问世实在英国伦敦，而不是德国，虽然马克思是德国人；我国最早的翻译本是陈望道翻译的；</p><p><strong>进步势力</strong>：工人，农民，城市小资；<strong>中间势力</strong>：民族资产阶级，开明绅士，地方实力派；<strong>顽固派</strong>：亲美派的国民党；</p>]]></content>
      
      
      <categories>
          
          <category> 死记硬背 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中共党史 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于法律</title>
      <link href="/2023/05/06/%E5%85%B3%E4%BA%8E%E6%B3%95%E5%BE%8B/"/>
      <url>/2023/05/06/%E5%85%B3%E4%BA%8E%E6%B3%95%E5%BE%8B/</url>
      
        <content type="html"><![CDATA[<p> <strong>国体</strong>：人民民主专政</p><p><strong>政体</strong>：人民代表大会制度</p><p><strong>社会主义制度</strong>是中华人民共和国的根本制度。</p><p><strong>中国共产党领导</strong>事中国特色社会主义最本质的特征</p><p>法律具有：<strong>概括性</strong>（人们从大量实际行为中高度抽象出来的一种行为规范）、<strong>普遍性</strong>（人人遵守）、<strong>规范性</strong>（不针对具体的人或事，是一种模式或者方案，可以反复适用）、<strong>严谨性</strong>（具有独特的逻辑结果，大部分由法律规范组成）</p><p>实体法：规定具体权利义务或法律保护的具体情况，如《刑法》《消费者权益保护法》</p><p>程序法：规定以保证权力和职权得以实现或行使，义务和责任得以履行，如《行政诉讼法》《民事诉讼法》</p><h3 id="全国人民代表大会"><a href="#全国人民代表大会" class="headerlink" title="全国人民代表大会"></a>全国人民代表大会</h3><p>最高的权力机关，立法机关 ；每届任期<strong>5</strong>年</p><p>职权：立法权（修改<strong>宪法</strong>、制定修改其他法律），选举决定任命中央国家机构组成人员（选举主席、副主席，军委主席，根据<strong>国家主席提名</strong>决定国务院副总理，选举最高人民法院院长，检察院检察长），决定国家重大事项（<strong>批准自治区直辖市建立</strong>，决定战争和平，决定特别行政区的设立）</p><p>人大直接选举：一常三高三主席（常务委员会委员长，国家主席，副主席，军委主席，最高人民法院院长，最高人民检察院检察长）</p><p>会议制度：每年举行<strong>1</strong>次，有<strong>全国人民大会常务委员会</strong>召集；宪法修改由<strong>全国人大常委会</strong>或<strong>五分之一</strong>以上全国人民代表大会代表提议，并由全国人民代表大会全体代表<strong>三分之二</strong>以上多数通过；法律和其他议案由全体代表<strong>半数</strong>通过</p><h3 id="全国人大常委"><a href="#全国人大常委" class="headerlink" title="全国人大常委"></a>全国人大常委</h3><p>全国人大的常设机关，闭会期间行使最高国家权力</p><p>任期<strong>5</strong>年，委员长、副委员长连续任职不超<strong>2</strong>届</p><p>职权：1. 解释宪法，监督实施；解释法律；制定和修改应该由全国人大制定的法律以外的法律 2. 监督国务院、中央军委、国家监察委员会、最高人民法院，检察院工作 3. 决定<strong>全国或个别地区</strong>进入<strong>紧急状态</strong></p><h3 id="中华人民共和国主席"><a href="#中华人民共和国主席" class="headerlink" title="中华人民共和国主席"></a>中华人民共和国主席</h3><p>任期5年</p><p>职权：1. 根据全国人大，全国人大常委会决定，公布法律；2. 任免国务院组成人员，授予国家荣誉称号，宣布进入紧急状态，宣布战争状态，发布动员令 </p><h3 id="国务院"><a href="#国务院" class="headerlink" title="国务院"></a>国务院</h3><p>即中央人民政府，最高国家行政机关  任期<strong>5</strong>年，连续不得超<strong>2</strong>届</p><p>职权：立法权（制定行政法规），决定<strong>省、自治区、直辖市</strong>进入紧急状态，批准省自治区直辖市州县的区域划分</p><h3 id="民事主体"><a href="#民事主体" class="headerlink" title="民事主体"></a>民事主体</h3><p>完全民事行为能力：<strong>18</strong>周岁以上（或<strong>16</strong>周岁以上不满18但有自己的收入），可以独立进行民事活动</p><p>限制民事行为能力：<strong>8</strong>周岁以上不满<strong>18</strong>周岁（或<strong>不能完全辨认</strong>自己行为的精神病人），法定代理人代理或争得代理人同意或追认</p><p>无民事行为能力：不满8周岁（不能辨认自己行为的精神病人），由法定代理人代理民事活动</p><h3 id="物权"><a href="#物权" class="headerlink" title="物权"></a>物权</h3><p>抵押权：以下产品不得抵押：1. 土地<strong>所有权</strong> 2. 耕地、宅基地、自留地、自留山等集体所有的<strong>土地使用权</strong>（其他使用权可以） 3. 学校、幼儿园等公益为目的的事业单位教育医疗<strong>设施</strong> 4. 所有权、使用权不明或有争议的财产 5. 法律规定的其他财产。 </p><h3 id="婚姻"><a href="#婚姻" class="headerlink" title="婚姻"></a>婚姻</h3><p>男：22  女：  20</p><p>无效婚姻：1. 未到法定婚龄 2. 重婚 3. 双方有禁止结婚的亲属关系 4. 婚前有禁止结婚的疾病，婚后未愈</p><p>可撤销婚姻：1. 受胁迫的一方可以向<strong>婚姻登记机关</strong>或<strong>人民法院</strong>申请撤销 2. 结婚登记之日起<strong>一年</strong>内提出  3. 被非法限制人身自由的，恢复自由后<strong>一年</strong>内提出</p><p>离婚的特殊情况：1. 一方宣告失踪，乙方提出离婚诉讼的准予离婚 2. 现役军人配偶要求的，需要军人同意，但军人一方有重大过错除外 3. <strong>怀孕期间、分娩后一年内、终止妊娠后六个月</strong>内，不得离婚。女方提出或者人民法院认为的除外。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>第一顺位：配偶、子女、父母（丧偶儿媳对公婆、丧偶女婿对岳父岳母，尽了赡养义务的，为第一顺位）</p><p>第二顺位：兄弟姐妹、祖父母、外祖父母</p><h3 id="犯罪主体"><a href="#犯罪主体" class="headerlink" title="犯罪主体"></a>犯罪主体</h3><p>八种犯罪：故意杀人、故意伤害致人重伤或死亡、强奸、抢劫、贩卖毒品、放火、爆炸、投毒罪</p><p>犯罪表示：通过一定方式，将犯罪意图表现与外部的行为</p><p>犯罪预备：准备、未实行、外因终止、为了犯罪准备工具，制造条件</p><p>犯罪未遂：已经实行，外因终止而非主动</p><p>犯罪中止：自动放弃、自动有效防止犯罪结果发生。对于中止犯，没有造成损害的，应当免除处罚，造成的应当减轻处罚</p><p>正当防卫：为了国家、公共利益、本人或他人，<strong>正在进行</strong>不法侵害，防卫对象只能是<strong>不法侵害人</strong></p><p>防卫过当：<strong>明显超出</strong>必要限度，<strong>应当</strong>减轻或免除处罚</p><p>紧急避险：<strong>正在发生</strong>危险、<strong>不得已</strong>采取<strong>损害</strong>较小方合法权益，保护较大权益</p><p>法律监督：国家机关监督（权力机关，行政机关，检察机关，司法机关）；社会法律体系监督（也叫社会监督；<strong>中国共产党</strong>、<strong>人民政协</strong>、<strong>民主党派</strong>、人民团体、社会组织、公民个人、媒体舆论）</p><h3 id="法理学"><a href="#法理学" class="headerlink" title="法理学"></a>法理学</h3><p>法的作用：<strong>指引</strong>作用（是社会成员知道什么能做什么不能做）、<strong>评价</strong>作用（判断他人行为是否合法）、<strong>教育</strong>作用（法的实施对他人造成的影响）、<strong>预测</strong>作用（预测对象互相间的行为）、<strong>强制</strong>作用（国家强制力制裁违法行为）</p><h3 id="刑法"><a href="#刑法" class="headerlink" title="刑法"></a>刑法</h3><p>全无刑事责任年龄：小于<strong>14</strong>岁</p><p>相对刑事责任年龄：已满<strong>14</strong>不满<strong>16</strong>，8种犯罪时 ，负刑事责任</p><p>完全刑事责任年龄：已满<strong>16</strong>周岁</p><p>减轻刑事责任年龄：已满14不满18，<strong>应当</strong>从轻或者减轻处罚；已满75周岁故意犯罪，<strong>可以</strong>从轻或减轻处罚；过失犯罪的，<strong>应当</strong>从轻或减轻处罚</p><p>主刑：管制（3月以上2年以下，最高不超3年，社区矫正）、拘役（1月以上6月以下，不超1年）、有期徒刑（6月以上15年以下，不满35年的不超20年；35以上的不超25年）、无期徒刑、死刑（不满18，怀孕妇女不适用，也不用死缓；75以上不适用，特别残忍致人死亡除外）</p><p>附加刑：罚金、剥夺政治权利、没收财产、驱逐出境</p><p>假释：对<strong>累犯</strong>以及故意杀人、强奸、抢劫、绑架、放火、爆炸、投放危险物质或者有组织的暴力性犯罪被判<strong>10</strong>年以上有期徒刑、无期徒刑的犯罪分子不可假释。</p><p>受贿罪：利用职务之便，索取他人财物或非法接受他人财物，为他人谋取利益；行为方式有两种，一为索贿，二为收受贿赂，<strong>没有索贿罪</strong>这个罪名</p><p>徇私枉法罪：对明知是无罪的人使他受追诉，对明知有罪的人故意包庇，处五年以下有期或拘役，情节严重的五年以上十年以下有期，特别严重的十年以上有期，同时受贿和徇私枉法应该择一重罪处罚</p><p>盗窃罪：以非法占有为目的，<strong>秘密的</strong>窃取数额较大的公私财物行为</p><p>抢劫罪：以<strong>暴力、胁迫</strong>或其他方法抢劫公私财物</p><p>抢夺罪：以非法占有为目的，<strong>趁人不备</strong>，公开夺取数额较大的公私财物行为</p><p>国家考试包括（<strong>组织作弊</strong>的<strong>三年以下</strong>有期或拘役和罚金，严重的<strong>三年以上七年以下</strong>有期和罚金）：普通高等学校招生考试、研究生招生考试、高等教育自学考试、成人高等学校招生考试、公务员考试、专业技术资格考试（<strong>高校教师录用考试不算国家考试</strong>）</p><p>刑事立案条件：1. 有犯罪事实  2. 需要追究刑事责任</p><p>危险驾驶罪（拘役并处罚金）：1. 追逐经济情节恶劣的；2. 醉酒驾驶汽车的；3. 从事校车业务或者旅客运输严重超载的；4. 违反化学实验品的</p><h3 id="宪法"><a href="#宪法" class="headerlink" title="宪法"></a>宪法</h3><p>宪法经过了5此修改，我国现行宪法为1982年宪法，经历了1988年（私营，土地）、1993年（市场经济）、1999年（依法治国）、2004年（尊重保障人权）、2018年（改社会主义法制为法治）</p><p>地方各级人民代表大会代表任期内调离本行政区的，代表资格自行终止，缺额另行补选</p><p>国家监察委员会对<strong>全国人大</strong>和<strong>全国人大常委会</strong>负责；地方各级监察委员会对<strong>产生他的权力机关</strong>和<strong>上一级监察委员</strong>会负责，对<strong>本级人民代表大会</strong>和<strong>常务委员会</strong>负责</p><h3 id="劳动法"><a href="#劳动法" class="headerlink" title="劳动法"></a>劳动法</h3><p>试用期：1. 小于3个月无试用期 2. 满三个月小于一年的试用期1个月 3. 满1年小于3年的试用期2个月 4. 满三年的试用期不超过6个月。试用期包含在劳动合同期内</p><p>用人单位提前<strong>30</strong>日以书面形式告知劳动者本人或者额外支付劳动者<strong>1</strong>月工资后，可以解除劳动合同。</p><p><strong>试用期不合格</strong>或以<strong>欺骗手段</strong>取得劳动合同的可以直接解除劳动合同，不需要经济补偿；试用期劳动者主动解除的提前<strong>3</strong>天告知用人单位</p><p>以下情况不可解除劳动合同：1. 因公负伤丧失劳动能力 2. 患病或非因工负伤，在规定的医疗期内 3. 女性在孕期、产期、哺乳期 4. 本单位连续工作满十五年，且距退休不足5年 5. 法律规定的其他情形</p><p>用人单位<strong>自用工之日</strong>起即建立劳动关系，不得扣押劳动者居民身份证和其他证件，不得要求提供担保财务；未涉及<strong>保密和竞业</strong>条例的不得要求违约金；不得自行约定劳动终止情况（<strong>劳动终止是法定条件</strong>）</p><p>劳动合同终止：1. 劳动合同期满 2. <strong>劳动者开始依法享受基本养老保险待遇</strong> 3. 劳动者死亡或宣告死亡失踪 4. 用人单位破产 5. 用人单位吊销执照、责令关闭、解散的 6.其他</p><p>非全日制用工的可以订立<strong>口头协议</strong>，不需要书面劳动合同</p><p>用人单位自用工之日起超过一个月不满一年未与劳动者订立劳动合同的，应每月支付双倍工资（<strong>最多一年</strong>）</p><h3 id="经济法"><a href="#经济法" class="headerlink" title="经济法"></a>经济法</h3><p>免征个人所得税：1. 国家奖金 2. 国债，金融债券利息 3. 补贴津贴 4. 福利费，抚恤金，救济金 5. 保险赔款 6. 军人退役金 7. 退休费，安家费，养老金等 </p><p>应该缴纳个人所得税：1. 工资 2. 劳动报酬所得 3. 稿酬所得 4. 特许权使用费所得 5. 经营所得 6. 利息，股息，红利所得 7. 财产租赁所得 8. 财产转让所得 9.<strong>偶然所得</strong></p><h3 id="行政法"><a href="#行政法" class="headerlink" title="行政法"></a>行政法</h3><p>行政处罚：申诫罚（警告），财产罚（罚款，没收违法所得，没收非法财物），行为罚（停产停业，暂扣或吊销许可证、执照），人身罚（行政拘留）</p><p>治安管理处罚：警告、罚款、拘留、吊销公安机关发放的许可证、限制出境或驱逐出境</p><p>行政强制执行：<strong>加</strong>处罚款或滞纳金、<strong>划</strong>拨存款、<strong>拍</strong>卖或依法处理查封场所、排<strong>除</strong>妨碍恢复原状、<strong>代</strong>履行（假话待排除）</p><p>行政强制措施：<strong>限</strong>制人身自由、查<strong>封</strong>场所、<strong>扣</strong>押财物、<strong>冻</strong>结存款（先封洞口）</p><p>当场收缴的罚款：<strong>100</strong>（行政法）、<strong>50</strong>（治安管理法）、200（简易程序，只罚不收）</p><p>行政处罚中的违法行为在<strong>2</strong>年内没有被发现的，不给予行政处罚，涉及公民生命安全且有危害后果的，延长至<strong>5</strong>年</p><p>吊销（违法行为后的行政处罚）、撤回（因法律等修改或废止而发生重大变化时，应给予补偿）、撤销（以不当手段去的的许可证）、注销（到期未续，公民死亡或失去行动能力、法人终止、许可证被依法吊销、不可抗力造成的、其他）</p><p>行政机关作出处罚时可以要求听证的：1. <strong>较大数额</strong>罚款（对于公民200元以上，对于法人3000元以上） 2. 没收<strong>较大数额</strong>违法所得、<strong>较大价值</strong>非法财物 3. 吊销许可证 4. 停产停业 5.其他；当事人<strong>不承担</strong>行政听证费用</p><p>行政诉讼的证据：1. 书证 2. 物证 3. 视听资料 4. 电子数据 5. 证人证言 6. 当事人的陈述 7.鉴定意见 8. 笔录 </p><p>行政诉讼举证：被告对做出的行政行为负有举证责任，不可以向原告、第三人和证人收集证据（<strong>被告一般是政府，自己出示证据证明自己没错，不可以向原告索要证据为了防止销毁证据</strong>）；不提供或逾期提供证据视为没有证据</p><p>民事诉讼举证：<strong>谁主张谁举证</strong></p><p>不受理行政诉讼的情况：1. 调解行为以及法律规定的仲裁行为 2. 国家机关依照刑事诉讼法明确授予实施的行为 3. 行政指导行为 </p><p>行政复议受理情况：1. 对<strong>行政处罚决定</strong>不服的（警告、罚款、没收违法所得、停产停业、暂扣吊销）2. 对<strong>行政强制措施</strong>决定不服的（限制人身自由、查封、冻结） 3. 对<strong>许可证</strong>的终止、撤销不服的 4. 对<strong>确认自然资源所有权或使用权</strong>不服的（土地、矿藏、森林等）   （抽象行政行为不复议，比如对法条不服）</p><p>行政诉讼和行政复议的异同：都是不服行政主体的行政行为而发起的，行政复议是向<strong>上级</strong>提出，审核处罚的<strong>合法性和合理性</strong>，行政诉讼直接上<strong>法院</strong>，只审查处罚的<strong>合法性</strong>；诉讼之后不在复议</p><p>先复议在诉讼：<strong>15</strong>日；直接复议<strong>60</strong>日；直接诉讼：<strong>6</strong>个月</p><p>行政公开原则：不涉及国家机密、商业机密、个人隐私的，行政机关实施行政管理应当公开，以实现公民的知情权</p><p>权责统一原则：行政权力和法律责任的统一</p><p>行政比例原则：尽量损害最小</p><p>信赖保护原则：非因法定事由并经法定程序，行政机关不得撤销、变更已经生效的行政决定，有需要时要依照法律程序并给予补偿</p><h3 id="公务员法"><a href="#公务员法" class="headerlink" title="公务员法"></a>公务员法</h3><p>公务员任用坚持：德才兼备、以德为先、任人唯贤、突出政治标准、注重工作实绩</p><p>不得录用公务员：因犯罪受过刑事处罚的、开除党籍的、开除公职的、失信对象、法律规定不得录用的</p><p>公务员考核：1. 全面考核德、能、勤、绩、廉，重点考核<strong>政治素质</strong>和**工作实绩 **</p><p>公务员奖励：已经<strong>精神奖励</strong>为主，分为嘉奖、记三等功、记二等功、记一等功、授予称号</p><p>公务员处分：1. 上级命令错误的可以提出意见，坚持执行的，后果由<strong>上级承担</strong> 2. 处分分为警告（<strong>可加薪不可升职</strong>）、记过、记大过、降级撤职开除（<strong>解除聘用合同</strong>） 3. 处分期间不得晋升职位、职级和级别，受记过、记大过、降级撤职开除的不得晋升工资档次 4. 警告<strong>6</strong>个月，后面依次+6</p><p>对党员的纪律处分：警告（一年）、严重警告（一年半）、撤销党内职务（两年）、留党察看（最多不超过两年）、开除党籍（五年）；</p><p>公务员回避：夫妻关系、直系血亲、三代内旁系血亲、近姻亲关系</p><p>执行公务时回避：涉及<strong>本人</strong>利害关系的、涉及与<strong>本人有亲属关系</strong>人员的利害关系的、可能<strong>影响公正执法公务</strong>的</p><p>公务员待遇：基本工资、津贴、补贴、奖金</p><p>公务员辞退：1. 年度考核连续<strong>2</strong>年不称职 2. 不胜任现职又不接受其他安排的 3. 所在机关调整工作，不适合继续在机关工作的 4. 不履行公务员义务，纪律，教育后无改变的 5. 不工作<strong>连续15</strong>天或者一年累计<strong>30</strong>天的</p><h3 id="民法"><a href="#民法" class="headerlink" title="民法"></a>民法</h3><p>人格权：生命权、健康权、姓名权、名称权、肖像权、名誉权、隐私权、荣誉权</p><p>身份权：配偶权、亲权、亲属权（监护权）、著作权、发明权、专利权、商标权</p><p>承诺生效时合同成立，法律另行规定或当事人另有约定除外</p><p>民事法律行为有效：1. 行为人具有相应的民事行为能力； 2. 意思表示真实 3. 不得违反法律来法规，公序良俗 </p><p>无效的民事法律行为：1. 无民事行为能力人实施的民事法律行为 2. 行为人以虚假的意思实施的 3. 行为人恶意串通，损害他人利益的 4. 违背公序良俗的 5. 违背法律的</p><p>效力待定的民事法律行为：1. 欠缺代理权的代理行为 2. 限制民事行为能力人实施的超越能力范围的行为 3. 债务承担，未经债权人同意</p><p>物权转让自交付时发生效力</p><p>民事诉讼中，原告来不了的按撤诉处理，被告来不了的缺席判决；被执行人未按判决履行义务的，要支付迟延履行金，未按判决给钱的加倍支付利息</p><p>消费者和经营者发生争议时，可以通过以下解决：1. 与经营者协商和解 2. 请求消费者协会调解 3. 向有关<strong>行政部门</strong>投诉 4. 向<strong>仲裁机构</strong>仲裁 5. 向<strong>人民法院</strong>提起诉讼</p><p>自然人信息受法律保护，不可<strong>非法</strong>收集个人信息，不可<strong>非法</strong>买卖提供个人信息（可以合法的收集和买卖提供）</p><p>民事诉讼中：1.因不动产纠纷提起诉讼的，由<strong>不动产所在</strong>地人民法院管辖 2. 因港口作业中发生纠纷提起诉讼的，由<strong>港口所在地</strong>人民法院管辖 3. 因继承遗产纠纷提起诉讼的，由<strong>被继承人死亡时住所地</strong>或者<strong>主要遗产所在地</strong>人民法院管辖</p><p>民法调整的财产关系：物权、债权、知识产权、财产继承权</p><p>相互有继承关系的数人在同一事件中死亡，难以确定死亡事件的，推定<strong>没有继承人</strong>的人先死亡，都有其他继承人的，推定<strong>长辈</strong>先死亡，辈分相同的，推定<strong>同时</strong>死亡，相互不发生继承</p><p>下落不明满四年，因意外情况下落不明满两年<strong>宣告死亡</strong>；下落不明满两年<strong>宣告失踪</strong>；</p><p>听证会的召开：民申请（<strong>5</strong>日内申请，行政机关<strong>20</strong>日内组织听证）；官直接（<strong>7</strong>日内告知民）</p>]]></content>
      
      
      <categories>
          
          <category> 死记硬背 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 法律 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于经济</title>
      <link href="/2023/05/06/%E5%85%B3%E4%BA%8E%E7%BB%8F%E6%B5%8E/"/>
      <url>/2023/05/06/%E5%85%B3%E4%BA%8E%E7%BB%8F%E6%B5%8E/</url>
      
        <content type="html"><![CDATA[<h3 id="社会主义市场经济"><a href="#社会主义市场经济" class="headerlink" title="社会主义市场经济"></a>社会主义市场经济</h3><p>公有制经济和非公有制经济都是社会主义市场经济的重要组成部分，都是我国经济社会发展的重要基础</p><p>公有制经济在<strong>社会总资产中</strong>占优势；<strong>国有经济</strong>控制国民经济命脉，对经济发展起<strong>主导</strong>作用</p><p><strong>生产资料公有制</strong>是社会主义的根本经济特征，是社会主义经济制度的基础</p><p>公有制经济：国有经济、集体经济、混合所有制经济中的国有成分和集体成分</p><p>非公有制经济：个体经济、私营经济、外资经济等</p><p>民营经济：个体经济、私营经济、混合所有民营经济、民营科技企业、农民专业合作社等</p><p>经济基础：生产关系的总和；生产资料所有制、生产过程中人与人之间的关系和分配关系</p><p>上层建筑：观念上层建筑（政治法律思想、道德、宗教、文学艺术、哲学等意识形态）政治上层建筑（政治法律制度和设施、军队、警察、法庭、监狱、政府机构和政党、社会集团）<strong>国家政权是核心</strong></p><h3 id="商品"><a href="#商品" class="headerlink" title="商品"></a>商品</h3><p>价值：凝结在商品中的无差别的人类劳动给；商品的<strong>社会属性</strong></p><p>使用价值：物品的有用性，商品的<strong>自然属性</strong>，使用价值是价值的物质承担者</p><p>有价值一定有使用价值，有使用价值不一定有价值</p><h3 id="货币"><a href="#货币" class="headerlink" title="货币"></a>货币</h3><p>从商品中分离出来固定充当一般等价物的商品</p><p>职能：价值尺度（基本职能），流通手段（基本职能），支付手段，贮藏手段，世界货币</p><p>价值规律的市场机制：<strong>价格</strong>机制、<strong>竞争</strong>机制、<strong>供求</strong>机制</p><p>市场经济的基本规律：<strong>价值</strong>规律、<strong>竞争</strong>规律、<strong>供求</strong>规律</p><h3 id="宏观调整"><a href="#宏观调整" class="headerlink" title="宏观调整"></a>宏观调整</h3><p>市场经济固有缺陷：自发性，盲目性，滞后性</p><p>财政政策：国际预算、<strong>税收</strong>、财政收入支出，财政投资、财政补贴、财政信用、<strong>国债</strong>、政府购买支出、<strong>转移支付</strong></p><p>货币政策：<strong>再贴现率</strong>、<strong>利率</strong>、<strong>法定存款准备金</strong>、公开市场操作、公开市场业务</p><p>社会保障制度：核心内容（<strong>保险制度</strong>）、最高纲领（<strong>福利制度</strong>）、最低纲领（<strong>社会救济</strong>）、特殊纲领（<strong>社会优抚</strong>）</p><h3 id="宏观经济"><a href="#宏观经济" class="headerlink" title="宏观经济"></a>宏观经济</h3><p>挤出效应：为了平衡财政预算赤字，发行债券，向私人借贷资金市场筹资，从而让市场利率上升，私人投资支出下降</p><p>棘轮效应：消费习惯易于向上调整，难于向下调整</p><p>收入效应：收入不变情况下，商品价格变化对需求的影响</p><p>溢出效应：一个组织在进行某种活动时，不仅会产生预期结果，还会对产生其他影响</p><p>庞氏骗局特征：低风险高回报、拆东墙补西墙、投资诀窍的不可知性和不可复制性、投资的反周期性（不受投资周期影响）、投资者结构的金字塔特征</p><p>宏观调控政策的目标：<strong>充分就业、经济增长、物价稳定、收支平衡</strong></p><h3 id="经济学简称"><a href="#经济学简称" class="headerlink" title="经济学简称"></a>经济学简称</h3><p>GDP：国内生产总值.</p><p>GNP：国民生产总值</p><p>NDP：国内生产净值 （NDP&#x3D;GDP-折旧）</p><p>NNP：国民生产净值 （NNP&#x3D;GNP-折旧）</p><h3 id="唯物论"><a href="#唯物论" class="headerlink" title="唯物论"></a>唯物论</h3><p>物质决定意识，意识反作用于物质</p><p>主观唯心：把人的主观精神（目的、意识、感觉、经验、心灵等）夸大为唯一的实在，如：我就是宇宙的中心</p><p>客观唯心：把客观精神（上帝、理念、绝对精神）看作世界的本原，如道生一，一生二；生死有命富贵在天</p><p>古代朴素唯物：物质是客观实在，物质是金木水火土</p><p>近代形而上学唯物（机械唯物主义）：世界是绝对静止的，孤立的，只有量变没有质变</p><p>辩证法唯物：世界是运动的，相互联系的，对立统一的，如：<strong>马克思主义哲学</strong></p><p>历史唯物：用唯物主义历史观解释历史的发展，历史发展有自己的客观规律，如：劳动创造了人本身、<strong>马克思主义哲学</strong></p><h3 id="辩证法"><a href="#辩证法" class="headerlink" title="辩证法"></a>辩证法</h3><p>两大特征：事物是普遍联系的和永恒发展的</p><p>三大规律：对立统一规律、质量互变规律、否定之否定规律</p><p>联系特点：客观性，普遍性，多样性</p><p><strong>对立统一</strong>规律是辩证法的根本规律，揭示了事物发展的源泉和动力</p><p>对立统一是<strong>核心地位</strong>，揭示了事物发展的<strong>源头和动力</strong>；否定之否定揭示了事物发展的<strong>方向和道路</strong>；质变和量变揭示了事物发展的<strong>形式和状态</strong>；</p><h3 id="认识论"><a href="#认识论" class="headerlink" title="认识论"></a>认识论</h3><p>实践是认识的<strong>唯一来源</strong>、实践是认识发展的<strong>动力</strong>、实践是检验认识正确与否的<strong>唯一标准</strong>、实践是认识的<strong>最终目的和归宿</strong></p><p>真理与谬误有着严格的界限，在一定范围内，真理就是真理，谬误就是谬误</p><p>真理是<strong>绝对性</strong>和<strong>相对性</strong>的统一，绝对性是指真理的无条件行，无限性，相对性指真理的有条件性，有限性</p><p>世界观包含人生观，是人生观的理论基础，世界观决定人生观，有什么样的世界观就有什么样的人生观，人生观是世界观的重要组成部分，反过来影响世界观</p><h3 id="历史观"><a href="#历史观" class="headerlink" title="历史观"></a>历史观</h3><p>社会存在<strong>决定</strong>社会意识、社会意识<strong>反作用</strong>于社会存在</p><p>人民群众是历史的<strong>创造者</strong>，是社会的<strong>主体</strong></p><p>人民群众是<strong>物质财富</strong>的创造者、是<strong>精神财富</strong>的创造者、是社会变革的<strong>决定</strong>力量</p>]]></content>
      
      
      <categories>
          
          <category> 死记硬背 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经济 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>党政机关公文处理条例</title>
      <link href="/2023/04/26/%E5%85%9A%E6%94%BF%E6%9C%BA%E5%85%B3%E5%85%AC%E6%96%87%E5%A4%84%E7%90%86%E6%9D%A1%E4%BE%8B/"/>
      <url>/2023/04/26/%E5%85%9A%E6%94%BF%E6%9C%BA%E5%85%B3%E5%85%AC%E6%96%87%E5%A4%84%E7%90%86%E6%9D%A1%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<ol><li>决议。适用于<strong>会议讨论</strong>通过的重大决策事项。</li><li>决定。适用于对重要事项作出<strong>决策和部署</strong>、奖惩有关单位和人员、<strong>变更或者撤销</strong>下级机关不适当的决定事项。</li><li>命令（令）。适用于<strong>公布行政法规和规章</strong>、宣布施行重大强制性措施、批准授予和晋升衔级、嘉奖有关单位和人员。</li><li>公报。适用于公布重要决定或者重大事项。</li><li>公告。适用于向<strong>国内外</strong>宣布重要事项或者法定事项。</li><li>通告。适用于在<strong>一定范围内公布</strong>应当遵守或者周知的事项。</li><li>意见。适用于对<strong>重要问题</strong>提出见解和处理办法。</li><li>通知。适用于发布、传达<strong>要求下级机关执行</strong>和有关单位周知或者执行的事项，<strong>批转、转发</strong>公文。</li><li>通报。适用于<strong>表彰先进、批评错误</strong>、传达重要精神和告知重要情况。</li><li>报告。适用于<strong>向上级机关汇报</strong>工作、反映情况，回复上级机关的询问。</li><li>请示。适用于向<strong>上级机关请求</strong>指示、批准。</li><li>批复。适用于<strong>答复下级机关</strong>请示事项。</li><li>议案。适用于各级人民政府按照法律程序向同级人民代表大会或者人民代表大会常务委员会<strong>提请审议</strong>事项。</li><li>函。适用于<strong>不相隶属机关</strong>之间商洽工作、询问和答复问题、请求批准和答复审批事项。</li><li>纪要。适用于<strong>记载会议</strong>主要情况和议定事项。</li></ol><p>版头：份号，密级和保密期限，紧急程度，发文机关标志，发文字号，<strong>签发人</strong>，版头中的分割线</p><p>主体：标题，主送机关，正文，附件说明，发文机关署名，成文日期，<strong>印章，附注，附件</strong></p><p>版记：版记中的分割线，<strong>抄送机关</strong>，印发机关，印发日期</p><p><img src="/2023/04/26/%E5%85%9A%E6%94%BF%E6%9C%BA%E5%85%B3%E5%85%AC%E6%96%87%E5%A4%84%E7%90%86%E6%9D%A1%E4%BE%8B/%E5%9B%BE.jpg" alt="图"></p><p><img src="/2023/04/26/%E5%85%9A%E6%94%BF%E6%9C%BA%E5%85%B3%E5%85%AC%E6%96%87%E5%A4%84%E7%90%86%E6%9D%A1%E4%BE%8B/%E5%AD%97.jpg" alt="字"></p><p>发文处理程序：拟稿、核稿、会签、签发、校对、编号、缮印、核发</p><p>收文处理程序：签收、登记、初审、承办（中心环节）、传阅、催办、答复</p>]]></content>
      
      
      <categories>
          
          <category> 死记硬背 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 公文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>会议的杂七杂八</title>
      <link href="/2023/04/23/%E4%BC%9A%E8%AE%AE%E7%9A%84%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
      <url>/2023/04/23/%E4%BC%9A%E8%AE%AE%E7%9A%84%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/</url>
      
        <content type="html"><![CDATA[<p>十四五时期经济社会发展要坚持稳中求进工作总基调，以<strong>推动高质量发展</strong>为主题，以<strong>深化供给侧改革</strong>为主线，以<strong>改革创新</strong>为根本动力，以<strong>满足人民日益增长的美好生活需要</strong>为根本目的</p><p>构建新发展格局：最本质的特征是<strong>实现高水平的自立自强</strong>，关键在于<strong>经济循环的畅通无阻</strong></p><p>乡村振兴：<strong>产业兴旺</strong>是重点，<strong>生态宜居</strong>是关键，<strong>乡风文明</strong>是保障，<strong>治理有效</strong>是基础，<strong>生活富裕</strong>是根本</p><p>乡村振兴<strong>总方针</strong>是坚持农业农村和谐发展；<strong>总要求</strong>是产业兴旺、生态宜居、乡风文明、治理有效、生活富裕；<strong>制度保障</strong>是建立健全城乡融合发展体制机制和政策体系；</p><p><strong>中国特色社会主义道路</strong>是实现途径，<strong>中国特色社会主义理论体系</strong>是行动指南，<strong>中国特色社会主义制度</strong>是根本保障，<strong>中国特色社会主义文化</strong>是精神力量，四者统一于中国特色社会主义伟大实践。这是中国特色社会主义的根本标志，必须坚定<strong>道路自信，理论自信，制度自信，文化自信</strong></p><p>总体国家安全观：人民安全为<strong>宗旨</strong>，政治安全为<strong>根本</strong>，经济安全为<strong>基础</strong>，军事、文化安全为<strong>保障</strong>，促进国际安全为<strong>依托</strong></p><p>科学发展观：<strong>发展</strong>是第一要义、核心是<strong>以人为本</strong>、基本要求是全<strong>面协调可持续</strong>、根本方法是<strong>统筹兼顾</strong></p><p>社会主义道德建设要：<strong>重点</strong>：诚实守信；<strong>核心</strong>：为人民服务；<strong>原则</strong>：集体主义；<strong>着力点</strong>：四德；<strong>基本要求</strong>：五爱；<strong>基本任务</strong>：全面提高国民道德素质</p><p>党的思想路线：一切从实际出发（<strong>前提</strong>），理论联系实际（<strong>方法</strong>），实事求是（<strong>核心</strong>），在实践中检验真理和发展真理（<strong>目的和验证条件</strong>）</p><p>四项基本原则：指坚持<strong>社会主义道路</strong>，坚持<strong>人民民主专政</strong>，坚持<strong>中国共产党的领导</strong>，坚持<strong>马克思列宁主义、毛泽东思想</strong></p><p>四项基本原则是<strong>立国之本</strong>，改革开放是<strong>强国之路</strong>，社会主义核心价值体系是<strong>兴国之魂</strong>，以经济建设为中心是<strong>兴国之要</strong></p><p>教育是<strong>民生之基</strong>，就业是<strong>民生之本</strong>，收入分配是<strong>民生之源</strong>，是<strong>发展成果由人民共享最直接的方式</strong></p><p>五位一体：创新是<strong>第一动力</strong>，协调是<strong>内在要求</strong>，绿色是<strong>必要条件</strong>，开放是<strong>必由之路</strong>，共享是<strong>本质要求</strong></p><p>社会主义核心价值观的<strong>灵魂</strong>：马克思主义的指导；<strong>主题</strong>是中国特色社会主义共同理想；<strong>精髓</strong>是民族精神和时代精神；<strong>基础</strong>是社会主义荣辱观；</p><p>供给侧改革：<strong>三去一降一补</strong>五大任务（去产能、去库存、去杠杆、降成本、补短板）</p><p>需求侧改革三架马车：投资，消费，出口</p><p>一切从实际出发是党的思想路线的<strong>前提和基础</strong>，在实践中检验真理和发展真理；理论联系实际是党的思想路线的<strong>根本途径和根本方法</strong>；实事求是是党的思想路线的<strong>核心和实质</strong>；内在的包含解放思想、实事求是、与时俱进、求真务实；</p><p><strong>一个中国的原则</strong>是两岸关系的政治基础；</p>]]></content>
      
      
      <categories>
          
          <category> 死记硬背 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 新时代 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毛泽东著作以及影响</title>
      <link href="/2023/04/23/%E6%AF%9B%E6%B3%BD%E4%B8%9C%E8%91%97%E4%BD%9C%E4%BB%A5%E5%8F%8A%E5%BD%B1%E5%93%8D/"/>
      <url>/2023/04/23/%E6%AF%9B%E6%B3%BD%E4%B8%9C%E8%91%97%E4%BD%9C%E4%BB%A5%E5%8F%8A%E5%BD%B1%E5%93%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="《中国革命战争的战略问题》1936年"><a href="#《中国革命战争的战略问题》1936年" class="headerlink" title="《中国革命战争的战略问题》1936年"></a><strong>《中国革命战争的战略问题》1936年</strong></h2><p>　　分析了中国革命战争的四个特点：</p><p>　　①中国是一个正好子经济发展不平衡的半殖民地的大国，而且经过了1924-1927年的革命；</p><p>　　②敌人的强大；</p><p>　　③人民军队的弱小；</p><p>　　④共产党的领导和土地革命；</p><p>　　①④规定了中国人民军队的可能发展和可能战胜其敌人；</p><p>　　②③规定了中国人民军队的不可能很快发展和不可能很快战胜其敌人，这就决定了战争的持久性。</p><h2 id="《战争和战略问题》1938年"><a href="#《战争和战略问题》1938年" class="headerlink" title="《战争和战略问题》1938年"></a><strong>《战争和战略问题》1938年</strong></h2><p>　　提出“革命的中心任务和最高形式是武装夺取政权，是战争解决问题。”</p><h2 id="《中国革命和中国共产党》-1939年"><a href="#《中国革命和中国共产党》-1939年" class="headerlink" title="《中国革命和中国共产党》 1939年"></a><strong>《中国革命和中国共产党》 1939年</strong></h2><p>　　1.第一次提出新民主主义革命这一科学概念，即“无产阶级领导之下的人民大众的反帝反封建的革命”；</p><p>　　2.强调认清中国国情的重要性“乃是认清一切革命问题的基本的依据”；</p><p>　　3.分析了社会性质，提出革命对象、革命动力；</p><p>　　4.指出中国革命如果没有无产阶级的领导，就必然不能胜利；</p><p>　　5.提出民主主义革命是社会主义革命的必要准备，社会主义革命是民主主义革命的必然趋势。</p><h2 id="《改造我们的学习》-1941年"><a href="#《改造我们的学习》-1941年" class="headerlink" title="《改造我们的学习》 1941年"></a><strong>《改造我们的学习》 1941年</strong></h2><p>　　对“实事求是”作了新解释：“事实就是客观存在着的一切事物，‘是’就是客观事物的内部联系，即规律性，‘求’就是我们去研究”，认为这是对待马克思主义的正确态度。</p><h2 id="《论反对日本帝国主义的策略》-1935年"><a href="#《论反对日本帝国主义的策略》-1935年" class="headerlink" title="《论反对日本帝国主义的策略》 1935年"></a><strong>《论反对日本帝国主义的策略》 1935年</strong></h2><p>　　1.指出“半殖民地的政治和经济的主要特点之一，就是民族资产阶级的软弱性”，这是“他们从娘肚子带出来的老毛病” ；</p><p>　　2.阐明了与民族资产阶级建立统一战线的可能性，分析了买办资产阶级发生分裂和比那化的可能性；</p><p>　　3.民族资产阶级的“两面性”即革命性和动摇性、妥协性是由软弱性决定的。</p><h2 id="《论联合政府》-1945年中共七大"><a href="#《论联合政府》-1945年中共七大" class="headerlink" title="《论联合政府》 1945年中共七大"></a><strong>《论联合政府》 1945年中共七大</strong></h2><p>　　1.指出只有经过民主主义，才能达到社会主义，这是马克思主义的天经地义；</p><p>　　2.提出废除国民党一党专政，建立由各党各派组成“民主联合政府”的主张；</p><p>　　3.对人民战争的思想作了概括：在中国共产党的领导下，充分依靠广大人民群众，有一支以全心全意为人民服务为宗旨的军队作为骨干，有一整套的正确战略战术，善于根据情况的变化，进行游击战和运动战，并以根据地为依托，实行“三结合”的武装力量体制，进行人民战争；</p><p>　　4.概括了我党的三大优良作风：理论联系实际，密切联系群众，批评与自我批评。</p><h2 id="《中国社会各阶级的分析》-1925年"><a href="#《中国社会各阶级的分析》-1925年" class="headerlink" title="《中国社会各阶级的分析》 1925年"></a><strong>《中国社会各阶级的分析》 1925年</strong></h2><p>　　1.分析了中国资产阶级的特殊情况，科学地划分为买办资产阶级和民族资产阶级，指出各自的政治态度；</p><p>　　2.指出国民革命的中心问题是农民问题；</p><p>　　3.揭示了中国革命的对象；</p><p>　　4.提出“谁是我们的敌人？谁是我们的朋友？这个问题是革命的首要问题。”阐明认清对象对革命胜利的极端重要性。</p><h2 id="《新民主主义论》-1940年"><a href="#《新民主主义论》-1940年" class="headerlink" title="《新民主主义论》 1940年"></a><strong>《新民主主义论》 1940年</strong></h2><p>　　1.指出中国革命必须分两步走：民主革命、社会主义革命；</p><p>　　2.新民主主义革命是社会主义革命的必要准备；</p><p>　　3.论述了“新民主主义共和国”的国体、政体，并提出新民主主义的政治归纳纲领；</p><p>　　4.新民主主义的政治纲领是建立无产阶级领导的、以工农联盟为基础的各个革命阶级的联合专政的民主共和国；</p><p>　　5.第一次完整提出新民主主义的经济纲领。</p><h2 id="《中国共产党在民族战争中的地位》1938年"><a href="#《中国共产党在民族战争中的地位》1938年" class="headerlink" title="《中国共产党在民族战争中的地位》1938年"></a><strong>《中国共产党在民族战争中的地位》1938年</strong></h2><p>　　指出：“共产党员应是实事求是的模范”，“只有实事求是，才能完成确定的任务”，“科学的态度是实事求是”。</p><h2 id="《将革命进行到底》-1948年"><a href="#《将革命进行到底》-1948年" class="headerlink" title="《将革命进行到底》 1948年"></a><strong>《将革命进行到底》 1948年</strong></h2><p>　　第一次公开使用人民民主专政概念。中共中央政治局报告中首次提出建立无产阶级领导的以工农联盟为基础的人民民主专政《在中国共产党第七届中央委员会第二次全体会议上的报告》。</p><h2 id="《湖南农民运动考察报告》1927年"><a href="#《湖南农民运动考察报告》1927年" class="headerlink" title="《湖南农民运动考察报告》1927年"></a><strong>《湖南农民运动考察报告》1927年</strong></h2><p>　　1.总结辛亥革命失败原因：“国民革命需要一个大的农村变动。辛亥革命没有这个变动，所以失败了。”；</p><p>　　2.指出国民革命的中心问题是农民问题；</p><p>　　3.揭示了中国革命的对象；</p><p>　　4.分析了民族资产阶级的两面性。</p><h2 id="《关于领导方法的若干问题》-1943年"><a href="#《关于领导方法的若干问题》-1943年" class="headerlink" title="《关于领导方法的若干问题》 1943年"></a><strong>《关于领导方法的若干问题》 1943年</strong></h2><p>　　第一次从哲学高度对党的群众路线作了理论概括，把党的群众路线与马克思主义认识论、辩证法和唯物论有机地统一起来。“从群众中来，到群众中去。”</p><h2 id="《在中国共产党第七届中央委员会第二次全体会议上的报告》-1948年"><a href="#《在中国共产党第七届中央委员会第二次全体会议上的报告》-1948年" class="headerlink" title="《在中国共产党第七届中央委员会第二次全体会议上的报告》 1948年"></a><strong>《在中国共产党第七届中央委员会第二次全体会议上的报告》 1948年</strong></h2><p>　　1.制定了迅速夺取全国胜利的各项政策，确立了革命胜利后建设人民民主专政新国家的蓝图，为新民主主义社会向社会主义社会的转变指明了道路，在政治、思想、理论上做了准备；</p><p>　　2.说明在全国胜利局面下，党的工作中心必须由乡村转到城市，必须把恢复和发展生产作为党的中心任务；</p><p>　　3.分析了当时中国的五种经济成分的发展状况和党必须采取的正确政策；</p><p>　　4.估计了中国人民民主革命胜利后国内外的阶级斗争的新形势，提醒全党警惕“糖衣炮弹”，保持谦虚、谨慎、不骄不躁的作风，保持艰苦奋斗的作风。</p><h2 id="《中国农村的社会主义高潮》-1955年"><a href="#《中国农村的社会主义高潮》-1955年" class="headerlink" title="《中国农村的社会主义高潮》 1955年"></a><strong>《中国农村的社会主义高潮》 1955年</strong></h2><p>　　在按语中指出“政治工作是一切经济工作的生命线。在社会经济制度发生根本变革的时期，尤其是这样。”</p><h2 id="《论人民民主专政》-1949年"><a href="#《论人民民主专政》-1949年" class="headerlink" title="《论人民民主专政》 1949年"></a><strong>《论人民民主专政》 1949年</strong></h2><p>　　1.总结中国民主革命胜利基本经验，“总结我们的经验，集中到一点，就是工人阶级(经过共产党)领导的以工农联盟为基础的人民民主专政”；</p><p>　　2.完整提出了人民民主专政的理论，进一步完善了新民主主义的政治纲领；</p><p>　　3.科学阐明新中国国家政权的性质及各阶级在国家中的地位与相互关系；</p><p>　　4.指出“我们现在的方针是节制资本主义，而不是消灭资本主义”；</p><p>　　5.提出新中国在政治上必须实行一边倒，即倒向社会主义一边。</p><h2 id="《关于纠正党内的错误思想》1929年"><a href="#《关于纠正党内的错误思想》1929年" class="headerlink" title="《关于纠正党内的错误思想》1929年"></a><strong>《关于纠正党内的错误思想》1929年</strong></h2><p>　　指出：要通过思想政治工作“教育党员用马克思列宁主义的方法去作政治形式的分析和阶级势力的估量，从代替主观主义的分析和估量”，“使党员注意社会经济的调查和研究，由此来决定斗争的策略和工作的方法。”</p><h2 id="《论持久战》1938年"><a href="#《论持久战》1938年" class="headerlink" title="《论持久战》1938年"></a><strong>《论持久战》1938年</strong></h2><p>　　1.分析了中日双方矛盾的四个基本特点：敌强我弱、敌小我大、敌退步我进步(关键)、敌寡助我多助；</p><p>　　2.批驳“速胜论”和“亡国论”；</p><p>　　3.预见了抗日战争的三个阶段：防御、相持、反攻；</p><p>　　4.阐明<strong>兵民是胜利之本</strong>的思想，即要依靠人民来争取抗日战争的最后胜利；</p><p>　　5.把抗日游击战争放在战略地位考察，依据国情，即“中国是一个处于进步时代的大而弱的国家”；</p><p>　　6.阐明了战略防御理论，应承认积极防御，反对消极防御。</p><h2 id="《关于正确处理人民内部矛盾的问题》-1957年"><a href="#《关于正确处理人民内部矛盾的问题》-1957年" class="headerlink" title="《关于正确处理人民内部矛盾的问题》 1957年"></a><strong>《关于正确处理人民内部矛盾的问题》 1957年</strong></h2><p>　　1.第一次系统地阐述了社会主义的矛盾问题，提出了正确区分和处理两类不同性质矛盾的学说；</p><p>　　2.分析了社会主要矛盾和党的中心任务是社会主义社会的基本矛盾；</p><p>　　3.论及了民主与专政，民主与集中的关系；</p><p>　　4.辨证地论证了重工业、轻工业和农业的关系；</p><p>　　5.重新阐述“长期共存、互相监督”的方针是我国具体的历史条件的产物；</p><p>　　6.详尽论述了“百花齐放、百家争鸣”的方针(不是首次提出)；</p><p>　　7.阐述了知识分子问题。</p><h2 id="《在晋绥干部会议上的讲话》-1948年"><a href="#《在晋绥干部会议上的讲话》-1948年" class="headerlink" title="《在晋绥干部会议上的讲话》 1948年"></a><strong>《在晋绥干部会议上的讲话》 1948年</strong></h2><p>　　1.提出新民主主义革命的总路线：“无产阶级领导的人民大众的，反对帝国主义，封建主义和官僚资本主义的革命”；</p><p>　　2.提出土地改革的总路线：“依靠贫农雇农，团结中农，有步骤有分别地消灭封建剥削制度，发展工业生产”；</p><p>　　3.第一次把官僚资本主义列为革命对象。</p><h2 id="《关于调查人口和土地状况的通知》1931年"><a href="#《关于调查人口和土地状况的通知》1931年" class="headerlink" title="《关于调查人口和土地状况的通知》1931年"></a><strong>《关于调查人口和土地状况的通知》1931年</strong></h2><p>　　提出“不做正确的调查同样没有发言权”。</p><h2 id="《目前形式和我们的任务》-1947年"><a href="#《目前形式和我们的任务》-1947年" class="headerlink" title="《目前形式和我们的任务》 1947年"></a><strong>《目前形式和我们的任务》 1947年</strong></h2><p>　　1.第一次提出新民主主义的<strong>三大经济纲领</strong>：①没收封建阶级的土地归农民所有②没收蒋介石、宋子文、孔祥熙、陈立夫为首的垄断资本归新民主主义国家所有③保护民主工商业；</p><p>　　2.提出土改的两个原则：</p><p>　　①必须满足贫农雇农的要求；</p><p>　　②必须坚决地团结中农，不要损害中农的利益；</p><p>　　3.人民军队的十大军事原则。</p><h2 id="《关于建国以来党的若干历史问题的决议》邓小平主持1981年"><a href="#《关于建国以来党的若干历史问题的决议》邓小平主持1981年" class="headerlink" title="《关于建国以来党的若干历史问题的决议》邓小平主持1981年"></a><strong>《关于建国以来党的若干历史问题的决议》邓小平主持1981年</strong></h2><p>　　1.指出社会主义经济建设必须从我国的国情出发，量力而行，积极奋斗，有步骤分阶段地实现现代化的目标；</p><p>　　2.对以毛泽东为代表的中国共产党人在领导中国革命和建设过程中形成的具有自己特色的立场、观点和方法进行了比较完整、系统的论述，并把它们提高到“灵魂”、“精髓”的高度，凸现了它们的本质意义；</p><p>　　3.实事求是，就是从实际出发，理论联系实际，就是要把马克思列宁主义普遍原理同中国革命具体实践相结合；</p><p>　　4.实事求是地评价了毛泽东的历史地位及毛泽东思想，并运用历史唯物主义和辩证唯物主义的方法分析毛泽东晚年的错误。</p><h2 id="《共产党人发刊词》-1939年"><a href="#《共产党人发刊词》-1939年" class="headerlink" title="《共产党人发刊词》 1939年"></a><strong>《共产党人发刊词》 1939年</strong></h2><p>　　1.提出党在革命中的三宝(统一战线、武装斗争、党的建设)；</p><p>　　2.第一次提出“马列主义理论和中国革命的实践相结合”；</p><p>　　3.把党的建设称为“伟大的工程”；</p><p>　　4.指出统一战线和武装斗争是中国共产党领导的中国资产阶级民主革命的两个基本特点；是中国革命的两个武器，党组织是掌握这两个武器的英勇战士；</p><p>　　5.分析了革命性质(资产阶级民主革命)、革命的对帝(帝、封)、革命动力(无、农、城、民)、革命的形式(武装斗争)。</p><h2 id="《反对本本主义》-1930年"><a href="#《反对本本主义》-1930年" class="headerlink" title="《反对本本主义》 1930年"></a><strong>《反对本本主义》 1930年</strong></h2><p>　　1.是党内第一篇反对教条主义的文献；</p><p>　　2.是党内第一篇提出思想路线的文章；</p><p>　　3.提出“没有调查，就没有发言权”；</p><p>　　4.认为“中国革命斗争的胜利要靠中国同志了解中国情况”。开始形成独立自主、自力更生的思想；</p><p>　　5.提出一切从实际出发的实事求是的思想路线；</p><p>　　6.基本形成了包含毛泽东思想活的灵魂的实事求是、群众路线、独立自主的基本思想。基本形成了明确的马克思主义的思想路线。</p><h2 id="《论十大关系》-1956年"><a href="#《论十大关系》-1956年" class="headerlink" title="《论十大关系》 1956年"></a><strong>《论十大关系》 1956年</strong></h2><p>　　1.明确了建设社会主义必须根据中国情况走自己道路的根本思想，标志着探索中国自己的社会主义道路的开始；</p><p>　　2.阐述了正确解决我国社会主义建设过程中存在的某些矛盾的基本原则，强调要处理好这些矛盾的各个方面以调动各种积极因素；</p><p>　　3.阐述了重工业、农业的关系；</p><p>　　4.论述了中央和地方的关系；</p><p>　　5.第一次提出了中国共产党和各民主党派“长期共存、互相监督”的方针；</p><p>　　6.将经济建设与国防建设的关系作为一个大问题提出。</p><h2 id="《在延安文艺座谈会上的讲话》-1942年"><a href="#《在延安文艺座谈会上的讲话》-1942年" class="headerlink" title="《在延安文艺座谈会上的讲话》 1942年"></a><strong>《在延安文艺座谈会上的讲话》 1942年</strong></h2><p>　　第一次提出“为什么人的问题，是一个根本的问题，原则的问题”中心问题，即“基本上是一个为群众的问题和一个如何为群众的问题”。</p>]]></content>
      
      
      <categories>
          
          <category> 死记硬背 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 毛泽东 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中国近代史重要会议总结</title>
      <link href="/2023/04/17/%E4%B8%AD%E5%9B%BD%E8%BF%91%E4%BB%A3%E5%8F%B2%E9%87%8D%E8%A6%81%E4%BC%9A%E8%AE%AE%E6%80%BB%E7%BB%93/"/>
      <url>/2023/04/17/%E4%B8%AD%E5%9B%BD%E8%BF%91%E4%BB%A3%E5%8F%B2%E9%87%8D%E8%A6%81%E4%BC%9A%E8%AE%AE%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="国民大革命时期"><a href="#国民大革命时期" class="headerlink" title="国民大革命时期"></a>国民大革命时期</h2><h3 id="中共一大（1921-7-23-上海）"><a href="#中共一大（1921-7-23-上海）" class="headerlink" title="中共一大（1921.7.23 上海）"></a>中共一大（1921.7.23 上海）</h3><ol><li>确立党的名称：中国共产党</li><li>确立党的纲领（中国共产党纲领）：以无产阶级革命军队推翻资产阶级，采用<strong>无产阶级</strong>专政从而消灭阶级，废除资本私有制，直至消灭阶级差别，联合第三国际</li></ol><p><strong>影响</strong></p><p>标志中国共产党的成立</p><h3 id="中共二大（1922-7）"><a href="#中共二大（1922-7）" class="headerlink" title="中共二大（1922.7）"></a>中共二大（1922.7）</h3><ol><li>明确敌人：资本帝国主义和军阀官僚的封建势力</li><li>制定<strong>反帝反封</strong>的革命纲领：<ul><li>最高纲领：实现社会主义、共产主义；</li><li>最低纲领：a.打倒军阀 b.推翻帝国主义的压迫 c.统一中国为真正民主共和国</li></ul></li><li>大会通过了《中国共产党党章》，这是党成立后的第一个党章，对党员条件、党的各级组织和党的纪律作了具体的规定。</li></ol><p><strong>影响</strong></p><ol><li>明确了中国革命必须分为民主革命和社会主义革命<strong>两步走</strong>；</li><li>在中国【第一次】提出了<strong>反帝反封建</strong>的革命纲领；</li></ol><h3 id="中共三大（1923-6）"><a href="#中共三大（1923-6）" class="headerlink" title="中共三大（1923.6）"></a>中共三大（1923.6）</h3><p>【国共合作】以及共产党员以个人名义加入国民党的决议案；</p><p>正确地确定了革命统一战线的方针政策</p><p>四个现代化</p><h3 id="国民党一大（1924-1）"><a href="#国民党一大（1924-1）" class="headerlink" title="国民党一大（1924.1）"></a>国民党一大（1924.1）</h3><p>重新解释三民主义，成为国共合作的政治基础：</p><ol><li>在民族主义中突出了【反帝】内容；</li><li>在民权主义中强调了民主权利应“为一般平民所共有”；</li><li>把民生主义概括为“平均地权”和“节制资本”，后来又提出耕者有其田的主张；</li></ol><p><strong>影响</strong></p><p>标志着【第一次国共合作】的正式形成</p><h3 id="中共四大（1925-1）"><a href="#中共四大（1925-1）" class="headerlink" title="中共四大（1925.1）"></a>中共四大（1925.1）</h3><p>无产阶级在民主革命中的领导权问题；</p><p>提出了无产阶级与农民建立巩固的【工农联盟】的重要思想；</p><h2 id="土地革命时期"><a href="#土地革命时期" class="headerlink" title="土地革命时期"></a>土地革命时期</h2><h3 id="八七会议（1927-8-7）"><a href="#八七会议（1927-8-7）" class="headerlink" title="八七会议（1927.8.7）"></a>八七会议（1927.8.7）</h3><ol><li>彻底清算陈独秀的右倾机会主义错误，确立了【土地革命和武装反抗国民党的总方针】</li><li>毛泽东提出【“<strong>枪杆子里出政权</strong>”】的思想（并提出要改编军队）</li><li>选出以瞿秋白为首的中央临时政治局</li><li>把发动农民举行秋收起义最为当前党的主要任务</li></ol><p><strong>影响</strong></p><p>大革命失败到土地革命兴起的历史性转折</p><h3 id="南昌起义（1927-8-1）"><a href="#南昌起义（1927-8-1）" class="headerlink" title="南昌起义（1927.8.1）"></a>南昌起义（1927.8.1）</h3><p>武装反抗国民党反动统治第一枪（国民革命军）</p><p><strong>影响</strong></p><p>标志着中国共产党独立领导革命战争、创建人民军队的开始。</p><p>【党对军队绝对领导】 （开端）</p><h3 id="秋收起义（1927-9-9）"><a href="#秋收起义（1927-9-9）" class="headerlink" title="秋收起义（1927.9.9）"></a>秋收起义（1927.9.9）</h3><p>工农革命军→ 井冈山革命军（10.7）</p><p>工农革命军的旗号，第一个农村革命根据地—井冈山。</p><h3 id="广州起义（1927-12-11）"><a href="#广州起义（1927-12-11）" class="headerlink" title="广州起义（1927.12.11）"></a>广州起义（1927.12.11）</h3><p>工农红军</p><h3 id="三湾改编（1927-9）"><a href="#三湾改编（1927-9）" class="headerlink" title="三湾改编（1927.9）"></a>三湾改编（1927.9）</h3><p>民主主义</p><ol><li>党指挥枪；</li><li>支部建在连上；</li><li>官兵平等；</li></ol><p><strong>影响</strong></p><p>【党对军队绝对领导】 （奠基）毛泽东建设人民军队思想的开始</p><h3 id="古田会议（1929-12）"><a href="#古田会议（1929-12）" class="headerlink" title="古田会议（1929.12）"></a>古田会议（1929.12）</h3><p>中国红军完全成为真正的人民军队。</p><p>思想建党，政治建军</p><p>官兵一致，军民一致，瓦解敌军的政治工作三大原则</p><p><strong>影响</strong></p><p>【党对军队绝对领导】 （定型）人民军队建设基本原则“党指挥枪”</p><p>中华苏维埃第一次全国工农兵代表大会</p><h3 id="中华苏维埃第一次全国工农兵代表大会（1931-11-江西瑞金）"><a href="#中华苏维埃第一次全国工农兵代表大会（1931-11-江西瑞金）" class="headerlink" title="中华苏维埃第一次全国工农兵代表大会（1931.11 江西瑞金）"></a>中华苏维埃第一次全国工农兵代表大会（1931.11 江西瑞金）</h3><ol><li>通过《中华苏维埃共和国宪法大纲》</li><li>选举产生中国苏维埃共和国中央执行委员会，成立了中华苏维埃共和国临时中央政府，毛泽东任主席</li></ol><p><strong>影响</strong></p><p>成立苏维埃政府</p><h3 id="遵义会议（1935-1）"><a href="#遵义会议（1935-1）" class="headerlink" title="遵义会议（1935.1）"></a>遵义会议（1935.1）</h3><p>集中解决了军事问题和组织问题：军事问题：肯定毛泽东的正确意见，批评博古、李德的错误</p><p><strong>影响</strong></p><p>【生死攸关的转折点】中国共产党幼稚→成熟确立以毛泽东为代表的马克思主义的正确路线；</p><h3 id="抗日战争时期"><a href="#抗日战争时期" class="headerlink" title="抗日战争时期"></a>抗日战争时期</h3><h3 id="瓦窑堡会议（1935-12）"><a href="#瓦窑堡会议（1935-12）" class="headerlink" title="瓦窑堡会议（1935.12）"></a>瓦窑堡会议（1935.12）</h3><p>通过《关于目前形势与党的任务决议》</p><p><strong>影响</strong></p><p>【抗日民族统一战线】</p><h3 id="国民党五届三中（1937-2）"><a href="#国民党五届三中（1937-2）" class="headerlink" title="国民党五届三中（1937.2）"></a>国民党五届三中（1937.2）</h3><p>同意国共两党进行谈判，并在会议文件上第一次写上了“抗日”字样</p><p><strong>影响</strong></p><p>（背景：中共提出“五项要求”、“四项保证”）</p><h3 id="国民党五届五中（1939-1）"><a href="#国民党五届五中（1939-1）" class="headerlink" title="国民党五届五中（1939.1）"></a>国民党五届五中（1939.1）</h3><p>成立防共委员会，确定了“防共、限共、溶共、反共”的方针</p><p><strong>影响</strong></p><p>国民党开始采取“消极抗战、积极反共”政策。</p><h3 id="洛川会议（1937-8-陕北洛川）"><a href="#洛川会议（1937-8-陕北洛川）" class="headerlink" title="洛川会议（1937.8 陕北洛川）"></a>洛川会议（1937.8 陕北洛川）</h3><p>《抗日救国十大纲领》《关于目前形势于党的任务的决定》党的工作重心：战区 &amp; 敌后无产阶级的领导权：游击战争，敌后抗日根据地，抗日群众运动；</p><p><strong>影响</strong></p><p>【全面抗战路线】国内战争→民族战争、正规战→游击战</p><h3 id="六届六中全会（1938-9）"><a href="#六届六中全会（1938-9）" class="headerlink" title="六届六中全会（1938.9）"></a>六届六中全会（1938.9）</h3><p>毛泽东《论新阶段》</p><p>强调学习的重要性</p><p><strong>影响</strong></p><p>毛泽东明确提出【马克思主义中国化】</p><h3 id="中共七大（1945-4-延安杨家岭中央大礼堂）"><a href="#中共七大（1945-4-延安杨家岭中央大礼堂）" class="headerlink" title="中共七大（1945.4 延安杨家岭中央大礼堂）"></a>中共七大（1945.4 延安杨家岭中央大礼堂）</h3><ol><li>毛泽东作《论联合政府》的政治报告；</li><li>刘少奇作《关于修改党的章程的报告》报告，对毛泽东思想的科学内涵做了第一次概括；</li><li>朱德作《论解放区战场报告》，周恩来作《论统一战线》讲话；</li></ol><p><strong>影响</strong></p><p>确立了毛泽东思想为党的指导思想三大作风新党章：群众路线；民主集中制</p><h2 id="解放战争时期"><a href="#解放战争时期" class="headerlink" title="解放战争时期"></a>解放战争时期</h2><h3 id="晋绥干部会议（1948-3）"><a href="#晋绥干部会议（1948-3）" class="headerlink" title="晋绥干部会议（1948.3）"></a>晋绥干部会议（1948.3）</h3><p>毛泽东作《在晋绥干部会议上的讲话》</p><ol><li>提出我党土改路线； </li><li>完整概括了新民主主义革命总路线</li></ol><h3 id="中共中央政治局会议（1948-9）"><a href="#中共中央政治局会议（1948-9）" class="headerlink" title="中共中央政治局会议（1948.9）"></a>中共中央政治局会议（1948.9）</h3><p>国体（国家政权的阶级性）：无产阶级领导的、以工农联盟为基础，还有资产阶级民主分子参加的人民民主专政政体（国家政权的组织）：不搞西方的议会制，应当建立民主集中制的各级人民代表大会制度</p><h3 id="中国七届二中（西柏坡会议-1949-3-经济建设问题）"><a href="#中国七届二中（西柏坡会议-1949-3-经济建设问题）" class="headerlink" title="中国七届二中（西柏坡会议 1949.3 经济建设问题）"></a>中国七届二中（西柏坡会议 1949.3 经济建设问题）</h3><ol><li>工作重点；农村→城市</li><li>两个转变：农业国→工业国，新民主主义社会→社会主义社会</li><li>提出“<strong>两个务必</strong>”思想：务必保持谦虚谨慎、不骄不躁的作风；务必保持艰苦奋斗的作风</li></ol><p><strong>影响</strong></p><p>两种基本矛盾：国际上，新中国和帝国主义的矛盾；国内：工人阶级和资产阶级的矛盾。因此提出了社会主义革命任务</p><h3 id="中国人民政治协商会议第一届全体会议（1949-9北平中南海怀仁堂）"><a href="#中国人民政治协商会议第一届全体会议（1949-9北平中南海怀仁堂）" class="headerlink" title="中国人民政治协商会议第一届全体会议（1949.9北平中南海怀仁堂）"></a>中国人民政治协商会议第一届全体会议（1949.9北平中南海怀仁堂）</h3><p>一．通过了《中国人民政治协商会议共同纲领》&#x2F;《共同纲领》</p><ol><li>国体：中华人民共和国为新民主主义国家（人民民主主义国家），实行工人阶级领导的、以工农联盟为基础的、团结各民主阶级和国内各民族的人民民主专政2</li><li>政体：实行人民代表大会制度</li><li>民主集中制</li><li>民族：民族一律平等，实行民族区域自治制度</li><li>经济政策：“公私兼顾、劳资两利、城乡互助、内外交流”</li><li>外交：保障本国独立、自由和领土主权完整，维护国际的持久和平和各国人民间的友好合作，反对帝国主义的侵略政策和战争政策</li></ol><p><strong>影响</strong></p><p>《共同纲领》临时宪法《共同纲领》从法律上正式确立了我党在全国的执政地位</p><h2 id="三大改造时期"><a href="#三大改造时期" class="headerlink" title="三大改造时期"></a>三大改造时期</h2><h3 id="中共七届三中全会（1950-6）"><a href="#中共七届三中全会（1950-6）" class="headerlink" title="中共七届三中全会（1950.6）"></a>中共七届三中全会（1950.6）</h3><ol><li>中心任务：三年左右，国家财政经济状况的根本好转《为争取国家财政经济状况的基本好转而奋斗》</li><li>战略策略方针：不要四面出击，应当集中力量向国民党残余势力、封建地主阶级和帝国主义进攻</li></ol><h2 id="十年建设时期"><a href="#十年建设时期" class="headerlink" title="十年建设时期"></a>十年建设时期</h2><h3 id="中央书记处会议（1956-4）"><a href="#中央书记处会议（1956-4）" class="headerlink" title="中央书记处会议（1956.4）"></a>中央书记处会议（1956.4）</h3><p>毛泽东：马克思主义和中国实际进行第二次结合</p><p><strong>影响</strong></p><p>适合中国国情的社会主义建设道路理论指导</p><h3 id="中共八大（1956-9）"><a href="#中共八大（1956-9）" class="headerlink" title="中共八大（1956.9）"></a>中共八大（1956.9）</h3><ol><li>基本任务: 团结全党，团结国内外可能团结的一切力量，为了建设一个伟大的社会主义中国而奋斗</li><li>主要矛盾和主要任务（在新的关系下保护和发展生产力）</li><li>经济建设方针：既反保守又反冒进，即在综合平衡中稳步前进陈云“三个主体、三个补充”思想（国家经济和集体经济vs个体经营；计划生产vs自由生产；国家市场vs自由市场）</li></ol><h3 id="扩大的最高国务会议（1957-2）"><a href="#扩大的最高国务会议（1957-2）" class="headerlink" title="扩大的最高国务会议（1957.2）"></a>扩大的最高国务会议（1957.2）</h3><p>毛泽东《关于正确处理人民内部矛盾问题》的报告 【正确处理人民内部矛盾】民主党派：长期共存、互相监督1. 政治思想领域：团结—批评—团结 2.经济：统筹兼顾，恰当安排 3.科学文化领域：百花齐放，百家争鸣</p><h3 id="中共八届二中全会（1956-11）"><a href="#中共八届二中全会（1956-11）" class="headerlink" title="中共八届二中全会（1956.11）"></a>中共八届二中全会（1956.11）</h3><p>提出整风运动。反对官僚主义、宗派主义和主观主义</p><h3 id="中共八届三种全会（1957-10）"><a href="#中共八届三种全会（1957-10）" class="headerlink" title="中共八届三种全会（1957.10）"></a>中共八届三种全会（1957.10）</h3><p>认为当前国内的主要矛盾仍然是无产阶级和资产阶级、社会主义道路和资产阶级道路之间的矛盾【×】</p><h3 id="中共八大二次会议（1958-5）"><a href="#中共八大二次会议（1958-5）" class="headerlink" title="中共八大二次会议（1958.5）"></a>中共八大二次会议（1958.5）</h3><p>“鼓足干劲、力争上游、多快好省的建设社会主义”</p><p><strong>影响</strong></p><p>开始大跃进【×】</p><h3 id="中央政治局北戴河（1958-8）"><a href="#中央政治局北戴河（1958-8）" class="headerlink" title="中央政治局北戴河（1958.8）"></a>中央政治局北戴河（1958.8）</h3><p>《关于在农村建立人民公社问题的决议》</p><p><strong>影响</strong></p><p>人民公社运动【×】</p><h3 id="中共八届九中全会（1961-1）"><a href="#中共八届九中全会（1961-1）" class="headerlink" title="中共八届九中全会（1961.1）"></a>中共八届九中全会（1961.1）</h3><p>“调整、巩固、充实、提高”八字方针</p><h3 id="七千人大会（1962-1）"><a href="#七千人大会（1962-1）" class="headerlink" title="七千人大会（1962.1）"></a>七千人大会（1962.1）</h3><p>总结了大跃进以来的经验教训</p><p><strong>影响</strong></p><p>总结了大跃进以来的经验教训</p><h2 id="改革开放新时期"><a href="#改革开放新时期" class="headerlink" title="改革开放新时期"></a>改革开放新时期</h2><h3 id="十一届三中全会（1978-12）"><a href="#十一届三中全会（1978-12）" class="headerlink" title="十一届三中全会（1978.12）"></a>十一届三中全会（1978.12）</h3><ol><li>彻底否定“两个凡是”错误方针，高度评价了关于真理标准的讨论</li><li>改革开放</li><li>重新确立马克思主义的思想路线、政治路线和组织路线</li><li>恢复了民主集中制的优良传统，审查了一批历史重大遗留问题和领导人的功过是非问题</li></ol><p><strong>影响</strong></p><p>以邓小平为核心的党中央领导集体；进入了改革开放和社会主义现代化建设新时期</p><h3 id="中共中央工作会议（1979-4）"><a href="#中共中央工作会议（1979-4）" class="headerlink" title="中共中央工作会议（1979.4）"></a>中共中央工作会议（1979.4）</h3><p>实行新八字方针：“调整、改革、整顿、提高”</p><h3 id="理论工作务虚会（1979-3）"><a href="#理论工作务虚会（1979-3）" class="headerlink" title="理论工作务虚会（1979.3）"></a>理论工作务虚会（1979.3）</h3><p>邓小平做《坚持四项基本原则》的讲话，首次提出了“四项基本原则”这一概念</p><h3 id="十一届六中全会（1981-6）"><a href="#十一届六中全会（1981-6）" class="headerlink" title="十一届六中全会（1981.6）"></a>十一届六中全会（1981.6）</h3><p>《关于建国以后党的若干历史问题的决议》</p><p><strong>影响</strong></p><p>科学评价了毛泽东和毛泽东思想的历史地位</p><h3 id="十二大（1982）"><a href="#十二大（1982）" class="headerlink" title="十二大（1982）"></a>十二大（1982）</h3><p>“建设有中国特色社会主义” 理论确立，经济建设总目标：“翻两番”</p><p><strong>影响</strong></p><p>体现了社会主义现代化建设的全面性要求</p><h3 id="十二届三中全会（1948-10）"><a href="#十二届三中全会（1948-10）" class="headerlink" title="十二届三中全会（1948.10）"></a>十二届三中全会（1948.10）</h3><p>计划经济同商品经济对立：以城市为重点</p><h3 id="六届人大三次会议（1985-3）"><a href="#六届人大三次会议（1985-3）" class="headerlink" title="六届人大三次会议（1985.3）"></a>六届人大三次会议（1985.3）</h3><p>正式把“一国两制”确定为中国的一项基本国策。</p><h3 id="十三大（1987）"><a href="#十三大（1987）" class="headerlink" title="十三大（1987）"></a>十三大（1987）</h3><ol><li>系统阐述了<strong>社会主义初级阶段</strong>理论</li><li>社会主义初级阶段基本路线——“一个中心，两个基本点”</li><li>制定“三步走”发展战略，邓小平“台阶式”</li></ol><p><strong>影响</strong></p><p>突出贡献：社会主义初级阶段的理论和基本路线中心任务：加快和深化改革</p><h3 id="南方谈话十四大（1992）"><a href="#南方谈话十四大（1992）" class="headerlink" title="南方谈话十四大（1992）"></a>南方谈话十四大（1992）</h3><ol><li>确立<strong>社会主义市场经济</strong>体制改革的目标</li><li>确立邓小平理论的指导地位，概括了建设有中国特色社会主义理论的主要内容</li></ol><p><strong>影响</strong></p><p>以邓小平南方谈话和十四大为标志：改革开放和现代化建设事业计划经济体制→社会主义市场经济体制</p><h3 id="十五大（1997）"><a href="#十五大（1997）" class="headerlink" title="十五大（1997）"></a>十五大（1997）</h3><ol><li>把【邓小平理论】写进党章</li><li>基本经济制度是“以公有制为主体，多种所有制经济共同发展”</li><li>提出党领导人民治理国家的基本方略是【依法治国】</li></ol><p><strong>影响</strong></p><p>为中国特色社会主义事业的跨世纪发展提供了根本保证。</p><h3 id="十六大（2002）"><a href="#十六大（2002）" class="headerlink" title="十六大（2002）"></a>十六大（2002）</h3><ol><li>把【三个代表】写进党章</li><li>制定了全面建设小康社会的奋斗目标，指出要在本世纪头20年，紧紧抓住这一重要战略机遇期，集中力量，全面建设惠及十几亿人口的更高水平的小康社会（低水平、不全面、发展不平 到 高水平、更全面、发展比较均衡）</li><li>总结概括了十条基本经验</li></ol><h3 id="十七大（2007）"><a href="#十七大（2007）" class="headerlink" title="十七大（2007）"></a>十七大（2007）</h3><ol><li>全面阐释了科学发展观的含义</li><li>概括了中国特色社会主义道路和中国特色社会主义理论体系</li></ol>]]></content>
      
      
      <categories>
          
          <category> 死记硬背 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HashMap和HashSet和HashTable</title>
      <link href="/2023/03/16/HashMap%E5%92%8CHashSet%E5%92%8CHashTable/"/>
      <url>/2023/03/16/HashMap%E5%92%8CHashSet%E5%92%8CHashTable/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList和LinkedList</title>
      <link href="/2023/03/16/ArrayList%E5%92%8CLinkedList/"/>
      <url>/2023/03/16/ArrayList%E5%92%8CLinkedList/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Stack和Queue</title>
      <link href="/2023/03/16/Stack%E5%92%8CQueue/"/>
      <url>/2023/03/16/Stack%E5%92%8CQueue/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>斐波那契数列</title>
      <link href="/2023/03/14/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
      <url>/2023/03/14/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>​    斐波那契数列（Fibonacci sequence），又称<strong>黄金分割数列</strong>，因数学家莱昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”。</p><p>​    斐波那契数列指的是这样一个数列：</p><blockquote><p>0，1，1，2，3，5，8，13，21，34，55，89，144，233，377，610，987，1597，2584，4181，6765，10946，17711……</p></blockquote><p>  它的规律是：<strong>这个数列从第 3 项开始，每一项都等于前两项之和。</strong></p><p> 在数学上，斐波那契数列以如下被以递推的方法定义：<code>F(0)=0，F(1)=1, F(n)=F(n - 1)+F(n - 2)（n ≥ 2，n ∈ N*）</code>，显然，斐波那契数列是一个<strong>线性递推数列</strong>。</p><p><strong>代码实现</strong></p><p>递归法（较为耗时）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span> || n == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fib(n-<span class="number">1</span>) + fib(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代法（优先使用）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;<span class="comment">//n从0开始</span></span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//第n-1项</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//第n-2项</span></span><br><span class="line">    <span class="comment">//遍历从 a 的位置开始，即a是第1项，i就从1开始，</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">        a = a + b;</span><br><span class="line">        b = a - b;</span><br><span class="line">        <span class="comment">//a = a%1000000007;//1000000007是一个质数，对于int32来说它足够大，保证不会超出int类型范围</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>THE END</p>]]></content>
      
      
      <categories>
          
          <category> 技术连连看 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找算法</title>
      <link href="/2023/03/07/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
      <url>/2023/03/07/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p> 查找算法有七种，分别为：顺序查找、二分查找、插值查找、斐波那契查找、树表查找、分块查找、哈希查找。</p><h3 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>基本思路</p><ul><li>从第一个元素m开始逐个与需要查找的元素x进行比较，当比较到元素值相同(即m&#x3D;x)时返回元素m的下标，如果比较到最后都没有找到，则返回-1。</li></ul><p>复杂度分析　</p><ul><li>查找成功时的平均查找长度为： ASL &#x3D; 每个元素被查找的概率 * 总的元素的个数&#x3D;1&#x2F;n*(1+2+3+…+n) &#x3D; (n+1)&#x2F;2 ;</li><li>当查找不成功时，需要n+1次比较，时间复杂度为O(n)，所以，顺序查找的时间复杂度为O(n)。</li></ul><p>优缺点</p><ul><li>缺点：是当n 很大时，平均查找长度较大，效率低；</li><li>优点：是对表中数据元素的存储没有要求。另外，对于线性链表，只能进行顺序查找。</li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sequenceSearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target)</span> &#123;    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++)&#123;<span class="comment">//第一次比较，判断下标是否越界        </span></span><br><span class="line">        <span class="keyword">if</span>(arr[i] == target)&#123;<span class="comment">//第二次比较，判断值是否相等</span></span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="顺序查找优化"><a href="#顺序查找优化" class="headerlink" title="顺序查找优化"></a>顺序查找优化</h4><p>在算法中，比较和赋值都是比较耗时的，上面算法中每次都会进行两次比较，所以可以将要查找的值放入数组的开头或者结尾作为哨兵，这样在遍历过程中总会找到这个值，至少哨兵位是这个值，省去了对下标是否越界的判断，预处理操作如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">//预处理数据</span></span><br><span class="line"><span class="type">int</span>[] newArr = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length + <span class="number">1</span>];<span class="comment">//0号作为哨兵</span></span><br><span class="line">newArr[<span class="number">0</span>] = target;<span class="comment">//将target放进数据开头</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">    newArr[i + <span class="number">1</span>] = arr[i];<span class="comment">//原数组数据整体后移一位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述中预处理数据需要将数组中所有数据都移动一遍，看起来更加花费时间，实际上也确实如此。但是在面对大量数据时，常常要对数据做预处理，因为这会使数据在进行其他操作时更加方便（不单单是查找），在这里也会使查找效率变高，优化后算法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sequenceSearchPlus</span><span class="params">(<span class="type">int</span>[] newArr, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="comment">//倒序查找（若将target放在最后，则正序查找）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> newArr.length-<span class="number">1</span>;       </span><br><span class="line">    <span class="keyword">while</span>(newArr[index] != target)&#123;<span class="comment">//第一次比较，判断值是否相等</span></span><br><span class="line">        index--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回哨兵位则未找到</span></span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//预处理数据</span></span><br><span class="line">        <span class="type">int</span>[] newArr = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length + <span class="number">1</span>];<span class="comment">//0号作为哨兵</span></span><br><span class="line">        newArr[<span class="number">0</span>] = target;<span class="comment">//将target放进数据开头</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">            newArr[i + <span class="number">1</span>] = arr[i];<span class="comment">//原数组数据整体后移一位</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> sequenceSearchPlus(newArr,target) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(res &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(target + <span class="string">&quot;存在，下标为：&quot;</span> + res);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;值不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sequenceSearchPlus</span><span class="params">(<span class="type">int</span>[] newArr, <span class="type">int</span> target)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//倒序查找（若将target放在最后，则正序查找）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> newArr.length-<span class="number">1</span>;       </span><br><span class="line">        <span class="keyword">while</span>(newArr[index] != target)&#123;<span class="comment">//第一次比较，判断值是否相等</span></span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回哨兵位则未找到</span></span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二分查找（折半查找）"><a href="#二分查找（折半查找）" class="headerlink" title="二分查找（折半查找）"></a>二分查找（折半查找）</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>二分查找，是一种在<strong>有序数组</strong>中查找某一特定元素的查找算法。</p><p>基本思路</p><ul><li>用给定值k先与中间结点的关键字比较，中间结点把线形表分成两个子表，若相等则查找成功；若不相等，再根据k与该中间结点关键字的比较结果确定下一步查找哪个子表，这样递归进行，直到查找到或查找结束发现表中没有这样的结点。</li></ul><p>复杂度分析</p><ul><li>时间复杂度：折半搜索每次把搜索区域减少一半，时间复杂度为O(logn) 。</li><li>空间复杂度：O(1)。</li></ul><p>优缺点分析</p><ul><li>当查找表不会频繁有更新、删除操作时，使用折半查找是比较理想的。如果查找表有较频繁的更新、删除操作，维护表的有序会花费比较大的精力，不建议使用该查找方式。</li></ul><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><p>使用java实现这边查找有两种方式：迭代法和递归法</p><p>迭代法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch1</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> mid ;</span><br><span class="line">    <span class="keyword">if</span>(target &lt; arr[left] || target &gt; arr[right])&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        mid = (left + right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] == target)&#123;</span><br><span class="line">            <span class="comment">//相等时返回下标</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[mid] &gt; target)&#123;</span><br><span class="line">            <span class="comment">//arr[mid]大于target，则target元素在左半边，下标在left和mid之间，左边界仍为left，右边界修改为mid-1</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; target)&#123;</span><br><span class="line">            <span class="comment">//arr[mid]小于target，则target元素在右半边，下标在right和mid之间，左边界修改为mid+1，右边界仍为right</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//未找到返回-1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch2</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(target &lt; arr[left] || target &gt; arr[right])&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] == target)&#123;</span><br><span class="line">            <span class="comment">//相等时返回下标</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[mid] &gt; target)&#123;</span><br><span class="line">            <span class="comment">//arr[mid]大于target，则target元素在左半边，下标在left和mid之间，左边界仍为left，右边界修改为mid-1</span></span><br><span class="line">            <span class="keyword">return</span> binarySearch2(arr, left, mid - <span class="number">1</span>, target);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//arr[mid]小于target，则target元素在右半边，下标在right和mid之间，左边界修改为mid+1，右边界仍为right</span></span><br><span class="line">            <span class="keyword">return</span> binarySearch2(arr, mid + <span class="number">1</span>, right, target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//未找到返回-1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h3><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><p>​在二分查找中，每次都是从待查找序列的中间点开始查找，这样的做法在正确性上固然没什么问题，但假如要查找的值距离某个边界比较近，还从中间点开始查找，就有点浪费时间了。举个例子来说说明，假如在在一个{1,2…,100}的数组中，要查找88这个值，还一直采用和中间点比较的策略，就显得不太明智，因为明显可以明显从较为靠后的位置去检索。为了克服这种弊端， 引入了插值查找。<br>基本思路</p><ul><li>插值查找是根据要查找的关键字key与查找表中最大最小记录的关键字比较后的 查找方法，其核心就在于插值的计算公式 (key-array[low])&#x2F;(array[high]-array[low])*(high-low)。简而言之，基于二分查找算法，将查找点的选择改进为自适应选择。</li></ul><p>复杂度分析　</p><ul><li>时间复杂性：如果元素均匀分布，则O(log(logn))，在最坏的情况下可能需要O(n)。</li><li>空间复杂度：O(1)。</li></ul><p>优缺点分析</p><ul><li>对于长度比较长、关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。</li></ul><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><p>二分查找中，mid的计算方式如下：<br>$$<br>mid &#x3D; \frac{left+right}{2}<br>$$<br>将left从分数中提取出来，mid的计算变成：<br>$$<br>mid &#x3D; left +  \frac{right - left}{2}<br>$$<br>在插值查找中，1&#x2F;2变成了由key所占的比例：<br>$$<br>mid &#x3D; left + \frac{key - arr[left]}{arr[right] - arr[left]}(right-left)<br>$$<br>代码如下：</p><p>迭代法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">insertSearch1</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> mid ;</span><br><span class="line">    <span class="keyword">if</span>(target &lt; arr[left] || target &gt; arr[right])&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        mid = left+(target-arr[left])/(arr[right]-arr[left])*(right-left);</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] == target)&#123;</span><br><span class="line">            <span class="comment">//相等时返回下标</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[mid] &gt; target)&#123;</span><br><span class="line">            <span class="comment">//arr[mid]大于target，则target元素在左半边，下标在left和mid之间，左边界仍为left，右边界修改为mid-1</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; target)&#123;</span><br><span class="line">            <span class="comment">//arr[mid]小于target，则target元素在右半边，下标在right和mid之间，左边界修改为mid+1，右边界仍为right</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//未找到返回-1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">insertSearch2</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(target &lt; arr[left] || target &gt; arr[right])&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left+(target-arr[left])/(arr[right]-arr[left])*(right-left);</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] == target)&#123;</span><br><span class="line">            <span class="comment">//相等时返回下标</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[mid] &gt; target)&#123;</span><br><span class="line">            <span class="comment">//arr[mid]大于target，则target元素在左半边，下标在left和mid之间，左边界仍为left，右边界修改为mid-1</span></span><br><span class="line">            <span class="keyword">return</span> insertSearch2(arr, left, mid - <span class="number">1</span>, target);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//arr[mid]小于target，则target元素在右半边，下标在right和mid之间，左边界修改为mid+1，右边界仍为right</span></span><br><span class="line">            <span class="keyword">return</span> insertSearch2(arr, mid + <span class="number">1</span>, right, target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//未找到返回-1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="斐波那契查找-搞不懂"><a href="#斐波那契查找-搞不懂" class="headerlink" title="斐波那契查找(搞不懂~)"></a>斐波那契查找(搞不懂~)</h3><h4 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h4><p>和前面的二分查找、插值查找相比，斐波那契查找是类似的，不过换了一种寻找mid点的方法。顾名思义，该种查找方法中，使用到了斐波那契数列，斐波那契数列的形式是：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89…….（从第三个数开始，后边每一个数都是前两个数的和）。<br>基本思路</p><ul><li>在斐波那契数列中的元素满足这样的关系：F[k]&#x3D;F[k-1]+F[k-2]，此处将这个数组稍微改一下，改成：（F[k]-1）&#x3D;（F[k-1]-1）+（F[k-2]-1）+1，图示如下：</li></ul><p><img src="/2023/03/07/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%8E%9F%E7%90%86.png" alt="斐波那契原理"></p><ul><li>通过上面的图，应该就可以看出为什么要这样分割数组了，因为要找出一个中间mid值，以便将数组按斐波那契数列的规律，分割成两部分。</li></ul><p>复杂度分析</p><ul><li>最坏情况下，时间复杂度为O(logn)，且其期望复杂度也为O(logn)。</li></ul><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><p>上面介绍了分割的方法，但还有一个问题，就是斐波那契数列中的数值都是固定的，但要查找的数组的长度不固定，这样情况要怎么办？此时需要的是创建新数组，使新数组的长度是斐波那契数列中的值，并且是比原数组长度略大的值（此处只能是略大，因为略小的话，就会导致原数组元素丢失），多出来的元素用原数组最高位元素补充，示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> f[] = fib();</span><br><span class="line"><span class="comment">/*获取最相邻的斐波那契数组中元素的值，该值略大于数组的长度*/</span></span><br><span class="line"><span class="keyword">while</span>(high &gt; f[k] - <span class="number">1</span>) &#123;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*因为 f[k]值可能大于arr的长度。如果大于时，需要构造一个新的数组temp[]，将arr数组中的元素拷贝过去，不足的部分会使用0填充*/</span></span><br><span class="line"><span class="type">int</span>[] temp=Arrays.copyOf(arr, f[k]);</span><br><span class="line"><span class="comment">/*然后将temp后面填充的0，替换为最后一位数字</span></span><br><span class="line"><span class="comment"> *如将temp数组由&#123;1,8,10,89,100,134,0,0&#125;变换为&#123;1,8,10,89,100,134,134,134&#125;*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> high + <span class="number">1</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">temp[i] = arr[high];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解决了如何分割、如果创建临时新数组后，还有一个问题：怎么判断最后target &#x3D;&#x3D; arr[i]时，这个arr[i]是原来的数组中的元素，还是在新数组中扩展出来的元素？如果是新数组中扩展出来的元素，该元素的下标是大于原数组元素的最大下标的，肯定不是要寻找的位置。其实该问题容易解决，就是当target &#x3D;&#x3D; arr[i]时，如果arr[i]的下标&gt;原数组最大下标时，直接返回元数组最大下标即可。示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">/*原arr数组中的值*/</span></span><br><span class="line">   <span class="keyword">if</span>(mid &lt;= high)&#123;</span><br><span class="line">       <span class="keyword">return</span> mid;</span><br><span class="line">       <span class="comment">/*在temp中，扩展出来的高位的值*/</span></span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> high;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>完整斐波那契查找示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FibonacciSearch</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">FLENGTH</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> [] arr = &#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">89</span>,<span class="number">100</span>,<span class="number">134</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">89</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;目标元素在数组中位置是：&quot;</span> + fibSearch(arr, target));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] fib() &#123;</span><br><span class="line"><span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[FLENGTH];</span><br><span class="line">f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; FLENGTH; i++) &#123;</span><br><span class="line">f[i] = f[i-<span class="number">1</span>] + f[i-<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fibSearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line"><span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line"><span class="type">int</span> f[] = fib();</span><br><span class="line"><span class="comment">/*获取最相邻的斐波那契数组中元素的值，该值略大于数组的长度*/</span></span><br><span class="line"><span class="keyword">while</span>(high &gt; f[k] - <span class="number">1</span>) &#123;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*因为 f[k]值可能大于arr的长度。如果大于时，需要构造一个新的数组temp[]，将arr数组中的元素拷贝过去，不足的部分会使用0填充*/</span></span><br><span class="line"><span class="type">int</span>[] temp=Arrays.copyOf(arr, f[k]);</span><br><span class="line"><span class="comment">/*然后将temp后面填充的0，替换为最后一位数字</span></span><br><span class="line"><span class="comment"> *如将temp数组由&#123;1,8,10,89,100,134,0,0&#125;变换为&#123;1,8,10,89,100,134,134,134&#125;*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> high + <span class="number">1</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">temp[i] = arr[high];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (low &lt;= high) &#123; </span><br><span class="line">mid = low + f[k - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(target &lt; temp[mid]) &#123; </span><br><span class="line">high = mid - <span class="number">1</span>;</span><br><span class="line"><span class="comment">/*因为f[k]=f[k-1]+f[k-2]，所以k--就相当于取temp数组的左边部分*/</span></span><br><span class="line">k--;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( target &gt; temp[mid]) &#123; </span><br><span class="line">low = mid + <span class="number">1</span>;</span><br><span class="line"><span class="comment">/*同理，f[k]=f[k-1]+f[k-2]，k -= 2就相当于取temp数组的右边部分*/</span></span><br><span class="line">k -= <span class="number">2</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*原arr数组中的值*/</span></span><br><span class="line"><span class="keyword">if</span>(mid &lt;= high)&#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line"><span class="comment">/*在temp中，扩展出来的高位的值*/</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> high;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="树表查找"><a href="#树表查找" class="headerlink" title="树表查找"></a>树表查找</h3><h4 id="二叉树查找介绍"><a href="#二叉树查找介绍" class="headerlink" title="二叉树查找介绍"></a>二叉树查找介绍</h4><p>二叉排序树是最简单的树表查找算法，该算法需要利用待查找的数据，进行生成树，确保树的左分支的值小于右分支的值，然后在就行和每个节点的父节点比较大小，然后再进行查找。</p><p><strong>二叉排序树性质</strong></p><p>二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：</p><ol><li>若左子树不空，则左子树上所有结点的键值均小于或等于它的根结点的键值。</li><li>若右子树不空，则右子树上所有结点的键值均大于或等于它的根结点的键值。</li><li>左、右子树也分别为二叉排序树。</li></ol><h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><p>首先，要创建一个树的节点，节点中要有该节点储存的值，然后起左右子树。示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span>&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    BinaryTree left;</span><br><span class="line">    BinaryTree right;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BinaryTree</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来就要创建二叉排序树，创建二叉排序树是一个递归的过程，需要将序列中的值一个一个添加到二叉树中。方便起见，可以利用序列中第一个元素作为根节点，再持续添加节点，示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] array = &#123;<span class="number">35</span>,<span class="number">76</span>,<span class="number">6</span>,<span class="number">22</span>,<span class="number">16</span>,<span class="number">49</span>,<span class="number">49</span>,<span class="number">98</span>,<span class="number">46</span>,<span class="number">9</span>,<span class="number">40</span>&#125;;</span><br><span class="line"><span class="type">BinaryTree</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinaryTree</span>(array[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">    createBST(root, array[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>具体创建树的过程，就是一个不断与根节点比较，然后添加到左侧、右侧或不添加的过程。也许有人会有疑问，为什么会存在不添加的情况？因为在二叉排序树中，不存在重复元素，有相等元素已经在树中时，直接忽略后续相等元素。示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">createBST</span><span class="params">(BinaryTree root, <span class="type">int</span> element)</span>&#123;</span><br><span class="line">    <span class="type">BinaryTree</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinaryTree</span>(element);</span><br><span class="line">    <span class="keyword">if</span>(element &gt; root.value)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.right == <span class="literal">null</span>)</span><br><span class="line">            root.right = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createBST(root.right, element);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(element &lt; root.value)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span>)</span><br><span class="line">            root.left = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createBST(root.left, element);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;该节点&quot;</span> + element + <span class="string">&quot;已存在&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查找元素是否在树中的过程，就是一个二分查找的过程，不过查找的对象从左右子序列转换成了左右子树而已。示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">searchBST</span><span class="params">(BinaryTree root, <span class="type">int</span> target, BinaryTree p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;查找&quot;</span>+target+<span class="string">&quot;失败&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.value == target)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;查找&quot;</span>+target+<span class="string">&quot;成功&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.value &gt;= target)&#123;</span><br><span class="line">        searchBST(root.left, target, root);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">        searchBST(root.right, target, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySortTree</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] array = &#123;<span class="number">35</span>,<span class="number">76</span>,<span class="number">6</span>,<span class="number">22</span>,<span class="number">16</span>,<span class="number">49</span>,<span class="number">49</span>,<span class="number">98</span>,<span class="number">46</span>,<span class="number">9</span>,<span class="number">40</span>&#125;;</span><br><span class="line">        <span class="type">BinaryTree</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinaryTree</span>(array[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">            createBST(root, array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;中序遍历结果：&quot;</span>);</span><br><span class="line">        midOrderPrint(root);</span><br><span class="line">        System.out.println();</span><br><span class="line">        searchBST(root, <span class="number">22</span>, <span class="literal">null</span>);</span><br><span class="line">        searchBST(root, <span class="number">100</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*创建二叉排序树*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">createBST</span><span class="params">(BinaryTree root, <span class="type">int</span> element)</span>&#123;</span><br><span class="line">        <span class="type">BinaryTree</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinaryTree</span>(element);</span><br><span class="line">        <span class="keyword">if</span>(element &gt; root.value)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.right == <span class="literal">null</span>)</span><br><span class="line">                root.right = newNode;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                createBST(root.right, element);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(element &lt; root.value)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left == <span class="literal">null</span>)</span><br><span class="line">                root.left = newNode;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                createBST(root.left, element);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;该节点&quot;</span> + element + <span class="string">&quot;已存在&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*二叉树中查找元素*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">searchBST</span><span class="params">(BinaryTree root, <span class="type">int</span> target, BinaryTree p)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;查找&quot;</span>+target+<span class="string">&quot;失败&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.value == target)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;查找&quot;</span>+target+<span class="string">&quot;成功&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.value &gt;= target)&#123;</span><br><span class="line">            searchBST(root.left, target, root);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">            searchBST(root.right, target, root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*二叉树的中序遍历*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">midOrderPrint</span><span class="params">(BinaryTree rt)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rt != <span class="literal">null</span>)&#123;</span><br><span class="line">        midOrderPrint(rt.left);</span><br><span class="line">            System.out.print(rt.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            midOrderPrint(rt.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h3><h4 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h4><p>分块查找，顾名思义，要先将所有元素按大小进行分块，然后在块内进行查找。在分块时，块内的元素不一定是有序的，只要一个块内的元素在同一区间就行。用较标准的语言描述是：算法的思想是将n个数据元素”按块有序”划分为m块（m≤n）。每一块中的结点不必有序，但块与块之间必须”按块有序”，每个块内的的最大元素小于下一块所有元素的任意一个值。<br>所以，在使用分块查找时，分成了两步：</p><ol><li>找到元素可能在的块。</li><li>在对应的块内查找元素。</li></ol><h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><p>在上个章节说到，该方法要先分块，那么块应该具有怎样的属性呢？至少要有以下元素：<br>长度</p><ul><li>一般是固定的长度。</li></ul><p>起始位置</p><ul><li>当块的长度固定后，需要确定起始位置才能固定不同的块表示的元素的位置范围。</li></ul><p>块标识</p><ul><li>该标识用来标识块内元素的范围，可以用最大值、最小值、平均值等多种方式来表示。</li></ul><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Block</span> &#123;</span><br><span class="line"><span class="comment">/*block的索引，用来标识块中元素*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> index;</span><br><span class="line">    <span class="comment">/*该block的开始位置*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> start; </span><br><span class="line">    <span class="comment">/*块元素长度，在该例子中0代表空元素，不计入block长度*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Block</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> start, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.index = index;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.length = length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在该例子中，定义元素数组和块数组，示例如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*主表*/</span></span><br><span class="line">   <span class="keyword">static</span> <span class="type">int</span>[] valueList = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;</span><br><span class="line">   <span class="number">104</span>, <span class="number">101</span>, <span class="number">103</span>, <span class="number">105</span>,<span class="number">102</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">       <span class="number">201</span>, <span class="number">202</span>, <span class="number">204</span>, <span class="number">203</span>,<span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">       <span class="number">303</span>, <span class="number">301</span>, <span class="number">302</span>,  <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*索引表*/</span></span><br><span class="line">   <span class="keyword">static</span> Block[] indexList = <span class="keyword">new</span> <span class="title class_">Block</span>[]&#123;</span><br><span class="line">   <span class="keyword">new</span> <span class="title class_">Block</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">5</span>),</span><br><span class="line">   <span class="keyword">new</span> <span class="title class_">Block</span>(<span class="number">2</span>, <span class="number">10</span>, <span class="number">4</span>),</span><br><span class="line">   <span class="keyword">new</span> <span class="title class_">Block</span>(<span class="number">3</span>, <span class="number">20</span>, <span class="number">3</span>)</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>valueList中的0，可以简单理解为块内的空元素；indexList中的1,2,3代表块内元素的取值范围，第一个块内是100-200之间的元素，第2个块内是200-300之间的元素，以此类推。<br>在进行元素查找时，先判断是否存在元素可能存在的块。示例如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*确定插入到哪个块中，在该例子中，第一个block中放的是100-200之间的数，第二个block中放的是200-300之间的数，以此类推*/</span></span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> key/<span class="number">100</span>;</span><br><span class="line"><span class="comment">/*找到对应的block*/</span></span><br><span class="line"><span class="comment">//块之间有序，可用二分查找，一下并未使用二分查找</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; indexList.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(indexList[i].index == index) &#123;</span><br><span class="line">        indexItem = indexList[i];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*如果数组中不存在对应的块，则返回-1，查找失败*/</span></span><br><span class="line"><span class="keyword">if</span>(indexItem == <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>找到内对的块后，就在该块内进行搜索，示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*在对应的block中查找*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexItem.start; i &lt; indexItem.start + indexItem.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(valueList[i] == key)</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果需要在数组中插入元素，同样需要需要先查找是否存在对应的块，如果存在，则追加到该块中元素的尾部。<br>完整示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockSearch</span> &#123;</span><br><span class="line"><span class="comment">/*主表*/</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] valueList = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;</span><br><span class="line">    <span class="number">104</span>, <span class="number">101</span>, <span class="number">103</span>, <span class="number">105</span>,<span class="number">102</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">201</span>, <span class="number">202</span>, <span class="number">204</span>, <span class="number">203</span>,<span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">303</span>, <span class="number">301</span>, <span class="number">302</span>,  <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*索引表*/</span></span><br><span class="line">    <span class="keyword">static</span> Block[] indexList = <span class="keyword">new</span> <span class="title class_">Block</span>[]&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Block</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">5</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Block</span>(<span class="number">2</span>, <span class="number">10</span>, <span class="number">4</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Block</span>(<span class="number">3</span>, <span class="number">20</span>, <span class="number">3</span>)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;原始主表：&quot;</span>);</span><br><span class="line">printElemts(valueList);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*分块查找*/</span></span><br><span class="line"><span class="type">int</span> <span class="variable">searchValue</span> <span class="operator">=</span> <span class="number">203</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;元素&quot;</span>+searchValue+<span class="string">&quot;，在列表中的索引为：&quot;</span>+blockSearch(searchValue)+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*插入数据并查找*/</span></span><br><span class="line"><span class="type">int</span> <span class="variable">insertValue</span> <span class="operator">=</span> <span class="number">106</span>;</span><br><span class="line">         </span><br><span class="line"><span class="comment">/*插入成功，查找插入位置*/</span></span><br><span class="line">    <span class="keyword">if</span> (insertBlock(insertValue)) &#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;插入元素&quot;</span>+insertValue+<span class="string">&quot;后的主表：&quot;</span>);</span><br><span class="line">   printElemts(valueList);</span><br><span class="line">   System.out.println(<span class="string">&quot;元素&quot;</span> + insertValue + <span class="string">&quot;在列表中的索引为：&quot;</span> + blockSearch(insertValue));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printElemts</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">        System.out.print(array[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> ((i+<span class="number">1</span>)%<span class="number">10</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*插入数据*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">insertBlock</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">Block</span> <span class="variable">item</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*确定插入到哪个块中，在该例子中，第一个block中放的是100-200之间的数，第二个block中放的是200-300之间的数，以此类推*/</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> key/<span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*找到对应的block*/</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; indexList.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (indexList[i].index == index) &#123;</span><br><span class="line">            item = indexList[i];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*如果数组中不存在对应的块，则不能插入该数据*/</span></span><br><span class="line">    <span class="keyword">if</span> (item == <span class="literal">null</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*将元素插入到每个块的最后*/</span></span><br><span class="line">    valueList[item.start + item.length] = key;</span><br><span class="line">    <span class="comment">/*更新该块的长度*/</span></span><br><span class="line">    indexList[i].length++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">blockSearch</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">Block</span> <span class="variable">indexItem</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*确定插入到哪个块中，在该例子中，第一个block中放的是100-200之间的数，第二个block中放的是200-300之间的数，以此类推*/</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> key/<span class="number">100</span>;</span><br><span class="line">    <span class="comment">/*找到对应的block*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; indexList.length; i++) &#123;</span><br><span class="line">       <span class="keyword">if</span>(indexList[i].index == index) &#123;</span><br><span class="line">           indexItem = indexList[i];</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*如果数组中不存在对应的块，则返回-1，查找失败*/</span></span><br><span class="line">   <span class="keyword">if</span>(indexItem == <span class="literal">null</span>)</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*在对应的block中查找*/</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexItem.start; i &lt; indexItem.start + indexItem.length; i++) &#123;</span><br><span class="line">       <span class="keyword">if</span>(valueList[i] == key)</span><br><span class="line">           <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="哈希查找（算了太难了，不看了）"><a href="#哈希查找（算了太难了，不看了）" class="headerlink" title="哈希查找（算了太难了，不看了）"></a>哈希查找（算了太难了，不看了）</h3>]]></content>
      
      
      <categories>
          
          <category> 技术连连看 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/2023/03/07/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2023/03/07/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="各种排序的复杂度"><a href="#各种排序的复杂度" class="headerlink" title="各种排序的复杂度"></a>各种排序的复杂度</h3><table><thead><tr><th>排序方式</th><th>平均时间复杂度</th><th>最坏时间复杂度</th><th>最好时间复杂度</th><th>空间复杂度</th><th>稳定性</th><th>备注</th></tr></thead><tbody><tr><td>快速</td><td>O(nlog<del>2</del>(n))</td><td>O(n^2^)</td><td>O(nlog<del>2</del>(n))</td><td>O(log<del>2</del>n)</td><td>不稳定</td><td>最坏比较次数：n(n-1)&#x2F;2</td></tr><tr><td>归并</td><td>O(nlog<del>2</del>(n))</td><td>O(nlog<del>2</del>(n))</td><td>O(nlog<del>2</del>(n))</td><td>O(n)</td><td>稳定</td><td></td></tr><tr><td>堆</td><td>O(nlog<del>2</del>(n))</td><td>O(nlog<del>2</del>(n))</td><td>O(nlog<del>2</del>(n))</td><td>O(1)</td><td>不稳定</td><td></td></tr><tr><td>冒泡</td><td>O(n^2^)</td><td>O(n^2^)</td><td>O(n)</td><td>O(1)</td><td>稳定</td><td>最坏比较次数：n(n-1)&#x2F;2</td></tr><tr><td>选择</td><td>O(n^2^)</td><td>O(n^2^)</td><td>O(n^2^)</td><td>O(1)</td><td>不稳定</td><td></td></tr><tr><td>插入</td><td>O(n^2^)</td><td>O(n^2^)</td><td>O(n)</td><td>O(1)</td><td>不稳定</td><td></td></tr><tr><td>希尔</td><td>O(n^(1.3~2)^)</td><td>O(n^2^)</td><td>O(n)</td><td>O(1)</td><td>不稳定</td><td></td></tr><tr><td>基数</td><td>*O(d(n+r))</td><td>*O(d(n+r))</td><td>*O(d(n+r))</td><td>*O(r)</td><td>稳定</td><td>*d为位数，r为基数</td></tr><tr><td>计数</td><td>O(n+k)</td><td>O(n+k)</td><td>O(n+k)</td><td>O(n+k)</td><td>稳定</td><td>k是整数的范围</td></tr></tbody></table><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>重复地走访过要排序的元素列，依次比较两个相邻的元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来</p><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较</li></ol><h4 id="动图"><a href="#动图" class="headerlink" title="动图"></a>动图</h4><p><img src="/2023/03/07/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif" alt="冒泡排序"></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] bubbleSort(<span class="type">int</span>[] arr)&#123;</span><br><span class="line">    <span class="comment">//5个数的排序只需要进行4次大循环，所以循环总次数为 arr.length-1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//每次循环开始时已经进行了i次大循环，所以已经有了i个值是有序的，</span></span><br><span class="line">        <span class="comment">//在比较时取值为j和j+1进行比较，所以为了防止数组越界，还要再减去1，</span></span><br><span class="line">        <span class="comment">//最终进行arr.length-i-1次小循环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; arr.length-i-<span class="number">1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法</p><h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h4><ol><li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</li><li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li><li>重复第二步，直到所有元素均排序完毕。</li></ol><h4 id="动图-1"><a href="#动图-1" class="headerlink" title="动图"></a>动图</h4><p><img src="/2023/03/07/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif" alt="选择排序"></p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] selectionSort(<span class="type">int</span>[] arr)&#123;</span><br><span class="line">    <span class="comment">//5个数的排序只需要进行4次大循环，所以循环总次数为 arr.length-1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//最小值下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="comment">//第i次大循环从a[i]开始，与之进行比较的数从a[i+1]开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>;j &lt; arr.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[minIndex] &gt; arr[j])&#123;</span><br><span class="line">                <span class="comment">//记录最小值下标</span></span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当minIndex != i时，说明a[i] 不是最小值，进行位置交换</span></span><br><span class="line">        <span class="keyword">if</span>(minIndex != i)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> arr[minIndex];</span><br><span class="line">            arr[minIndex] = arr[i];</span><br><span class="line">            arr[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>插入算法把要排序的<a href="https://baike.baidu.com/item/%E6%95%B0%E7%BB%84/3794097">数组</a>分成两部分：第一部分包含了这个数组的所有元素，但将最后一个元素除外（让数组多一个空间才有插入的位置），而第二部分就只包含这一个元素（即待插入元素）。在第一部分排序完成后，再将这个最后元素插入到已排好序的第一部分中。</p><h4 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h4><ol><li>从第一个元素开始，该元素可以认为已经被排序</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li><li>将新元素插入到下一位置中</li><li>重复步骤2~5</li></ol><h4 id="动图-2"><a href="#动图-2" class="headerlink" title="动图"></a>动图</h4><p><img src="/2023/03/07/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif" alt="插入排序"></p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] insertionSort(<span class="type">int</span>[] arr)&#123;</span><br><span class="line">    <span class="comment">//对数组进行拷贝，不改变原数组内容</span></span><br><span class="line">    <span class="type">int</span>[] newArr = Arrays.copyOf(arr,arr.length);</span><br><span class="line">    <span class="comment">//下标为0时只有一个元素，默认有序，所以从下标为1开始</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; newArr.length;i++)&#123;</span><br><span class="line">        <span class="comment">//记录要插入的数据</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> newArr[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="comment">//此时newAee[j] 之前的数已经有序，newArr[j] 为待插入的数</span></span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; newArr[j - <span class="number">1</span>] &gt; temp)&#123;</span><br><span class="line">            <span class="comment">//向后挪一格</span></span><br><span class="line">            newArr[j] = newArr[j - <span class="number">1</span>];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j != i)&#123;</span><br><span class="line">            newArr[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h4 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h4><p>在数组中随机选一个数（默认数组首个元素），数组中小于等于此数的放在左边，大于此数的放在右边，再对数组两边递归调用快速排序，重复这个过程。</p><h4 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤"></a>步骤</h4><ol><li>先从数列中取出一个数作为key值；</li><li>将比这个数小的数全部放在它的左边，大于或等于它的数全部放在它的右边；</li><li>对左右两个小数列重复第二步，直至各区间只有1个数。</li></ol><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><h5 id="动图-3"><a href="#动图-3" class="headerlink" title="动图"></a>动图</h5><p><img src="/2023/03/07/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F1.gif" alt="快速排序"></p><h5 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] res = sort(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">1</span>&#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : res) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] sourceArr)&#123;</span><br><span class="line">        <span class="comment">//对数组进行拷贝，不改变参数内容</span></span><br><span class="line">        <span class="type">int</span>[] arr = Arrays.copyOf(sourceArr, sourceArr.length);</span><br><span class="line">        <span class="comment">//调用快排方法</span></span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//返回已排好序的数组</span></span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] quickSort(<span class="type">int</span>[] arr,<span class="type">int</span> left,<span class="type">int</span> right)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="comment">//获取基准值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> partition(arr, left,right);</span><br><span class="line">            <span class="comment">//对左边数组进行递归</span></span><br><span class="line">            quickSort(arr, left, mid - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//对右边数组进行递归</span></span><br><span class="line">            quickSort(arr, mid + <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回已排好序的数组</span></span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="comment">//设定基准值，默认为数组的第一项</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="comment">//指向基准值右边第一个比基准值大的数的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> p + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//从左到右开始遍历，遇到比基准值大的数就跳过，遇到比基准值小的数就与arr[index]交换位置</span></span><br><span class="line">        <span class="comment">//同时index向右移动，指向最新的一个比基准值大的数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index;i &lt;= right;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[p] &gt; arr[i])&#123;</span><br><span class="line">                swap(arr,index,i);</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历完成后基准值与index左边的数交换位置，此时基准值左边都是较小的数，右边都是较大的数</span></span><br><span class="line">        swap(arr, p, index-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//返回基准值</span></span><br><span class="line">        <span class="keyword">return</span> index - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr ,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="comment">//交换操作，arr[i] 和 arr[j]互换位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> arr[j];</span><br><span class="line">        arr[j] = arr[i];</span><br><span class="line">        arr[i] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><h5 id="动图-4"><a href="#动图-4" class="headerlink" title="动图"></a>动图</h5><p><img src="/2023/03/07/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F2.gif" alt="快速排序"></p><h5 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">19</span>,<span class="number">33</span>,<span class="number">68</span>,<span class="number">32</span>,<span class="number">92</span>,<span class="number">29</span>,<span class="number">91</span>,<span class="number">95</span>,<span class="number">45</span>&#125;;</span><br><span class="line">        quickSort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="comment">//选定最左边的值为基准值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="comment">//从基准值右边第一个数开始遍历</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> right;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; j)&#123;<span class="comment">//只剩一个元素，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="comment">//当arr[j] 比基准值arr[p]大的数，则j继续向前扫描</span></span><br><span class="line">            <span class="keyword">while</span>(arr[p] &lt;= arr[j] &amp;&amp; i &lt; j )&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当arr[i]比基准值arr[p]小的数，则i继续向后扫描</span></span><br><span class="line">            <span class="keyword">while</span>(arr[p] &gt;= arr[i] &amp;&amp; i &lt; j)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//此时arr[i]是左边第一个比基准值大的数，arr[j]是右边第一个比基准值小的数，进行互换</span></span><br><span class="line">            swap(arr, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//基准值与arr[i]进行交换，此时基准是左边都是较小的数，右边都是较大的数</span></span><br><span class="line">        swap(arr,i,p);</span><br><span class="line">        <span class="comment">//对左边进行递归</span></span><br><span class="line">        quickSort(arr,left,i-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//对右边进行递归</span></span><br><span class="line">        quickSort(arr,i+<span class="number">1</span>,right);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr ,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="comment">//交换操作，arr[i] 和 arr[j]互换位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> arr[j];</span><br><span class="line">        arr[j] = arr[i];</span><br><span class="line">        arr[i] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h4 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h4><p>​将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p><h4 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤"></a>步骤</h4><ol><li>把长度为n的输入序列分成两个长度为n&#x2F;2的子序列。</li><li>对这两个子序列分别采用归并排序。</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ol><h4 id="动图-5"><a href="#动图-5" class="headerlink" title="动图"></a>动图</h4><p><img src="/2023/03/07/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif" alt="归并排序"></p><h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] mergeSort(<span class="type">int</span>[] arr,<span class="type">int</span> left,<span class="type">int</span> right)&#123;</span><br><span class="line">    <span class="comment">//当数组中只剩一个数时，直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;arr[left]&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用二路归并，取中间值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right)/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//左有序数组</span></span><br><span class="line">    <span class="type">int</span>[] leftArr = mergeSort(arr, left, mid);</span><br><span class="line">    <span class="comment">//右有序数组</span></span><br><span class="line">    <span class="type">int</span>[] rightArr = mergeSort(arr,mid+<span class="number">1</span>,right);</span><br><span class="line">    <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//建立一个新数组，长度为两数组长度之和</span></span><br><span class="line">    <span class="type">int</span>[] newArr = <span class="keyword">new</span> <span class="title class_">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//两个数组分别从左向右遍历，值较小的填入newArr</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; leftArr.length &amp;&amp; j &lt; rightArr.length)&#123;</span><br><span class="line">        newArr[t++] = leftArr[i] &lt; rightArr[j] ? leftArr[i++] : rightArr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//填入leftArr剩余部分</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; leftArr.length )&#123;</span><br><span class="line">        newArr[t++] = leftArr[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//填入rightArr剩余部分</span></span><br><span class="line">    <span class="keyword">while</span>(j &lt; rightArr.length )&#123;</span><br><span class="line">        newArr[t++] = rightArr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回新有序数组</span></span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><h4 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h4><p>​希尔排序是插入排序改良的算法，希尔排序步长从大到小调整，第一次循环后面元素逐个和前面元素按间隔步长进行比较并交换，直至步长为1，步长选择是关键。</p><h4 id="步骤-5"><a href="#步骤-5" class="headerlink" title="步骤"></a>步骤</h4><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><ol><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk&#x3D;1；</li><li>按增量序列个数k，对序列进行k 趟排序；</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ol><h4 id="动图-6"><a href="#动图-6" class="headerlink" title="动图"></a>动图</h4><p><img src="/2023/03/07/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.gif" alt="希尔排序"></p><h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><h5 id="四重循环版本"><a href="#四重循环版本" class="headerlink" title="四重循环版本"></a>四重循环版本</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] a)</span>&#123;       </span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> a.length;<span class="comment">//单独把数组长度拿出来，提高效率。</span></span><br><span class="line">    <span class="keyword">while</span>(len != <span class="number">0</span>) &#123;</span><br><span class="line">        len = len/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;<span class="comment">//分组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; a.length; j+=len) &#123;<span class="comment">//元素从第二个开始</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> j - len;<span class="comment">//k为有序序列最后一位的位数</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[j];<span class="comment">//要插入的元素</span></span><br><span class="line">                <span class="keyword">while</span> (k &gt;= <span class="number">0</span> &amp;&amp; temp &lt; a[k]) &#123;<span class="comment">//从后往前遍历</span></span><br><span class="line">                    a[k + len] = a[k];</span><br><span class="line">                    k -= len;<span class="comment">//向后移动len位</span></span><br><span class="line">                &#125;</span><br><span class="line">                a[k + len] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三重循环版本</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> length / <span class="number">2</span>; step &gt;= <span class="number">1</span>; step /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> step; i &lt; length; i++) &#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - step;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp) &#123;</span><br><span class="line">                arr[j + step] = arr[j];</span><br><span class="line">                j -= step;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j + step] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><h4 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a>简介</h4><p>​基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p><h4 id="步骤-6"><a href="#步骤-6" class="headerlink" title="步骤"></a>步骤</h4><ol><li>取得数组中的最大数，并取得位数；</li><li>arr为原始数组，从最低位开始取每个位组成radix数组；</li><li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li></ol><h4 id="动图-7"><a href="#动图-7" class="headerlink" title="动图"></a>动图</h4><p><img src="/2023/03/07/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.gif" alt="基数排序"></p><h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基数排序</span></span><br><span class="line"><span class="comment"> * 考虑负数的情况还可以参考： https://code.i-harness.com/zh-CN/q/e98fa9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RadixSort</span> <span class="keyword">implements</span> <span class="title class_">IArraySort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] sourceArray) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 对 arr 进行拷贝，不改变参数内容</span></span><br><span class="line">        <span class="type">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxDigit</span> <span class="operator">=</span> getMaxDigit(arr);</span><br><span class="line">        <span class="keyword">return</span> radixSort(arr, maxDigit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取最高位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getMaxDigit</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> getMaxValue(arr);</span><br><span class="line">        <span class="keyword">return</span> getNumLenght(maxValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getMaxValue</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxValue &lt; value) &#123;</span><br><span class="line">                maxValue = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">getNumLenght</span><span class="params">(<span class="type">long</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lenght</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">temp</span> <span class="operator">=</span> num; temp != <span class="number">0</span>; temp /= <span class="number">10</span>) &#123;</span><br><span class="line">            lenght++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lenght;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] radixSort(<span class="type">int</span>[] arr, <span class="type">int</span> maxDigit) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">dev</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; maxDigit; i++, dev *= <span class="number">10</span>, mod *= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="comment">// 考虑负数的情况，这里扩展一倍队列数，其中 [0-9]对应负数，[10-19]对应正数 (bucket + 10)</span></span><br><span class="line">            <span class="type">int</span>[][] counter = <span class="keyword">new</span> <span class="title class_">int</span>[mod * <span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">bucket</span> <span class="operator">=</span> ((arr[j] % mod) / dev) + mod;</span><br><span class="line">                counter[bucket] = arrayAppend(counter[bucket], arr[j]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>[] bucket : counter) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> value : bucket) &#123;</span><br><span class="line">                    arr[pos++] = value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自动扩容，并保存数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arrayAppend(<span class="type">int</span>[] arr, <span class="type">int</span> value) &#123;</span><br><span class="line">        arr = Arrays.copyOf(arr, arr.length + <span class="number">1</span>);</span><br><span class="line">        arr[arr.length - <span class="number">1</span>] = value;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><h4 id="简介-7"><a href="#简介-7" class="headerlink" title="简介"></a>简介</h4><p>​堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><h4 id="步骤-7"><a href="#步骤-7" class="headerlink" title="步骤"></a>步骤</h4><ol><li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;&#x3D;R[n]；</li><li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li></ol><h4 id="动图-8"><a href="#动图-8" class="headerlink" title="动图"></a>动图</h4><p><img src="/2023/03/07/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%A0%86%E6%8E%92%E5%BA%8F.gif" alt="堆排序"></p><h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSort</span> <span class="keyword">implements</span> <span class="title class_">IArraySort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] sourceArray) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 对 arr 进行拷贝，不改变参数内容</span></span><br><span class="line">        <span class="type">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line"></span><br><span class="line">        buildMaxHeap(arr, len);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            swap(arr, <span class="number">0</span>, i);</span><br><span class="line">            len--;</span><br><span class="line">            heapify(arr, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildMaxHeap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (<span class="type">int</span>) Math.floor(len / <span class="number">2</span>); i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            heapify(arr, i, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">largest</span> <span class="operator">=</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">            largest = left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">            largest = right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">            swap(arr, i, largest);</span><br><span class="line">            heapify(arr, largest, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术连连看 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 排序 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面试</title>
      <link href="/2023/03/07/Java%E9%9D%A2%E8%AF%95/"/>
      <url>/2023/03/07/Java%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="java面试题笔记"><a href="#java面试题笔记" class="headerlink" title="java面试题笔记"></a>java面试题笔记</h1><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>面向对象相对于面向过程，更加注重事件有哪些参与者，各自需要做些什么。更加的易于复用，拓展和维护。</p><p><strong>封装：</strong>封装的意义在于明确标示出外部使用的所有成员函数和数据项，内部细节全部对外透明，外部调用无需修改或者关心内部实现</p><p><strong>继承：</strong>继承基类的方法，做出自己的改变或拓展。</p><p><strong>多态：</strong>基于对象所属类的不同，外部对象对同一方法的调用，实际执行的逻辑不同。</p><h2 id="JDK、JRE、JVM-三者的区别和联系"><a href="#JDK、JRE、JVM-三者的区别和联系" class="headerlink" title="JDK、JRE、JVM 三者的区别和联系"></a>JDK、JRE、JVM 三者的区别和联系</h2><p><strong>JDK：</strong> java Development Kit java开发工具</p><p><strong>JRE：</strong>Java Runtime Environment java运行时环境</p><p><strong>JVM：</strong>java Virtual Machine java虚拟机</p><p><img src="/2023/03/07/Java%E9%9D%A2%E8%AF%95/627a2e5609475431295bae3a-16781581775101.jpg" alt="image-20220510170809934"></p><p>JDK–(include)–&gt;JRE–(include)–&gt;JVM</p><h2 id="x3D-x3D-和-equals"><a href="#x3D-x3D-和-equals" class="headerlink" title="&#x3D;&#x3D; 和 equals"></a>&#x3D;&#x3D; 和 equals</h2><p><strong>&#x3D;&#x3D; ：</strong>对比的是栈中的值，基本数据类型是变量值，引用数据类型是堆中内存对象的地址。</p><p><strong>equals：</strong>object中默认采用 <code>==</code> 比较，通常会重写（String重写了equals()方法）。</p><h2 id="finall"><a href="#finall" class="headerlink" title="finall"></a>finall</h2><p><strong>最终的</strong></p><ul><li>修饰类：表示方法不可被继承</li><li>修饰方法：表示方法不可被子类覆盖，但可以重载</li><li>修饰变量：表示变量一旦赋值不可改变它的值（修饰成员变量一定要赋初始值，修饰局部变量可以不赋初始值，但在使用前一定要赋值）</li></ul><p><strong>为什么局部内部类中和匿名内部类中只能访问局部final变量</strong></p><p>内部类中为了防止局部变量被回收导致异常，采用将局部变量复制一份的方法保存在自己的类中，为了保证内部类中成员变量和方法的成员变量保持一致，所以使用final关键字。</p><h2 id="String、StringBuffer、StringBuilder的区别及使用场景"><a href="#String、StringBuffer、StringBuilder的区别及使用场景" class="headerlink" title="String、StringBuffer、StringBuilder的区别及使用场景"></a>String、StringBuffer、StringBuilder的区别及使用场景</h2><p>String是final修饰的，不可变，每次操作都会生成新的String对象</p><p>StringBuffer和StringBuilder都是在原对象上操作的</p><p>StringBuffer是线程安全的，StringBuilder是线程不安全的</p><p>StringBuffer和StringBuilder方法都是synchronized修饰的</p><p>性能：StringBuilder &gt; StringBuffer &gt; String</p><p>场景：经常用到字符串改变使用后边两个，多线程使用StringBuffer，追求效率使用StringBuilder</p><p><strong>重载：</strong>发生在同一个类中，方法名必须相同，参数类型不同，个数不同，顺序不同都叫重载，方法返回值不同，访问修饰符不同不叫重载，发生在编译时。</p><p><strong>重写：</strong>发生在父子类中，方法名，参数列表必须相同，返回值范围小于等于父类，异常抛出范围大于等于父类，访问修饰符范围大于等于父类；如果父类方法为private，则子类不能重写。</p><h2 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h2><ul><li>抽象类可以存在普通成员函数，接口只能存在public abstract方法</li><li>抽象类只能继承一个，接口可以继承多个</li><li>抽象类中成员变量可以是各种类型，接口中成员变量只能是public static final类型</li></ul><p>接口的目的是对类的行为进行约束，抽象类的目的是代码复用</p><p><strong>使用场景：</strong>当你关注一个事物的本质时使用抽象类，关注一个操作时，使用接口</p><h2 id="List和Set的区别"><a href="#List和Set的区别" class="headerlink" title="List和Set的区别"></a>List和Set的区别</h2><p><strong>List：</strong>有序可重复，顺序为对象进入的顺序，允许多个<code>null</code>元素出现，可以用迭代器（Iterator）取出所有对象，也可使用下标取出元素。</p><p><strong>Set：</strong>无序不可重复，只能有一个<code>null</code>，只能使用迭代器取出元素。</p><h2 id="hashCode-和-equals"><a href="#hashCode-和-equals" class="headerlink" title="hashCode 和 equals"></a>hashCode 和 equals</h2><p>hashCode()的作用是获取哈希码（散列码），返回一个整数，使用哈希码确定对象在哈希表中的位置。</p><p>hashSet来检查是否重复，就是先对比hashCode的值，不相等则不重复，相等就使用equal方法，这样就大大减少了equal的次数。</p><h2 id="ArrayList-和-LinkedList的区别"><a href="#ArrayList-和-LinkedList的区别" class="headerlink" title="ArrayList 和 LinkedList的区别"></a>ArrayList 和 LinkedList的区别</h2><p><strong>ArrayLIst：</strong>基于动态数组，连续内存存储，扩容时需要新建一个数组，将老数组的数据复制到新数组，扩容到原来的<strong>1.5</strong>倍。</p><p><strong>LinkedList：</strong>基于链表，可以存储在散列的内存中，不适合查询，适合插入与删除。只能使用迭代器遍历，不可使用for循环，因为for的每次get都需要重新遍历，性能消耗极大。</p><h2 id="HashMap-和-HashTable-的区别和底层实现"><a href="#HashMap-和-HashTable-的区别和底层实现" class="headerlink" title="HashMap 和 HashTable 的区别和底层实现"></a>HashMap 和 HashTable 的区别和底层实现</h2><p><strong>区别：</strong></p><p>HashMap是线程不安全的，HashTable是线程安全的</p><p>HashMap允许key和value为null，hashTable不允许</p><p><strong>底层实现（HashMap）：</strong></p><p>jdk8开始链表高度到8，数组长度超过64，链表转为红黑树（自平衡的二叉排序树），元素以内部Node节点存在。</p><p>数组扩容：默认容量为16，加载因子默认0.75，阈值&#x3D;容量*加载因子，默认12，当元素数量超过阈值时，扩容到原来的<strong>2</strong>倍。</p><h2 id="ConcurrentHashMap原理，在-jdk7和jdk8版本的区别"><a href="#ConcurrentHashMap原理，在-jdk7和jdk8版本的区别" class="headerlink" title="ConcurrentHashMap原理，在 jdk7和jdk8版本的区别"></a>ConcurrentHashMap原理，在 jdk7和jdk8版本的区别</h2><p>ConcurrentHashMap是线程安全的，使用分段锁，而HashTable是使用全局锁，所以前者效率要高。</p><h2 id="如何实现一个IOC容器"><a href="#如何实现一个IOC容器" class="headerlink" title="如何实现一个IOC容器"></a>如何实现一个IOC容器</h2><ol><li>配置文件配置包扫描路径</li><li>递归包扫描获取.class文件</li><li>反射、确定需要交给ioc管理的类</li><li>对需要注入的类进行依赖注入</li></ol><h2 id="什么是字节码，使用字节码的好处是什么"><a href="#什么是字节码，使用字节码的好处是什么" class="headerlink" title="什么是字节码，使用字节码的好处是什么"></a>什么是字节码，使用字节码的好处是什么</h2><p>java源程序经过编译器编译后变成字节码（.class文件），字节码由虚拟机解释运行，采用字节码可以实现一处编译，到处运行的效果。</p><p><strong>java源代码–&gt;编译器–&gt;jvm可执行的java字节码–&gt;jvm–&gt;jvm中的解释器–&gt;及其可执行的二进机器码–&gt;程序运行</strong></p><h2 id="java类加载器有哪些"><a href="#java类加载器有哪些" class="headerlink" title="java类加载器有哪些"></a>java类加载器有哪些</h2><p>jdk自带的三个类加载器：bootstrap ClassLoader、ExtClassLoader 、AppClassLoader</p><p>前者是后者的父类（并非继承关系，而是有一个变量控制的），继承ClassLoader实现自定义类加载器。</p><h2 id="双亲委派（委托）模型"><a href="#双亲委派（委托）模型" class="headerlink" title="双亲委派（委托）模型"></a>双亲委派（委托）模型</h2><p><img src="/2023/03/07/Java%E9%9D%A2%E8%AF%95/627b7ca0094754312999af06.jpg" alt="img"></p><p>向上委派查找缓存，向下查找加载路径。</p><p>好处：为了安全性，避免用户自己编写的类替换java核心类同时避免了类的重复加载。类名和类加载器确定一个类。</p><h2 id="java中的异常体系"><a href="#java中的异常体系" class="headerlink" title="java中的异常体系"></a>java中的异常体系</h2><p>java中异常都来自顶级父类Throwable</p><p>Throwable有两个子类Error和Exception</p><p>Error是程序无法处理的错误，一旦出现则程序终止运行</p><p>Exception不会导致程序停止，又分为RunTimeException和CheckedException</p><h2 id="GC如何判断对象可以被回收"><a href="#GC如何判断对象可以被回收" class="headerlink" title="GC如何判断对象可以被回收"></a>GC如何判断对象可以被回收</h2><ul><li>引用计数法：每一个对象有一个引用计数属性，新增一个引用时计数加一，释放一个引用时计数减一，当计数为零是回收。（效率十分高，但会出现相互引用的情况，此时永远无法回收）</li><li>可达性分析法：从GC Roots（根）开始向下搜索，可以被搜索到的不回收，不可以被搜索到的可回收。（不可达对象不会立即销毁，有一次自我拯救的机会）</li></ul><p>GC Roots对象有：</p><ul><li>虚拟机栈中引用的对象</li><li>方法去中类静态属性引用的对象</li><li>方法去中常量引用的对象</li><li>本地方法栈中引用的对象</li></ul><h2 id="线程的生命周期、线程的几种状态"><a href="#线程的生命周期、线程的几种状态" class="headerlink" title="线程的生命周期、线程的几种状态"></a>线程的生命周期、线程的几种状态</h2><p>线程一般有五种状态：创建，就绪，运行，阻塞，死亡</p><h2 id="sleep-、wait-、join-、yield-的区别"><a href="#sleep-、wait-、join-、yield-的区别" class="headerlink" title="sleep()、wait()、join()、yield()的区别"></a>sleep()、wait()、join()、yield()的区别</h2><p>sleep是Thread类的静态本地方法，wait是Object类的本地方法</p><p>sleep方法不会释放lock（锁），但是wait会释放，并加入等待队列中</p><p>sleep方法不依赖同步器synchronized，wait需要</p><p>sleep不需要被唤醒，wait需要（不指定时间时）</p><p>sleep一般用于当前线程休眠，或者轮询暂停操作，wait用于多线程通信</p><p>sleep会让出cpu并强制上下文切换，wait进入等待队列后被唤醒仍有机会重新竞争cpu</p><p>yiele执行后会进入就绪状态，释放cpu但保留执行资格</p><p>join执行后会进入阻塞状态</p><h2 id="对线程安全的理解"><a href="#对线程安全的理解" class="headerlink" title="对线程安全的理解"></a>对线程安全的理解</h2><p>线程安全实际上指的是内存安全，因为堆是共享的，可以被所有线程所访问，当多个线程访问一个对象时，如果不用进行额外的同步控制或其他协调操作，调用这个对象的行为都可以获得正确的结果，我们就说这个对象是线程安全的。</p><h2 id="Thread、Runable的区别"><a href="#Thread、Runable的区别" class="headerlink" title="Thread、Runable的区别"></a>Thread、Runable的区别</h2><p>Thread是一个类，Runable是一个接口</p><p>Thread实现了Runable</p><h2 id="对守护线程的理解"><a href="#对守护线程的理解" class="headerlink" title="对守护线程的理解"></a>对守护线程的理解</h2><p><strong>守护线程：</strong>为所有非守护线程提供服务的线程；用户线程就属于非守护线程。当所有非守护线程结束后，守护线程也会被中断。</p><p><strong>应用场景</strong></p><ul><li>为其他线程提供服务支持</li><li>在任何情况下，程序结束后，线程必须正常且立刻关闭，就可以使用守护线程。反之当一个正在执行某个操作的线程必须要正确关闭时则不可用守护线程，而应使用用户线程。</li></ul><h2 id="ThreadLocal的原理和使用场景"><a href="#ThreadLocal的原理和使用场景" class="headerlink" title="ThreadLocal的原理和使用场景"></a>ThreadLocal的原理和使用场景</h2><p>每一个Thread对象中均含有一个ThreadLocalMap类型的成员变量，threadlocals，它存储了本线程中所有的ThreadLocal对象及其对应的值</p><p>使用场景：</p><ol><li>在进行对象跨层传递的时候，使用ThreadLocal可以避免多次传递，打破层次间的约束。</li><li>线程间数据隔离</li><li>进行事务操作，用于存储线程事务信息</li><li>数据库连接，Session会话管理</li></ol><h2 id="ThreadL内存泄露的原因，如何避免"><a href="#ThreadL内存泄露的原因，如何避免" class="headerlink" title="ThreadL内存泄露的原因，如何避免"></a>ThreadL内存泄露的原因，如何避免</h2><p><strong>内存泄漏：</strong>不再会被使用的对象或变量无法被回收，一直占用内存</p><p>Threadl内存泄漏的根源是：由于ThreadLocalMap的生命周期和Thread一样长，如果没有手动删除，对应的key就会导致内存泄露，而不是因为弱引用。</p><p>ThreadLocal正确使用方法</p><ul><li>每次使用完Threadlocal都调用它的remove()方法清除数据</li><li>将ThreadLocal变量定义成private static ，这样就一直存在ThreadLocal的强引用，也能保证任何时候都能通过Threadlocal的弱引用访问到值，进而清除掉。</li></ul><h2 id="并发、并行、串行的区别"><a href="#并发、并行、串行的区别" class="headerlink" title="并发、并行、串行的区别"></a>并发、并行、串行的区别</h2><p><strong>串行</strong>在时间上不可能发生重叠前一个任务没有完成，后一个任务就不会执行</p><p><strong>并行</strong>在时间上是重叠的，两个任务在同一时刻互不干扰的同时执行</p><p><strong>并发</strong>允许两个任务彼此干扰，同一时间点只有一个任务运行，人物之间交替执行</p><h2 id="并发的三大特性"><a href="#并发的三大特性" class="headerlink" title="并发的三大特性"></a>并发的三大特性</h2><p><strong>原子性：</strong>原子性是指在一个操作中cpu不可以中途暂停然后再调度，即不可被中断操作，要么全部执行成功，要么都不执行。</p><p><strong>可见性：</strong>当多个线程访问同一变量时，一个线程修改了这个变量的值，其他线程能够立即看到修改的值。</p><p><strong>持续性：</strong>虚拟机在进行代码编译时，对于那些改变顺序之后不会对最终结果造成影响的代码，虚拟机可能将他们重排序，实际上，对于代码重排序后，虽然变量的值没有影响，但可能造成线程安全问题。</p><h2 id="为什么使用线程池、解释下线程池参数"><a href="#为什么使用线程池、解释下线程池参数" class="headerlink" title="为什么使用线程池、解释下线程池参数"></a>为什么使用线程池、解释下线程池参数</h2><ol><li>降低资源消耗</li><li>提高响应速度</li><li>提高线程的可管理性</li></ol><p><strong>参数：</strong></p><ul><li>corePoolSize：核心线程数；指正常工作时创建的线程数。属于常驻线程。</li><li>maxinumPoolSize：最大线程数；与核心线程想对应，指线程池中能够创建的最大线程数。</li><li>keepAliveTime、unit：表示除核心线程之外的线程的空闲存活时间，超出时间则会被消除。</li><li>workQueue：用来存放待执行的任务。</li><li>ThreadFactory：实际上是一个创建线程的线程工厂，用来生产线程执行任务。</li></ul><h2 id="简述线程池处理流程"><a href="#简述线程池处理流程" class="headerlink" title="简述线程池处理流程"></a>简述线程池处理流程</h2><p><img src="/2023/03/07/Java%E9%9D%A2%E8%AF%95/627c63f609475431299e05cc-16781582321103.jpg" alt="img"></p><p>当达到最大线程数时，根据拒绝策略来处理任务</p><h2 id="线程池中阻塞队列的作用是什么、为什么先添加队列而不是先创建最大线程"><a href="#线程池中阻塞队列的作用是什么、为什么先添加队列而不是先创建最大线程" class="headerlink" title="线程池中阻塞队列的作用是什么、为什么先添加队列而不是先创建最大线程"></a>线程池中阻塞队列的作用是什么、为什么先添加队列而不是先创建最大线程</h2><p>阻塞队列的作用：没搞懂。。。</p><p>先添加队列的原因：在创建新线程时，是要获取全局锁的，这个时候就要阻塞其他线程，影响效率。</p><h2 id="线程池中线程复用原理"><a href="#线程池中线程复用原理" class="headerlink" title="线程池中线程复用原理"></a>线程池中线程复用原理</h2><p>线程池将线程和任务解耦，拜托了之前创建一个线程必须对应一个任务的限制</p><p>在线程池中，一个线程可以不断从阻塞队列中获取新任务来执行，其原理就是线程池对Thread进行了封装，并不是每次执行任务都会调用start()方法来创建新县城，而是让每个线程执行一个循环任务，在这个循环任务中不停检查是否有任务要执行，有则调用run()方法直接执行。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start()是创建一个线程，run()是使用当前线程</span><br></pre></td></tr></table></figure><h2 id="Spring是什么"><a href="#Spring是什么" class="headerlink" title="Spring是什么"></a>Spring是什么</h2><p>spring是一个轻量级的开源的J2ee框架。它是一个容器框架，用来装javabean对象。</p><p>spring是一个轻量级的控制翻转（ioc）和面向切面（aop）的容器框架</p><ul><li>从大小和开销方面来说是轻量级的</li><li>通过ioc实现了解耦合的目的</li><li>提供了aop，允许通过分离应用的业务逻辑与系统级服务进行内聚性的开发</li><li>包含并管理应用对象的生命周期，这个意义上来说是个容器</li><li>将简单的组件配置、组合成为复杂的应用，这个意义上来说是一个框架</li></ul><h2 id="对AOP的理解"><a href="#对AOP的理解" class="headerlink" title="对AOP的理解"></a>对AOP的理解</h2><p>将程序中的交叉业务逻辑（比如安全，日志，事务等），封装成一个切面，然后注入到业务逻辑中，这样就可以再不改变源代码的前提下，对对象中的方法进行增强，在执行对象方法前后都可以额外做一些事。</p><h2 id="对IOC的理解"><a href="#对IOC的理解" class="headerlink" title="对IOC的理解"></a>对IOC的理解</h2><p>ioc容器实际上是一个存放bean的map，在项目启动时会读取配置文件，然后通过反射将bean对象创建好并放入map集合中。这样我们就可以通过依赖注入获取到这些对象。</p><p>使用ioc容器后，对象的创建就从一开始我们去new一个新对象变成了ioc帮我们去创建一个对象，创建对象从主动变成了被动。这就是控制反转。</p><h2 id="BeanFactory和ApplicationContext有什么区别"><a href="#BeanFactory和ApplicationContext有什么区别" class="headerlink" title="BeanFactory和ApplicationContext有什么区别"></a>BeanFactory和ApplicationContext有什么区别</h2><p>ApplicationContext是BeanFactory的子接口，ApplicationContext提供了更完整的功能：</p><ol><li>继承MessageSource，因此支持国际化</li><li>统一的资源文件访问方式</li><li>提供在监听器中注册bean的事件</li><li>同时加载多个配置文件</li><li>载入多个有继承关系的上下文，使得每一个上下文都专注于一个特定的层次</li></ol><p>BeanFactory采用了延迟加载形式注入bean，即只有在使用bean时才会进行加载实例化，而ApplicationContext在容器启动时一次性创建所有bean，可以才容器启动时就发现spirngboot中存在的配置错误，有利于检查依赖属性是否注入。同时确保使用时不需要等待，直接使用即可。相对于BeanFactory的不足就是内存占用大，程序启动慢。</p><p>BeanFactory通常以编程方式被创建，ApplicationContext还能以声明的方式被创建</p><p>BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，区别是前者需要手动注册，后者自动注册</p><h2 id="描述一下Spring-Bean的生命周期"><a href="#描述一下Spring-Bean的生命周期" class="headerlink" title="描述一下Spring Bean的生命周期"></a>描述一下Spring Bean的生命周期</h2><p>大体生命周期为 实例化–&gt;属性赋值–&gt;初始化–&gt;销毁</p><ol><li>实例化对象：通过反射的方式进行对象的创建</li><li>设置对象属性</li><li>检查Aware相关接口并设置相关依赖</li><li>BeanPostprocessor的前置处理</li><li>调用初始化方法</li><li>BeanPostProcessing后置处理</li><li>使用bean</li><li>调用DisposableBean中的destroy()方法</li></ol><h2 id="简述一下Spring支持的几种bean的作用于"><a href="#简述一下Spring支持的几种bean的作用于" class="headerlink" title="简述一下Spring支持的几种bean的作用于"></a>简述一下Spring支持的几种bean的作用于</h2><ul><li>singleton：单例，默认。每一个容器中只有一个bean的实例</li><li>prototype：多例，为每一个bean请求提供一个实例，每次注入时都会创建新的对象</li><li>request：在每一个HTTP请求中创建一个可复用的单例对象</li><li>session：确保每一个session中有一个可复用的单例对象</li><li>application：每一个ServletContext的生命周期中有一个可复用的单例对象</li><li>websocket：每一个websocket的生命周期中有一个可复用的单例对象</li><li>global-session：全局作用域</li></ul><h2 id="Spring框架中的单例Bean是线程安全的么"><a href="#Spring框架中的单例Bean是线程安全的么" class="headerlink" title="Spring框架中的单例Bean是线程安全的么"></a>Spring框架中的单例Bean是线程安全的么</h2><p>不是的</p><p>如果bean是有状态的（存储了数据），就需要开发人员来保证线程安全，最简单的方法就是改变bena的作用域，把singleton改成prototype，这样每次bean请求都会创建一个新对象，保证线程安全。</p><p>所以尽量不要在bena中声明任何有状态的实例变量或者类变量，如果必须这样做，则只能使用synchronized、lock、CAS等实现线程同步。</p><h2 id="Spring框架中都用到了哪些设计模式"><a href="#Spring框架中都用到了哪些设计模式" class="headerlink" title="Spring框架中都用到了哪些设计模式"></a>Spring框架中都用到了哪些设计模式</h2><p>单例模式、工厂模式、适配器模式、动态代理、装饰器模式、观察者模式、策略模式</p><h2 id="Spring事务的实现方式和原理以及隔离级别"><a href="#Spring事务的实现方式和原理以及隔离级别" class="headerlink" title="Spring事务的实现方式和原理以及隔离级别"></a>Spring事务的实现方式和原理以及隔离级别</h2><p>两种使用事务的方式：一种是编程式，一种是声明式，@Transactional就是生命式的</p><p>在方法上加入@Transactional注解后，Spring会基于这个类生成代理对象，在使用这个方法时，代理逻辑会吧事务中的自动提交设置为false，再去执行业务逻辑代码，如果业务逻辑出现异常，则回滚，没有则提交。</p><p>隔离级别：</p><ul><li>read uncommitted(未提交读、脏读) 读取到未提交的内容</li><li>read committed(提交读，不可重复读)<ul><li><strong>A：</strong>启动事务，此时数据为初始状态</li><li><strong>B：</strong>启动事务，更新数据，但不提交</li><li><strong>A：</strong>再次读数据，发现数据未被修改</li><li><strong>B：</strong>提交事务</li><li><strong>A：</strong>再次读取数据，发现数据已发生变化，说明B提交的修改被事务中的A读到了，这就是所谓的“不可重复读”</li></ul></li><li>repeatable read (可重复读、幻读) 当用户读取某一范围的数据时，其他事务有插入了新行，当用户再次读取时发现有新的“幻”影行。<ul><li><strong>A：</strong>启动事务，此时数据为初始状态</li><li><strong>B：启动事务，更新数据，但不提交</strong></li><li><strong>A：</strong>再次读取数据，发现数据未被修改</li><li><strong>B：</strong>提交事务</li><li><strong>A：</strong>再次读取数据，发现数据依然未发生变化，这说明这次可以重复读了</li><li><strong>B：</strong>插入一条新的数据，并提交</li><li><strong>A：</strong>再次读取数据，发现数据依然未发生变化，虽然可以重复读了，但是却发现读的不是最新数据，这就是所谓的“幻读”</li><li><strong>A：</strong>提交本次事务，再次读取数据，发现读取正常了</li></ul></li><li>serializable(可串行化)</li></ul><p>不可重复读和幻读的区别：前者的重点是修改，后者的重点是增加或删除，两者都是在一个事物过程中，两次读取读到了不同的值。</p><h2 id="spirng事物的传播机制"><a href="#spirng事物的传播机制" class="headerlink" title="spirng事物的传播机制"></a>spirng事物的传播机制</h2><p><strong>REQUIRED（默认）：</strong>如果当前有事务，则加入，没有则自己创建</p><p><strong>SUPPORTS：</strong>如果当前有事务就加入，没有就不以事物运行</p><p><strong>MANDATORY：</strong>如果当前有事务就加入，没有抛出异常</p><p><strong>REQUIRES_NEW：</strong>创建一个新事务，如果存在当前事务，则挂起该事务（a调用b，如果a有事务，则b将a的事务挂起，自己创建一个新事务运行，简单来说就是各跑各的事务）</p><p><strong>NOT_SUPPORTED：</strong>以非事务的方式运行，如果当前存在事务，则挂起该事务</p><p><strong>NEVER：</strong>不使用事务，如果有事务，则抛异常</p><p><strong>NESTED：</strong>如果当前事务存在，则在嵌套事务中执行，否则开启一个新事务（嵌套事务中父事务回滚，子事务回滚，子事务回滚，父事务不一定）</p><h2 id="spring事务什么时候失效"><a href="#spring事务什么时候失效" class="headerlink" title="spring事务什么时候失效"></a>spring事务什么时候失效</h2><p>spring事务的原理就是AOP，失效的原因就是AOP不起作用</p><ol><li>发生自调用。自调用时调用对象是UserService对象本身，而不是代理类</li><li>方法不是public。@Transactional注解只能用在public方法上</li><li>数据库不支持事务</li><li>bean对象没有被spring管理</li><li>异常没有抛出或者跑出的异常没有被定义</li></ol><h2 id="什么是bean的自动装配，有哪些方式"><a href="#什么是bean的自动装配，有哪些方式" class="headerlink" title="什么是bean的自动装配，有哪些方式"></a>什么是bean的自动装配，有哪些方式</h2><p>开启自动装配，只需要在xml配置文件中定义autowire属性</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;customer&quot; class=&quot;com.XXX.XXX.Customer&quot; autowire=&quot;&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>autowire属性有五种装配方式</p><ul><li>no -缺省情况下，默认使用ref属性手动设定</li><li>byName -根据属性名称自动装配</li><li>byType -根据属性类型自动装配</li><li>constructor -类似于byType，不过应用于构造器参数，如果一个bean与构造器参数的类型相同，则自动装配</li><li>autodetect -如果有默认构造器，则通过constructor自动装配，否则使用byType</li></ul><p>@Autowired默认使用byType；@Resource默认使用byName</p><h2 id="Spring-Boot-、Spring、Spring-MVC有什么区别"><a href="#Spring-Boot-、Spring、Spring-MVC有什么区别" class="headerlink" title="Spring Boot 、Spring、Spring MVC有什么区别"></a>Spring Boot 、Spring、Spring MVC有什么区别</h2><p>Spring是一个ioc容器用来管理bean，使用依赖注入实现控制反转，提供了aop机制来解决oop的代码重复的问题。</p><p>springmvc是spring对web框架的一个解决方案，提供了一个总的前端控制器servlet用来接收请求，定义了一系列路由策略及适配执行的handle，将结果生成视图返回给前端。</p><p>spring boot是spring提供的一个快速开发的工具包，让程序员更快速方便的开发spring+springmvc的应用，简化了配置，整合了一系列的解决方案（start机制）比如redis，mongodb等，开箱即用</p><h2 id="Spring-MVC的工作流程"><a href="#Spring-MVC的工作流程" class="headerlink" title="Spring MVC的工作流程"></a>Spring MVC的工作流程</h2><ol><li>用户发送请求到前端控制器DispatcherServlet</li><li>DispatcherServlet收到请求后调用HandlerMapping处理器映射器</li><li>处理器映射器找到具体的处理器，生成处理器及处理器拦截器一并返回给DispatcherServlet</li><li>DispatcherServlet调用HandlerAdapter处理器适配器</li><li>HandlerAdapter经过适配调用具体的处理器Controller</li><li>controller执行完成后返回ModelAndView</li><li>HandlerAdapter将controller执行的结果ModelAndView返回给DIspatcherServlet</li><li>DIspatcherServlet将ModelAndView传给ViewReslover视图解析器</li><li>ViewReslover解析后返回具体VIew</li><li>DispatcherServlet根据View进行渲染视图</li><li>DIspatcherServlet响应客户</li></ol><h2 id="Spring-MVC的主要组件"><a href="#Spring-MVC的主要组件" class="headerlink" title="Spring MVC的主要组件"></a>Spring MVC的主要组件</h2><ol><li>HandlerMapping：处理器映射器。根据用户请求的资源url查找handler</li><li>HandlerAdapter：适配器。让servlet能够调用handler来进行处理</li><li>HandlerExceptionResolver：异常处理器</li><li>ViewResolver：视图解析器</li><li>RequestToViewNameTranslator：</li><li>LocaleResolver</li><li>ThemeResolver：用于解析主题</li><li>MultipartResolver：用于处理上传请求</li><li>FlashMapManager：用来管理FlashMap的</li></ol><h2 id="Spring-Boot自动配置原理"><a href="#Spring-Boot自动配置原理" class="headerlink" title="Spring Boot自动配置原理"></a>Spring Boot自动配置原理</h2><p>搞不懂。。。</p><h2 id="如何理解Spring-Boot中的starter"><a href="#如何理解Spring-Boot中的starter" class="headerlink" title="如何理解Spring Boot中的starter"></a>如何理解Spring Boot中的starter</h2><p>starter就是定义一个sterter的jar包，写一个@configuration配置类，将这些bean定义到里面，然后在starter的META-INF&#x2F;spring.factories中写入该配置类，spirngboot就会按照约定加载该配置类</p><p>开发人员只需要引入starter包，就直接可以进行代码开发。</p><h2 id="什么是嵌入式服务器、为什么要使用嵌入式服务器"><a href="#什么是嵌入式服务器、为什么要使用嵌入式服务器" class="headerlink" title="什么是嵌入式服务器、为什么要使用嵌入式服务器"></a>什么是嵌入式服务器、为什么要使用嵌入式服务器</h2><p>普通的spring springmvc应用要使用tomcat外部服务器，而springboot将tomcat打成jar包，直接在jvm上运行即可，这就是嵌入式服务器</p><p>节省了下载安装tomcat，应用也不需要再打war包，放到webapp目录下运行了，只需安装jvm就可以直接运行</p><p>springboot已经内置了tomcat.jar，运行main方法就会启动tomcat，然后加载mvc</p><h2 id="mybatis的优缺点"><a href="#mybatis的优缺点" class="headerlink" title="mybatis的优缺点"></a>mybatis的优缺点</h2><p>优点</p><ol><li>基于sql语句编程，相当灵活，不会对应用程序或者数据库现有的设计造成影响，sql写在xml文件中，解除sql与程序代码的耦合，支持编写动态sql语句，可复用。</li><li>可以很好的和各种数据库兼容</li><li>能够与spring很好地集成</li></ol><p>缺点</p><ol><li>sql语句编写的工作量巨大</li><li>sql语句依赖于数据库，导致数据库移植性差，不能随意更换数据库</li></ol><h2 id="和-的区别"><a href="#和-的区别" class="headerlink" title="#{}和${}的区别"></a>#{}和${}的区别</h2><p>#{}是预编译处理、是占位符，${}是字符串替换，是拼接符。</p><p>#{}在变量替换后，会加上单引号，${}不会</p><p>#{}可以有效地防止sql注入</p><h2 id="索引的基本原理"><a href="#索引的基本原理" class="headerlink" title="索引的基本原理"></a>索引的基本原理</h2><p>索引用来快速寻找那些具有特定值的记录，没有索引一般执行查询时会遍历整张表</p><p>索引的原理：就是把无序的数据变成有序的数据</p><ol><li>把创建了索引的列的内容进行排序</li><li>堆排序结果生成倒排表</li><li>在倒排表内容上拼上数据地址链</li><li>在查询时，先拿到倒排表内容，再取出地址链，在拿到具体数据</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">倒排表：使用内容去查找id    正排表：使用id去查找内容</span><br></pre></td></tr></table></figure><h2 id="mysql索引的数据结构、各自优劣"><a href="#mysql索引的数据结构、各自优劣" class="headerlink" title="mysql索引的数据结构、各自优劣"></a>mysql索引的数据结构、各自优劣</h2><p>索引的数据结构和具体的存储引擎的实现有关，mysql中有hash索引，B+树索引等，InnoDB默认为B+树，对于哈希索引来说，底层的数据结构就是哈希表，因此绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询速度最快，其余大部分情况，可以选择BTree索引。</p><p><strong>B+树</strong></p><p>B+树是一个平衡的多叉树，从根节点到每一个叶子节点的高度差值不超过1，根节点通过双向指针链接，效率非常高，与B树不同的是，B+树的内部节点不保存数据，只是起到索引的作用，只有叶子节点保存数据</p><p><strong>哈希索引</strong></p><p>哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，只需一次哈希算法，就能够找到数据的位置，速度十分快。</p><h2 id="索引设计的原则"><a href="#索引设计的原则" class="headerlink" title="索引设计的原则"></a>索引设计的原则</h2><ol><li>适合索引的列是出现在where子句中的列，或者链接子句中指定的列</li><li>基数较小的表，索引效果较差，没有必要在此列建立索引</li><li>使用短索引。</li><li>不要过度索引。</li><li>定义有外间的数据列一定要建立索引</li><li>更新频繁的字段不适合建立索引</li><li>若是不能有效区分数据的列不适合做索引，比如性别，只有男女，区分度很低</li><li>尽量的拓展索引，不要建立新索引。</li><li>对于那些查询中很少涉及的列，重复比较多的咧不适合做索引</li><li>对于定义为text、image和bit数据类型的列不要建立索引</li></ol><h2 id="mysql锁的类型有哪些"><a href="#mysql锁的类型有哪些" class="headerlink" title="mysql锁的类型有哪些"></a>mysql锁的类型有哪些</h2><p>基于锁的属性分类：共享锁，排它锁</p><p>基于锁的粒度分类：行级锁、表级索、页级索、记录锁、间隙锁、临建锁</p><p>基于锁的状态分类：意向共享锁、意向排它锁</p><h2 id="事务的基本特性和隔离级别"><a href="#事务的基本特性和隔离级别" class="headerlink" title="事务的基本特性和隔离级别"></a>事务的基本特性和隔离级别</h2><p><strong>ACID</strong></p><p><strong>原子性</strong>指的是一个事务中的操作要么全部成功，要么全部失败</p><p><strong>一致性</strong>指的是数据库总是从一个一致性状态转换到另一个一致性状态，例如转账中转入账户和转出账户的金额总数不变</p><p><strong>隔离性</strong>指的是一个事务的修改在提交前，对其他事务是不可见的</p><p><strong>持久性</strong>指的是一旦事务提交，所做的修改会永久保存在数据库中</p><p><strong>隔离级别：</strong></p><ul><li>read uncommitted(未提交读、脏读) 读取到未提交的内容</li><li>read committed(提交读，不可重复读)<ul><li><strong>A：</strong>启动事务，此时数据为初始状态</li><li><strong>B：</strong>启动事务，更新数据，但不提交</li><li><strong>A：</strong>再次读数据，发现数据未被修改</li><li><strong>B：</strong>提交事务</li><li><strong>A：</strong>再次读取数据，发现数据已发生变化，说明B提交的修改被事务中的A读到了，这就是所谓的“不可重复读”</li></ul></li><li>repeatable read (可重复读、幻读) 当用户读取某一范围的数据时，其他事务有插入了新行，当用户再次读取时发现有新的“幻”影行。<ul><li><strong>A：</strong>启动事务，此时数据为初始状态</li><li><strong>B：启动事务，更新数据，但不提交</strong></li><li><strong>A：</strong>再次读取数据，发现数据未被修改</li><li><strong>B：</strong>提交事务</li><li><strong>A：</strong>再次读取数据，发现数据依然未发生变化，这说明这次可以重复读了</li><li><strong>B：</strong>插入一条新的数据，并提交</li><li><strong>A：</strong>再次读取数据，发现数据依然未发生变化，虽然可以重复读了，但是却发现读的不是最新数据，这就是所谓的“幻读”</li><li><strong>A：</strong>提交本次事务，再次读取数据，发现读取正常了</li></ul></li><li>serializable(可串行化)</li></ul><h2 id="关心过业务系统里面的sql耗时么，统计过慢查询么，怎么优化慢查询"><a href="#关心过业务系统里面的sql耗时么，统计过慢查询么，怎么优化慢查询" class="headerlink" title="关心过业务系统里面的sql耗时么，统计过慢查询么，怎么优化慢查询"></a>关心过业务系统里面的sql耗时么，统计过慢查询么，怎么优化慢查询</h2><p>慢查询的优化首先要搞明白慢的原因是什么，是索引命中率不高？是加载了不需要的数据列？是数据量太大？</p><ul><li>首先分析语句，看看是否是加载了多余的数据列，对语句进行分析以及重写</li><li>分析语句的执行计划，获取其使用的索引情况，之后修改语句或者修改索引，使得语句尽可能的命中</li><li>如果因为数据量太大，可以进行横向或纵向的分表</li></ul><h2 id="ACID靠什么保证"><a href="#ACID靠什么保证" class="headerlink" title="ACID靠什么保证"></a>ACID靠什么保证</h2><p>A 原子性由undo log日志保证，他记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql</p><p>C 一致性由其他三大特性保证，程序代码要保证业务上的一致性</p><p>I 隔离性是由MVCC来保证</p><p>D持久性是由内存+redo log来保证，mysql修改数据同时在内存和redo log记录这次操作，宕机时可以从redo log恢复</p><h2 id="什么是MVCC"><a href="#什么是MVCC" class="headerlink" title="什么是MVCC"></a>什么是MVCC</h2><p>MVCC多版本并发控制：<br>读取数据时通过一种类似快照的方式将数据保存下来，这样读锁就和写锁不冲突了，不同的事务session会看到自己特定版本的数据，版本链</p><p>mvcc只在READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作，其他两个不兼容</p><h2 id="mysql主从同步原理"><a href="#mysql主从同步原理" class="headerlink" title="mysql主从同步原理"></a>mysql主从同步原理</h2><p>mysql的主从复制主要由三个线程：master（binlog dump thread）、slave（IO thread，sql thread），master一条线程和slave中的两条线程。</p><ul><li>主节点binlog，主从复制的基础是主数据库的所有变更记录到binlog中，binlog是数据库启动时就保存所有修改数据库结构或内容的一个文件</li><li>主节点log dump线程，当binlog文件发生修改时，log dump线程读取其内容并发送到各个从节点</li><li>从节点io线程接受binlog内容，将其写入relay log文件中</li><li>从节点的sql线程读取relay log文件内容对数据库进行重放，最终保证数据一致性</li></ul><p>由于mysql默认的复制方式是异步的，主节点将日志交给从节点后就不管了，如果此时从数据库写入失败，主数据库挂了，日志就丢失了，由此产生了两个概念：</p><p><strong>全同步复制</strong></p><p>主库写入日志后，会强制同步到从库，当所有从库全部写入成功后，才能返回客户端，显然这种方法效率会受到严重影响</p><p><strong>半同步复制</strong></p><p>与全同步不同，半同步只需要一个库成功返回，主库就认为写操作完成</p><h2 id="简述mysql中索引类型对数据库性能的影响"><a href="#简述mysql中索引类型对数据库性能的影响" class="headerlink" title="简述mysql中索引类型对数据库性能的影响"></a>简述mysql中索引类型对数据库性能的影响</h2><p>普通索引：允许被索引的数据列包含重复的值</p><p>唯一索引：可以保证数据记录的唯一性</p><p>主键：是一种特殊的唯一索引，在一张表中只能有一个主键索引，用于唯一标识一条记录</p><p>联合索引：索引可以覆盖多个数据列</p><p>全文索引：通过建立倒排索引，可以极大地提升检索效率，解决判断字段是否包含的问题</p><p>使用索引可以极大地提高数据的查询速度，但是会降低插入、删除、更新表的速度，因为在执行这些操作时，还要额外的去维护索引表，并且索引需要占物理空间。</p><h2 id="Redis过期键的删除策略"><a href="#Redis过期键的删除策略" class="headerlink" title="Redis过期键的删除策略"></a>Redis过期键的删除策略</h2><ul><li>定时删除<ul><li>含义：在设置key的过期时间的同时，为该key创建一个定时器，让定时器在key的过期时间来临时，对key进行删除</li><li>优点：保证内存被尽快释放</li><li>缺点：<ul><li>若过期key很多，删除这些key会占用很多的CPU时间，在CPU时间紧张的情况下，CPU不能把所有的时间用来做要紧的事儿，还需要去花时间删除这些key</li><li>定时器的创建耗时，若为每一个设置过期时间的key创建一个定时器（将会有大量的定时器产生），性能影响严重</li><li>没人用</li></ul></li></ul></li><li>惰性删除<ul><li>含义：key过期的时候不删除，每次从数据库获取key的时候去检查是否过期，若过期，则删除，返回null。</li><li>优点：删除操作只发生在从数据库取出key的时候发生，而且只删除当前key，所以对CPU时间的占用是比较少的，而且此时的删除是已经到了非做不可的地步（如果此时还不删除的话，我们就会获取到了已经过期的key了）</li><li>缺点：若大量的key在超出超时时间后，很久一段时间内，都没有被获取过，那么可能发生内存泄露（无用的垃圾占用了大量的内存）</li></ul></li><li>定期删除<ul><li>含义：每隔一段时间执行一次删除(在redis.conf配置文件设置hz，1s刷新的频率)过期key操作</li><li>优点：<ul><li>通过限制删除操作的时长和频率，来减少删除操作对CPU时间的占用–处理”定时删除”的缺点</li><li>定期删除过期key–处理”惰性删除”的缺点</li></ul></li><li>缺点<ul><li>在内存友好方面，不如”定时删除”</li><li>在CPU时间友好方面，不如”惰性删除”</li></ul></li><li>难点<ul><li>合理设置删除操作的执行时长（每次删除执行多长时间）和执行频率（每隔多长时间做一次删除）（这个要根据服务器运行情况来定了）</li></ul></li></ul></li></ul><h2 id="Redis线程模型，单线程为什么快"><a href="#Redis线程模型，单线程为什么快" class="headerlink" title="Redis线程模型，单线程为什么快"></a>Redis线程模型，单线程为什么快</h2><p>redis是单线程模型，采用io多路复用机制</p><p>单线程快的原因：</p><ol><li>纯内存操作</li><li>核心是基于非阻塞的io多路复用机制</li><li>单线程避免了多线程中频繁上下文切换带来得性能问题</li></ol><h2 id="缓存雪崩、缓存穿透、缓存击穿"><a href="#缓存雪崩、缓存穿透、缓存击穿" class="headerlink" title="缓存雪崩、缓存穿透、缓存击穿"></a>缓存雪崩、缓存穿透、缓存击穿</h2><p>缓存雪崩是指缓存同一时间大面积失效，所有请求都直接访问数据库，造成数据库短时间内大量承受访问请求而崩掉</p><p>解决方案：</p><ul><li>缓存数据的过期时间设置为随机，防止同一时间大量数据过期</li><li>给每一个数据加上一个相应的缓存标记，记录是否失效，若失效则更新缓存</li><li>缓存预热</li><li>互斥锁</li></ul><p>缓存穿透是指缓存和数据库中都没有数据，导致所有请求落在数据库中，导致数据库崩掉</p><p>解决方案：</p><ul><li>接口层增加校验，如用户权限校验，id做基础校验</li><li>从缓存娶不到的数据，在数据库中也没有取到，这是将对应的key-value设置为key-null，将缓存时间缩短，如30秒，这样可以防止攻击用户反复使用同一个id暴力攻击</li><li>采用布隆过滤器</li></ul><p>缓存击穿是指缓存中没有但是数据库中有的数据，一般是缓存时间到期。这时并发用户特别多时， 大量用户去访问数据库导致数据库崩掉。与缓存雪崩不同，缓存击穿一般指并发的查找同一条热点数据，雪崩是由于大量缓存过期导致。</p><p>解决方案：</p><ul><li>设置热点数据永不过期</li><li>加互斥锁</li></ul><h2 id="CAP理论，BASE理论"><a href="#CAP理论，BASE理论" class="headerlink" title="CAP理论，BASE理论"></a>CAP理论，BASE理论</h2><p>Consistency（一致性）：更新操作成功后，同一时间所有节点的数据完全一致</p><p>Availability（可用性）：服务一只可用，不会出现用户操作失败或访问超时等现象</p><p>Partition Tolerance（分区容错性）：要求虽然是分布式系统，但使用时要像在使用一个系统一样，当其中有一个或几个机器宕机时，剩下的机器仍能够正常运转，不会对用户的使用体验造成影响</p><p>CAP中p是必须要保证的，c和a中只能二选一</p><p>BASE是Basically Available（基本可用）、Soft state（软状态）、Eventually consistent（最终一致性）</p><h2 id="负载均衡算法、类型"><a href="#负载均衡算法、类型" class="headerlink" title="负载均衡算法、类型"></a>负载均衡算法、类型</h2><ol><li>轮询法：按照请求顺序轮流地分配到后端服务器上</li><li>随机法：随机算法分配</li><li>源地址哈希法：根据客户端的ip地址，通过哈希算法得到一个值，用该数值对服务器列表大小进行取模运算，得到的结果就是访问的服务系序号</li><li>加权轮询法：为服务器附上权值，权值大的会多次被分配。如1234 12 1</li><li>加权随机法：类似加权轮询，不过分配方式随机 。如 1324 21 1</li><li>最小连接数法：选择连接数最小的服务器分配</li></ol><p>类型：</p><p>DNS方式实现负载均衡</p><p>硬件负载均衡：F5和A10</p><p>软件负载均衡：Nginx、HAproxy、LVS。</p><h2 id="分布式架构下，Session共享有什么方案"><a href="#分布式架构下，Session共享有什么方案" class="headerlink" title="分布式架构下，Session共享有什么方案"></a>分布式架构下，Session共享有什么方案</h2><ol><li>采用无状态服务，抛弃session</li><li>存入cookie（有安全风险）</li><li>服务器之间进行session同步，不过当服务器数量较多时，同步会有延迟甚至失败</li><li>ip绑定策略：同一个ip只能同一个服务器进行访问，但这样就失去了负载均衡的意义</li><li>使用redis存储，有多种好处<ol><li>实现了session共享</li><li>可以水平拓展（增加redis服务器）</li><li>服务器重启sesson不丢失</li><li>不仅可以跨服务器session共享，甚至可以跨平台</li></ol></li></ol><h2 id="分布式id生成方案"><a href="#分布式id生成方案" class="headerlink" title="分布式id生成方案"></a>分布式id生成方案</h2><ul><li><p>uuid</p><ol><li>当前日期和时间 时间戳</li><li>时钟序列 计数器</li><li>全局唯一的IEEE机器识别号。</li></ol><p>优点：代码简单，性能好，保证唯一</p><p>缺点：每次生成的id都是无序的，而且不是全数字，且无法保证趋势递增</p><p> 生成的是字符串，查询慢，长度过长，不适合存储，有信息安全问题</p></li><li><p>数据库自增序列</p></li><li><p>Leaf-segment</p></li><li><p>基于redis、mongodb、zk等中间件生成</p></li><li><p>雪花算法</p><p>生成一个64位的整形数字</p><p>第一位符号位固定为0,41位时间戳，10位workId，12为序列号</p><p>位数可以有不同实现</p><p>优点：</p><p> 每一个毫秒值包含的id值有很多，不够可以变动位数来增加，性能佳。</p><p> 时间戳值在高位，中间是固定的机器码，自增的序列号在低位，整个id是趋势递增的</p><p> 能够根据业务场景数据库节点布置灵活的bit位划分，灵活度高</p><p>缺点：</p><p> 强依赖与机器时钟，如果时钟回拨，会导致id重复，因此一般基于此算法发现时钟回拨时会抛出异 常，阻止id生成，这可能导致服务不可用</p></li></ul><h2 id="分布式锁的解决方案"><a href="#分布式锁的解决方案" class="headerlink" title="分布式锁的解决方案"></a>分布式锁的解决方案</h2><p>需要这个锁独立于每一个服务之外 ，而不是在服务内</p><ol><li>数据库：利用主键冲突控制一次只有一个线程才能获取锁，非阻塞、不可重入、单点、失效时间</li><li>zookeeper分布式锁：</li><li>redis分布式锁：setNX（只有当key不存在时才能设置成功），单线程处理网络请求，不需要考虑并发的安全性，所有服务节点设置相同的key，返回值为0、则锁获取失败</li><li>删除锁：判断线程唯一标志，再删除</li><li>redlock</li></ol><h2 id="如何实现接口的幂等性"><a href="#如何实现接口的幂等性" class="headerlink" title="如何实现接口的幂等性"></a>如何实现接口的幂等性</h2><ul><li>唯一id。每次操作，根据操作和内容生成唯一id，执行前判断id是否存在</li><li>建去重表。将业务中有唯一标识的字段保存到去重表，如果表中存在，表示已经处理过了</li><li>版本控制。增加版本号，当版本号符合时才更新数据</li><li>状态控制。</li><li>服务端提供发送token接口，业务调用时携带token，当业务执行完成后，将token从redis中删除</li></ul><h2 id="zk的数据模型和节点类型"><a href="#zk的数据模型和节点类型" class="headerlink" title="zk的数据模型和节点类型"></a>zk的数据模型和节点类型</h2><p>数据模型：树形结构</p><p>树中每一个节点被称为Znode</p><p>znode兼具文件和目录两种特点</p><p>znode具有原子性操作，度操作获取与节点相关的所有数据，写操作替换节点所有数据</p><p>znode存储数据大小有限制</p><p>znode通过路径引用，如同Unix中的文件路径。</p><p>节点类型：</p><p> 持久节点：一旦创建，该节点会只存在zk服务器上，即使该节点的客户端与服务器端会话关闭，节点也 不会删除</p><p> 临时节点：当创建该节点的客户端会话关闭时，节点删除</p><p> 有序节点：不是一种单独种类的节点，而是在前两种节点的基础上，加上了有序的特性</p><h2 id="zk和eureka的区别"><a href="#zk和eureka的区别" class="headerlink" title="zk和eureka的区别"></a>zk和eureka的区别</h2><p>zk:cp设计（强一致性），目标是一个分布式协调系统，用于资源的统一管理，当节点不可用时，需要进行选举，期间zk服务不可用</p><p>eureka：ap设计（高可用），目标是一个服务注册发现系统，专门用于微服务发现注册</p><p>eureka的各个节点都是平等的，一个不可用会自动切换到其他的节点，只要还要一个eureka在工作，就能保证注册服务可用，不过查询到的信息能不是最新的</p><h2 id="Spring-Cloud和Dubbo的区别"><a href="#Spring-Cloud和Dubbo的区别" class="headerlink" title="Spring Cloud和Dubbo的区别"></a>Spring Cloud和Dubbo的区别</h2><p>底层协议：前者基于http协议，后者基于tcp协议</p><p>注册中心：前者使用eureka，后者使用zk</p><p>模型定义：前者将一个应用定义为一个服务，后者将一个接口定义为一个服务</p><p>前者是一个生态，后者只是前者生态中关于微服务调用额一种解决方案</p><h2 id="什么是Hystrix，简述实现机制"><a href="#什么是Hystrix，简述实现机制" class="headerlink" title="什么是Hystrix，简述实现机制"></a>什么是Hystrix，简述实现机制</h2><p>分布式容错框架</p><ul><li>阻止故障的连锁反应，实现熔断</li><li>快速失败，实现优雅降级</li><li>提供实时的监控和告警</li></ul><p>熔断和降级：调用服务失败后快速失败</p><p>熔断是为了防止异常扩散，保证系统的稳定性</p><p>降级：编写好调用失败的补救逻辑，然后对服务直接停止运行，这样接口就无法直接调用，但又不至于报错，只是服务水平下降</p><h2 id="Spring-Cloud核心组件及作用"><a href="#Spring-Cloud核心组件及作用" class="headerlink" title="Spring Cloud核心组件及作用"></a>Spring Cloud核心组件及作用</h2><p>Eureka：服务注册与发现</p><p>Ribbon：负载均衡</p><p>Feign：动态代理，调用远程就想调用本地服务一样</p><p>Hystrix：服务熔断和降级</p><p>Zuul：微服务网关，负责网络路由</p><h2 id="Dubbo的整体架构设计及分层"><a href="#Dubbo的整体架构设计及分层" class="headerlink" title="Dubbo的整体架构设计及分层"></a>Dubbo的整体架构设计及分层</h2><p>五个角色</p><p>注册中心registry：服务注册与发现</p><p>服务提供者provider：暴露服务</p><p>服务消费者consumer：调用远程服务</p><p>监控中心monitor：统计服务的调用次数和调用时间</p><p>容器container：服务允许容器</p><p>调用流程：</p><ol><li>container容器负责启动、加载、运行provider</li><li>provider在启动时，向registry中心注册自己提供的服务</li><li>consumer在启动时，向registry中心订阅自己需要的服务</li><li>registry返回服务提供者列表给consumer</li><li>consumer调用provider服务，基于负载均衡算法进行调用</li><li>consumer调用provider的统计，基于短链接定时每分钟一次统计到monitor</li></ol><p>分层</p><ul><li>接口服务层（Service）：面向开发者，业务代码，接口，实现等</li><li>配置层（Config）：对外配置接口，以ServiceConfig和ReferenceConfig为中心</li><li>服务代理层（Proxy）：对生产者和消费者、dubbo都会产生一个代理类封装调用细节，业务层对远程调用无感</li><li>服务注册层（Registry）：封装服务地址的注册和发现，以服务URL为中心</li><li>路由层（Cluster）：封装多个提供者的路由和负载均衡，并桥接注册中心</li><li>监控层（Monitor）：RPC调用次数和调用时间监控</li><li>远程调用层（Protocal）：封装RPC调用</li><li>信息交换层（Exchange）：封装请求响应模式，同步转异步</li><li>网络传输层（Transport）:抽象main和hetty为统一接口，同一网络传输接口</li><li>数据序列化层（Serialize）：数据传输的序列化和反序列化</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术连连看 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git用法</title>
      <link href="/2023/03/06/git%E7%94%A8%E6%B3%95/"/>
      <url>/2023/03/06/git%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><p>把要提交的文件的信息添加到暂存区中。当使用 git commit 时，将依据暂存区中的内容来进行文件的提交。</p><blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 把指定的文件添加到暂存区中</span></span><br><span class="line">$ git add &lt;文件路径&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加所有修改、已删除的文件到暂存区中</span></span><br><span class="line">$ git add -u [&lt;文件路径&gt;]</span><br><span class="line">$ git add --update [&lt;文件路径&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加所有修改、已删除、新增的文件到暂存区中，省略 &lt;文件路径&gt; 即为当前目录</span></span><br><span class="line">$ git add -A [&lt;文件路径&gt;]</span><br><span class="line">$ git add --all [&lt;文件路径&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有修改、已删除但没有提交的文件，进入一个子命令系统</span></span><br><span class="line">$ git add -i [&lt;文件路径&gt;]</span><br><span class="line">$ git add --interactive [&lt;文件路径&gt;]</span><br></pre></td></tr></table></figure></blockquote><h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h3><p>操作 Git 的分支命令。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出本地的所有分支，当前所在分支以 &quot;*&quot; 标出</span></span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出本地的所有分支并显示最后一次提交，当前所在分支以 &quot;*&quot; 标出</span></span><br><span class="line">$ git branch -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建新分支，新的分支基于上一次提交建立</span></span><br><span class="line">$ git branch &lt;分支名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改分支名称</span></span><br><span class="line"><span class="comment"># 如果不指定原分支名称则为当前所在分支</span></span><br><span class="line">$ git branch -m [&lt;原分支名称&gt;] &lt;新的分支名称&gt;</span><br><span class="line"><span class="comment"># 强制修改分支名称</span></span><br><span class="line">$ git branch -M [&lt;原分支名称&gt;] &lt;新的分支名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定的本地分支</span></span><br><span class="line">$ git branch -d &lt;分支名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制删除指定的本地分支</span></span><br><span class="line">$ git branch -D &lt;分支名称&gt;</span><br></pre></td></tr></table></figure><h3 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h3><p>更新工作树中的文件以匹配索引或指定树中的版本。如果没有给出路径 - <code>git checkout</code> 还会更新 <code>HEAD</code> ，将指定的分支设置为当前分支。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切换到已存在的指定分支</span></span><br><span class="line">$ git checkout &lt;分支名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建并切换到指定的分支，保留所有的提交记录</span></span><br><span class="line"><span class="comment"># 等同于 &quot;git branch&quot; 和 &quot;git checkout&quot; 两个命令合并</span></span><br><span class="line">$ git checkout -b &lt;分支名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建并切换到指定的分支，删除所有的提交记录</span></span><br><span class="line">$ git checkout --orphan &lt;分支名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换掉本地的改动，新增的文件和已经添加到暂存区的内容不受影响</span></span><br><span class="line">$ git checkout &lt;文件路径&gt;</span><br></pre></td></tr></table></figure><p><code>git checkout</code> 是 git 最常用的命令之一，同时也是一个很危险的命令，因为这条命令会重写工作区。</p><h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><p>将存储库克隆到新创建的目录中，为克隆的存储库中的每个分支创建远程跟踪分支(使用 <code>git branch -r</code> 可见)，并从克隆检出的存储库作为当前活动分支的初始分支。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认在当前目录下创建和版本库名相同的文件夹并下载版本到该文件夹下</span></span><br><span class="line">$ git <span class="built_in">clone</span> &lt;远程仓库的网址&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定本地仓库的目录</span></span><br><span class="line">$ git <span class="built_in">clone</span> &lt;远程仓库的网址&gt; &lt;本地目录&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># -b 指定要克隆的分支，默认是master分支</span></span><br><span class="line">$ git <span class="built_in">clone</span> &lt;远程仓库的网址&gt; -b &lt;分支名称&gt; &lt;本地目录&gt;</span><br></pre></td></tr></table></figure><h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><p>将索引的当前内容与描述更改的用户和日志消息一起存储在新的提交中。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 把暂存区中的文件提交到本地仓库，调用文本编辑器输入该次提交的描述信息</span></span><br><span class="line">$ git commit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把暂存区中的文件提交到本地仓库中并添加描述信息</span></span><br><span class="line">$ git commit -m <span class="string">&quot;&lt;提交的描述信息&gt;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把所有修改、已删除的文件提交到本地仓库中</span></span><br><span class="line"><span class="comment"># 不包括未被版本库跟踪的文件，等同于先调用了 &quot;git add -u&quot;</span></span><br><span class="line">$ git commit -a -m <span class="string">&quot;&lt;提交的描述信息&gt;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改上次提交的描述信息</span></span><br><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure><h3 id="git-config"><a href="#git-config" class="headerlink" title="git config"></a>git config</h3><p>主要是用来配置 Git 的相关参数，其主要操作有：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看配置信息</span></span><br><span class="line"><span class="comment"># --local：仓库级，--global：全局级，--system：系统级</span></span><br><span class="line">$ git config &lt;--<span class="built_in">local</span> | --global | --system&gt; -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前生效的配置信息</span></span><br><span class="line">$ git config -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑配置文件</span></span><br><span class="line"><span class="comment"># --local：仓库级，--global：全局级，--system：系统级</span></span><br><span class="line">$ git config &lt;--<span class="built_in">local</span> | --global | --system&gt; -e</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加配置项</span></span><br><span class="line"><span class="comment"># --local：仓库级，--global：全局级，--system：系统级</span></span><br><span class="line">$ git config &lt;--<span class="built_in">local</span> | --global | --system&gt; --add &lt;name&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取配置项</span></span><br><span class="line">$ git config &lt;--<span class="built_in">local</span> | --global | --system&gt; --get &lt;name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除配置项</span></span><br><span class="line">$ git config &lt;--<span class="built_in">local</span> | --global | --system&gt; --<span class="built_in">unset</span> &lt;name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置提交记录中的用户信息</span></span><br><span class="line">$ git config --global user.name &lt;用户名&gt;</span><br><span class="line">$ git config --global user.email &lt;邮箱地址&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更改Git缓存区的大小</span></span><br><span class="line"><span class="comment"># 如果提交的内容较大，默认缓存较小，提交会失败</span></span><br><span class="line"><span class="comment"># 缓存大小单位：B，例如：524288000（500MB）</span></span><br><span class="line">$ git config --global http.postBuffer &lt;缓存大小&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用 git status/git diff 命令时以高亮或彩色方式显示改动状态</span></span><br><span class="line">$ git config --global color.ui <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置可以缓存密码，默认缓存时间15分钟</span></span><br><span class="line">$ git config --global credential.helper cache</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置密码的缓存时间</span></span><br><span class="line"><span class="comment"># 缓存时间单位：秒</span></span><br><span class="line">$ git config --global credential.helper <span class="string">&#x27;cache --timeout=&lt;缓存时间&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置长期存储密码</span></span><br><span class="line">$ git config --global credential.helper store</span><br></pre></td></tr></table></figure><p>Git 一共有3个配置文件：</p><ul><li>仓库级的配置文件：在仓库的 <code>.git/.gitconfig</code>，该配置文件只对所在的仓库有效。</li><li>全局配置文件：Mac 系统在 <code>~/.gitconfig</code>，Windows 系统在 <code>C:\Users\&lt;用户名&gt;\.gitconfig</code>。</li><li>系统级的配置文件：在 Git 的安装目录下（Mac 系统下安装目录在 <code>/usr/local/git</code>）的 <code>etc</code> 文件夹中的 <code>gitconfig</code>。</li></ul><h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h3><p>用于显示提交和工作树等之间的更改。</p><p>此命令比较的是工作目录中当前文件和暂存区域快照之间的差异,也就是修改之后还没有暂存起来的变化内容。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 比较当前文件和暂存区中文件的差异，显示没有暂存起来的更改</span></span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较暂存区中的文件和上次提交时的差异</span></span><br><span class="line">$ git diff --cached</span><br><span class="line">$ git diff --staged</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较当前文件和上次提交时的差异</span></span><br><span class="line">$ git diff HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看从指定的版本之后改动的内容</span></span><br><span class="line">$ git diff &lt;commit ID&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较两个分支之间的差异</span></span><br><span class="line">$ git diff &lt;分支名称&gt; &lt;分支名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看两个分支分开后各自的改动内容</span></span><br><span class="line">$ git diff &lt;分支名称&gt;...&lt;分支名称&gt;</span><br></pre></td></tr></table></figure><h3 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h3><p>从远程仓库获取最新的版本到本地的 tmp 分支上。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将远程仓库所有分支的最新版本全部取回到本地</span></span><br><span class="line">$ git fetch &lt;远程仓库的别名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将远程仓库指定分支的最新版本取回到本地</span></span><br><span class="line">$ git fetch &lt;远程主机名&gt; &lt;分支名&gt;</span><br></pre></td></tr></table></figure><h3 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h3><p>初始化项目所在目录，初始化后会在当前目录下出现一个名为 .git 的目录。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化本地仓库，在当前目录下生成 .git 文件夹</span></span><br><span class="line">$ git init</span><br></pre></td></tr></table></figure><h3 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h3><p>显示提交的记录。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打印所有的提交记录</span></span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印从第一次提交到指定的提交的记录</span></span><br><span class="line">$ git <span class="built_in">log</span> &lt;commit ID&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印指定数量的最新提交的记录</span></span><br><span class="line">$ git <span class="built_in">log</span> -&lt;指定的数量&gt;</span><br></pre></td></tr></table></figure><h3 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h3><p>用于将两个或两个以上的开发历史加入(合并)一起。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 把指定的分支合并到当前所在的分支下，并自动进行新的提交</span></span><br><span class="line">$ git merge &lt;分支名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把指定的分支合并到当前所在的分支下，不进行新的提交</span></span><br><span class="line">$ git merge --no-commit &lt;分支名称&gt;</span><br></pre></td></tr></table></figure><h3 id="git-mv"><a href="#git-mv" class="headerlink" title="git mv"></a>git mv</h3><p>重命名文件或者文件夹。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重命名指定的文件或者文件夹</span></span><br><span class="line">$ git <span class="built_in">mv</span> &lt;源文件/文件夹&gt; &lt;目标文件/文件夹&gt;</span><br></pre></td></tr></table></figure><h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><p>从远程仓库获取最新版本并合并到本地。 首先会执行 <code>git fetch</code>，然后执行 <code>git merge</code>，把获取的分支的 HEAD 合并到当前分支。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从远程仓库获取最新版本。</span></span><br><span class="line">$ git pull</span><br></pre></td></tr></table></figure><h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><p>把本地仓库的提交推送到远程仓库。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 把本地仓库的分支推送到远程仓库的指定分支</span></span><br><span class="line">$ git push &lt;远程仓库的别名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定的远程仓库的分支</span></span><br><span class="line">$ git push &lt;远程仓库的别名&gt; :&lt;远程分支名&gt;</span><br><span class="line">$ git push &lt;远程仓库的别名&gt; --delete &lt;远程分支名&gt;</span><br></pre></td></tr></table></figure><h3 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h3><p>操作远程库。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出已经存在的远程仓库</span></span><br><span class="line">$ git remote</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出远程仓库的详细信息，在别名后面列出URL地址</span></span><br><span class="line">$ git remote -v</span><br><span class="line">$ git remote --verbose</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加远程仓库</span></span><br><span class="line">$ git remote add &lt;远程仓库的别名&gt; &lt;远程仓库的URL地址&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改远程仓库的别名</span></span><br><span class="line">$ git remote rename &lt;原远程仓库的别名&gt; &lt;新的别名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定名称的远程仓库</span></span><br><span class="line">$ git remote remove &lt;远程仓库的别名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改远程仓库的 URL 地址</span></span><br><span class="line">$ git remote set-url &lt;远程仓库的别名&gt; &lt;新的远程仓库URL地址&gt;</span><br></pre></td></tr></table></figure><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><p>还原提交记录。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重置暂存区，但文件不受影响</span></span><br><span class="line"><span class="comment"># 相当于将用 &quot;git add&quot; 命令更新到暂存区的内容撤出暂存区，可以指定文件</span></span><br><span class="line"><span class="comment"># 没有指定 commit ID 则默认为当前 HEAD</span></span><br><span class="line">$ git reset [&lt;文件路径&gt;]</span><br><span class="line">$ git reset --mixed [&lt;文件路径&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 HEAD 的指向改变，撤销到指定的提交记录，文件未修改</span></span><br><span class="line">$ git reset &lt;commit ID&gt;</span><br><span class="line">$ git reset --mixed &lt;commit ID&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 HEAD 的指向改变，撤销到指定的提交记录，文件未修改</span></span><br><span class="line"><span class="comment"># 相当于调用 &quot;git reset --mixed&quot; 命令后又做了一次 &quot;git add&quot;</span></span><br><span class="line">$ git reset --soft &lt;commit ID&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 HEAD 的指向改变，撤销到指定的提交记录，文件也修改了</span></span><br><span class="line">$ git reset --hard &lt;commit ID&gt;</span><br></pre></td></tr></table></figure><h3 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h3><p>生成一个新的提交来撤销某次提交，此次提交之前的所有提交都会被保留。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成一个新的提交来撤销某次提交</span></span><br><span class="line">$ git revert &lt;commit ID&gt;</span><br></pre></td></tr></table></figure><h3 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h3><p>删除文件或者文件夹。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 移除跟踪指定的文件，并从本地仓库的文件夹中删除</span></span><br><span class="line">$ git <span class="built_in">rm</span> &lt;文件路径&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除跟踪指定的文件夹，并从本地仓库的文件夹中删除</span></span><br><span class="line">$ git <span class="built_in">rm</span> -r &lt;文件夹路径&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除跟踪指定的文件，在本地仓库的文件夹中保留该文件</span></span><br><span class="line">$ git <span class="built_in">rm</span> --cached</span><br></pre></td></tr></table></figure><h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h3><p>用于显示工作目录和暂存区的状态。使用此命令能看到那些修改被暂存到了, 哪些没有, 哪些文件没有被 Git tracked 到。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看本地仓库的状态</span></span><br><span class="line">$ git status</span><br></pre></td></tr></table></figure><blockquote><p><code>git status</code> 不显示已经 <code>commit</code> 到项目历史中去的信息。<br>看项目历史的信息要使用 <code>git log</code>。</p></blockquote><h3 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h3><p>操作标签的命令。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打印所有的标签</span></span><br><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加轻量标签，指向提交对象的引用，可以指定之前的提交记录</span></span><br><span class="line">$ git tag &lt;标签名称&gt; [&lt;commit ID&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加带有描述信息的附注标签，可以指定之前的提交记录</span></span><br><span class="line">$ git tag -a &lt;标签名称&gt; -m &lt;标签描述信息&gt; [&lt;commit ID&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到指定的标签</span></span><br><span class="line">$ git checkout &lt;标签名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看标签的信息</span></span><br><span class="line">$ git show &lt;标签名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定的标签</span></span><br><span class="line">$ git tag -d &lt;标签名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将指定的标签提交到远程仓库</span></span><br><span class="line">$ git push &lt;远程仓库的别名&gt; &lt;标签名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将本地所有的标签全部提交到远程仓库</span></span><br><span class="line">$ git push &lt;远程仓库的别名&gt; –tags</span><br></pre></td></tr></table></figure><hr><p>THE END</p>]]></content>
      
      
      <categories>
          
          <category> 技术连连看 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 字典 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lambda表达式</title>
      <link href="/2023/03/06/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2023/03/06/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 技术连连看 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# </tag>
            
            <tag> lambda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linq语法</title>
      <link href="/2023/03/02/linq%E8%AF%AD%E6%B3%95/"/>
      <url>/2023/03/02/linq%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="LINQ中的八大关键字"><a href="#LINQ中的八大关键字" class="headerlink" title="LINQ中的八大关键字"></a>LINQ中的八大关键字</h3><table><thead><tr><th><strong>关键字</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>from</td><td>指定范围变量和数据源</td></tr><tr><td>where</td><td>根据bool表达式从数据源中筛选数据</td></tr><tr><td>select</td><td>指定查询结果中的元素所具有的类型或表现形式</td></tr><tr><td>group</td><td>对查询结果按照键值进行分组(IGrouping&lt;TKey,TElement&gt;)</td></tr><tr><td>into</td><td>提供一个标识符，它可以充当对join、group或select子句结果的引用</td></tr><tr><td>orderby</td><td>对查询出的元素进行排序(ascending&#x2F;descending)</td></tr><tr><td>join</td><td>按照两个指定匹配条件来Equals连接两个数据源（join on equals）</td></tr><tr><td>let</td><td>产生一个用于存储查询表达式中的子表达式查询结果的范围变量</td></tr></tbody></table><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">List&lt;User&gt; list1 = <span class="keyword">new</span> List&lt;User&gt;()</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">new</span> User(<span class="string">&quot;杨无敌&quot;</span>,<span class="number">17</span>)&#123; &#125;,</span><br><span class="line">                <span class="keyword">new</span> User(<span class="string">&quot;杨无敌&quot;</span>,<span class="number">18</span>)&#123; &#125;,</span><br><span class="line">                <span class="keyword">new</span> User(<span class="string">&quot;杨潇洒&quot;</span>,<span class="number">18</span>)&#123; &#125;,</span><br><span class="line">                <span class="keyword">new</span> User(<span class="string">&quot;杨高尚&quot;</span>,<span class="number">20</span>)&#123; &#125;,</span><br><span class="line">            &#125;;</span><br><span class="line">            List&lt;User&gt; list2 = <span class="keyword">new</span> List&lt;User&gt;()</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">new</span> User(<span class="string">&quot;杨无敌&quot;</span>,<span class="number">19</span>)&#123; &#125;,</span><br><span class="line">                <span class="keyword">new</span> User(<span class="string">&quot;杨无敌&quot;</span>,<span class="number">20</span>)&#123; &#125;,</span><br><span class="line">                <span class="keyword">new</span> User(<span class="string">&quot;杨潇洒&quot;</span>,<span class="number">19</span>)&#123; &#125;,</span><br><span class="line">                <span class="keyword">new</span> User(<span class="string">&quot;杨倜傥&quot;</span>,<span class="number">18</span>)&#123; &#125;,</span><br><span class="line">            &#125;;</span><br><span class="line">            List&lt;User&gt; list3 = <span class="keyword">new</span> List&lt;User&gt;()</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">new</span> User(<span class="string">&quot;杨无敌&quot;</span>,<span class="number">19</span>)&#123; &#125;,</span><br><span class="line">                <span class="keyword">new</span> User(<span class="string">&quot;杨无敌&quot;</span>,<span class="number">20</span>)&#123; &#125;,</span><br><span class="line">                <span class="keyword">new</span> User(<span class="string">&quot;杨无敌&quot;</span>,<span class="number">21</span>)&#123; &#125;,</span><br><span class="line">                <span class="keyword">new</span> User(<span class="string">&quot;杨无敌&quot;</span>,<span class="number">22</span>)&#123; &#125;,</span><br><span class="line">                <span class="keyword">new</span> User(<span class="string">&quot;杨无敌&quot;</span>,<span class="number">20</span>)&#123; &#125;,</span><br><span class="line">                <span class="keyword">new</span> User(<span class="string">&quot;杨潇洒&quot;</span>,<span class="number">19</span>)&#123; &#125;,</span><br><span class="line">                <span class="keyword">new</span> User(<span class="string">&quot;杨潇洒&quot;</span>,<span class="number">19</span>)&#123; &#125;,</span><br><span class="line">                <span class="keyword">new</span> User(<span class="string">&quot;杨潇洒&quot;</span>,<span class="number">19</span>)&#123; &#125;,</span><br><span class="line">                <span class="keyword">new</span> User(<span class="string">&quot;杨倜傥&quot;</span>,<span class="number">18</span>)&#123; &#125;,</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure><h3 id="from用法"><a href="#from用法" class="headerlink" title="from用法"></a>from用法</h3><h4 id="from简单用法"><a href="#from简单用法" class="headerlink" title="from简单用法"></a>from简单用法</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> res = <span class="keyword">from</span> user <span class="keyword">in</span> list1</span><br><span class="line">           <span class="keyword">where</span> user.name == <span class="string">&quot;杨无敌&quot;</span></span><br><span class="line">           <span class="keyword">select</span> user;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="复合from用法"><a href="#复合from用法" class="headerlink" title="复合from用法"></a>复合from用法</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无条件判断时 结果数量为两表的笛卡尔积中对象的数量即 4*4=16 条数据</span></span><br><span class="line"><span class="keyword">var</span> res1 = <span class="keyword">from</span> user1 <span class="keyword">in</span> list1</span><br><span class="line">            <span class="keyword">from</span> user2 <span class="keyword">in</span> list2 </span><br><span class="line">            <span class="keyword">select</span> user1;</span><br><span class="line"><span class="keyword">foreach</span>(<span class="keyword">var</span> user <span class="keyword">in</span> res1)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;user.name&#125;</span>+<span class="subst">&#123;user.age&#125;</span>&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  输出结果</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">杨无敌+17</span></span><br><span class="line"><span class="comment">    杨无敌+17</span></span><br><span class="line"><span class="comment">    杨无敌+17</span></span><br><span class="line"><span class="comment">    杨无敌+17</span></span><br><span class="line"><span class="comment">    杨无敌+18</span></span><br><span class="line"><span class="comment">    杨无敌+18</span></span><br><span class="line"><span class="comment">    杨无敌+18</span></span><br><span class="line"><span class="comment">    杨无敌+18</span></span><br><span class="line"><span class="comment">    杨潇洒+18</span></span><br><span class="line"><span class="comment">    杨潇洒+18</span></span><br><span class="line"><span class="comment">    杨潇洒+18</span></span><br><span class="line"><span class="comment">    杨潇洒+18</span></span><br><span class="line"><span class="comment">    杨高尚+20</span></span><br><span class="line"><span class="comment">    杨高尚+20</span></span><br><span class="line"><span class="comment">    杨高尚+20</span></span><br><span class="line"><span class="comment">    杨高尚+20</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="join用法"><a href="#join用法" class="headerlink" title="join用法"></a>join用法</h3><h4 id="简单join用法（内连接）"><a href="#简单join用法（内连接）" class="headerlink" title="简单join用法（内连接）"></a>简单join用法（内连接）</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> res2 = (<span class="keyword">from</span> user1 <span class="keyword">in</span> list1</span><br><span class="line">            <span class="keyword">join</span> user2 <span class="keyword">in</span> list2</span><br><span class="line">            <span class="keyword">on</span> user1.name <span class="keyword">equals</span> user2.name</span><br><span class="line">            <span class="keyword">select</span> user1).ToList();</span><br><span class="line"><span class="keyword">foreach</span> (User user <span class="keyword">in</span> res2)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;user.name&#125;</span>+<span class="subst">&#123;user.age&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//输出结果的数量为：符合条件的数量的乘积再相加，例如user1中杨无敌两条符合，user2中杨无敌两条符合，最终杨无敌数量为4条，</span></span><br><span class="line"><span class="comment">//                                            user1中杨潇洒一条符合，user2中杨潇洒一条符合，最终杨潇洒数量为1条，最终再把各个符合条件的加起来4+1=5条数据；</span></span><br><span class="line"><span class="comment">//输出结果的值：取决于select中的代码赋值     </span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">杨无敌+17</span></span><br><span class="line"><span class="comment">    杨无敌+17</span></span><br><span class="line"><span class="comment">    杨无敌+18</span></span><br><span class="line"><span class="comment">    杨无敌+18</span></span><br><span class="line"><span class="comment">    杨潇洒+18</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="join实现左外连接"><a href="#join实现左外连接" class="headerlink" title="join实现左外连接"></a>join实现左外连接</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//若要在 LINQ 中执行左外部联接，请结合使用 DefaultIfEmpty 方法与分组联接，指定要在某个左侧元素不具有匹配元素时生成的默认右侧元素。 </span></span><br><span class="line"><span class="comment">//可以使用 null 作为任何引用类型的默认值，也可以指定用户定义的默认类型。</span></span><br><span class="line"><span class="keyword">var</span> res22 = <span class="keyword">from</span> user1 <span class="keyword">in</span> list1</span><br><span class="line">    <span class="keyword">join</span> user2 <span class="keyword">in</span> list2 <span class="keyword">on</span> user1.name <span class="keyword">equals</span> user2.name <span class="keyword">into</span> users</span><br><span class="line">    <span class="keyword">from</span> user <span class="keyword">in</span> users.DefaultIfEmpty()</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">new</span></span><br><span class="line">&#123;</span><br><span class="line">    name = user1.name,</span><br><span class="line">    age = user == <span class="literal">null</span> ? <span class="number">0</span> : user1.age</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">foreach</span>(<span class="keyword">var</span> user <span class="keyword">in</span> res22)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;user.name&#125;</span>+<span class="subst">&#123;user.age&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//结果相对于内连接 还多了左表中不符合条件的数据</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">杨无敌+17</span></span><br><span class="line"><span class="comment">    杨无敌+17</span></span><br><span class="line"><span class="comment">    杨无敌+18</span></span><br><span class="line"><span class="comment">    杨无敌+18</span></span><br><span class="line"><span class="comment">    杨潇洒+18</span></span><br><span class="line"><span class="comment">    杨高尚+0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="let用法"><a href="#let用法" class="headerlink" title="let用法"></a>let用法</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//let子句用于在LINQ表达式中存储子表达式的计算结果。let子句创建一个范围变量来存储结果，</span></span><br><span class="line"><span class="comment">//变量被创建后，不能修改或把其他表达式的结果重新赋值给它。此范围变量可以再后续的LINQ子句中使用。</span></span><br><span class="line"><span class="keyword">var</span> res3 = (<span class="keyword">from</span> user <span class="keyword">in</span> list1</span><br><span class="line">            <span class="keyword">let</span> age = user.age</span><br><span class="line">            <span class="keyword">let</span> name = user.name</span><br><span class="line">            <span class="keyword">where</span> age &gt; <span class="number">17</span> &amp;&amp; name.Equals( <span class="string">&quot;杨无敌&quot;</span>)</span><br><span class="line">            <span class="keyword">select</span> user).ToList();</span><br><span class="line"><span class="keyword">foreach</span>(User user <span class="keyword">in</span> res3)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;user.name&#125;</span>+<span class="subst">&#123;user.age&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">杨无敌+18</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="group-by用法"><a href="#group-by用法" class="headerlink" title="group by用法"></a>group by用法</h3><h4 id="单列分组"><a href="#单列分组" class="headerlink" title="单列分组"></a>单列分组</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> res4 = (<span class="keyword">from</span> user <span class="keyword">in</span> list2</span><br><span class="line">            <span class="keyword">group</span> user <span class="keyword">by</span> user.name <span class="keyword">into</span> g</span><br><span class="line">            <span class="keyword">select</span> <span class="keyword">new</span></span><br><span class="line">            &#123;</span><br><span class="line">                name = g.Key,</span><br><span class="line">                age = g.Sum(t =&gt; t.age)</span><br><span class="line">            &#125;).ToList();</span><br><span class="line"><span class="keyword">foreach</span>(<span class="keyword">var</span> user <span class="keyword">in</span> res4)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;user.name&#125;</span>+<span class="subst">&#123;user.age&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多列分组"><a href="#多列分组" class="headerlink" title="多列分组"></a>多列分组</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如需按多列分组可使用new  参考  group t by new &#123;t.MaterialID, t.ProductID&#125; into grp</span></span><br><span class="line"><span class="comment">//into 用法  查询延续子句可以接受查询的一部分结构并赋予一个名字，从而可以在查询的另一部分中使用</span></span><br><span class="line"><span class="comment">//key 表示用来分组的列，这里表示name和age两列组成的集合</span></span><br><span class="line"><span class="comment">//group by where 的使用顺序是    where-&gt;groupby</span></span><br><span class="line"><span class="keyword">var</span> res5 = (<span class="keyword">from</span> user <span class="keyword">in</span> list3</span><br><span class="line">            <span class="keyword">where</span> user.age &lt;= <span class="number">20</span></span><br><span class="line">            <span class="keyword">group</span> user <span class="keyword">by</span> <span class="keyword">new</span> &#123; user.name, user.age &#125; <span class="keyword">into</span> grouptmp</span><br><span class="line">            <span class="keyword">select</span> <span class="keyword">new</span></span><br><span class="line">            &#123;</span><br><span class="line">                key = grouptmp.Key,</span><br><span class="line">                name = grouptmp.Key.name,</span><br><span class="line">                age = grouptmp.Sum(t =&gt; t.age)</span><br><span class="line">            &#125;).ToList();</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> user <span class="keyword">in</span> res5)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;user.key&#125;</span>+<span class="subst">&#123;user.name&#125;</span>+<span class="subst">&#123;user.age&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123; name = 杨无敌, age = 19 &#125;+杨无敌+19</span></span><br><span class="line"><span class="comment">    &#123; name = 杨无敌, age = 20 &#125;+杨无敌+40</span></span><br><span class="line"><span class="comment">    &#123; name = 杨潇洒, age = 19 &#125;+杨潇洒+57</span></span><br><span class="line"><span class="comment">    &#123; name = 杨倜傥, age = 18 &#125;+杨倜傥+18</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="orderby用法"><a href="#orderby用法" class="headerlink" title="orderby用法"></a>orderby用法</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//与where关键字不分前后 默认是ascending，可以设置倒序 descending</span></span><br><span class="line"><span class="keyword">var</span> res6 = (<span class="keyword">from</span> user <span class="keyword">in</span> list2</span><br><span class="line">            <span class="keyword">orderby</span> user.age <span class="keyword">descending</span></span><br><span class="line">            <span class="keyword">select</span> user).ToList();</span><br><span class="line"><span class="keyword">foreach</span>(<span class="keyword">var</span> user <span class="keyword">in</span> res6)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;user.name&#125;</span>+<span class="subst">&#123;user.age&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">杨无敌+20</span></span><br><span class="line"><span class="comment">    杨无敌+19</span></span><br><span class="line"><span class="comment">    杨潇洒+19</span></span><br><span class="line"><span class="comment">    杨倜傥+18</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="select用法"><a href="#select用法" class="headerlink" title="select用法"></a>select用法</h3><h4 id="简单用法"><a href="#简单用法" class="headerlink" title="简单用法"></a>简单用法</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> res7 = <span class="keyword">from</span> user <span class="keyword">in</span> list1</span><br><span class="line">    <span class="keyword">select</span> user;</span><br></pre></td></tr></table></figure><h4 id="匿名类型形式"><a href="#匿名类型形式" class="headerlink" title="匿名类型形式"></a>匿名类型形式</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> res8 = <span class="keyword">from</span> user <span class="keyword">in</span> list1</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">new</span></span><br><span class="line">&#123;</span><br><span class="line">    name = user.name,</span><br><span class="line">    age = user.age</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>THE END</p>]]></content>
      
      
      <categories>
          
          <category> 技术连连看 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# </tag>
            
            <tag> 字典 </tag>
            
            <tag> linq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ado.net操作mysql数据库</title>
      <link href="/2023/02/24/ado-net%E6%93%8D%E4%BD%9Cmysql%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2023/02/24/ado-net%E6%93%8D%E4%BD%9Cmysql%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h3 id="首先是流程图"><a href="#首先是流程图" class="headerlink" title="首先是流程图"></a><strong>首先是流程图</strong></h3><img src="流程图.png" style="zoom:50%;" /><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="引用（有用的没有的都放这了）"><a href="#引用（有用的没有的都放这了）" class="headerlink" title="引用（有用的没有的都放这了）"></a><strong>引用（有用的没有的都放这了）</strong></h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Office.Interop.Excel;</span><br><span class="line"><span class="keyword">using</span> MySqlConnector;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Data;</span><br><span class="line"><span class="keyword">using</span> SData = System.Data;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> NPOI.SS.UserModel;</span><br><span class="line"><span class="keyword">using</span> NPOI.XSSF.UserModel;</span><br><span class="line"><span class="keyword">using</span> NPOI.HSSF.UserModel;</span><br><span class="line"><span class="keyword">using</span> CsvHelper;</span><br><span class="line"><span class="keyword">using</span> System.Globalization;</span><br></pre></td></tr></table></figure><h4 id="全局变量一览"><a href="#全局变量一览" class="headerlink" title="全局变量一览"></a><strong>全局变量一览</strong></h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">string</span> connectionString = <span class="string">&quot;server=127.0.0.1;port=3306;user=root;password=root; database=test;charset=utf8;SslMode=none&quot;</span>;</span><br><span class="line">DataTable excel = ExcelUtil.ExcelToTable(<span class="string">&quot;C:\\Users\\baizh\\Desktop\\test_user.xlsx&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="表格数据一览"><a href="#表格数据一览" class="headerlink" title="表格数据一览"></a><strong>表格数据一览</strong></h4><p><img src="/2023/02/24/ado-net%E6%93%8D%E4%BD%9Cmysql%E6%95%B0%E6%8D%AE%E5%BA%93/%E8%A1%A8%E6%A0%BC%E6%95%B0%E6%8D%AE.png" alt="excel表格内容"></p><h3 id="不使用适配器"><a href="#不使用适配器" class="headerlink" title="不使用适配器"></a>不使用适配器</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> (MySqlConnection myconn = <span class="keyword">new</span> MySqlConnection(connectionString))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> user_name = <span class="string">&quot;杨代码&quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> sqlSelect = <span class="string">&quot;select user_price from test_user where user_name=@user_name&quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> sqlDelete = <span class="string">&quot;delete from test_user where user_name=@user_name&quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> sqlUpdate = <span class="string">&quot;update test_user set user_price = 114514 where user_name=@user_name&quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> sqlInsert = <span class="string">&quot;insert into test_user(user_name,user_price,user_date) values (&#x27;杨代码&#x27;,110110,&#x27;2023-02-02&#x27;)&quot;</span>;</span><br><span class="line">    MySqlCommand command = <span class="keyword">new</span> MySqlCommand(sqlSelect, myconn);</span><br><span class="line">    command.Parameters.AddWithValue(<span class="string">&quot;@user_name&quot;</span>, user_name);</span><br><span class="line"></span><br><span class="line">    myconn.Open();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> res = command.ExecuteScalar();</span><br><span class="line">    <span class="comment">//var res = command.ExecuteNonQuery();</span></span><br><span class="line"></span><br><span class="line">    Console.WriteLine(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于ExecuteScalar和ExecuteNonQuery和ExecuteReader的用法</p><ul><li><p>ExecuteScalar 方法执行一个SQL命令返回结果集的第一列的第一行。它经常用来执行SQL的COUNT、AVG、MIN、MAX 和 SUM 函数，这些函数都是返回单行单列的结果集，用于增删改时返回值没有意义。</p></li><li><p>ExecuteNonQuery方法用来执行INSERT、UPDATE、DELETE和其他没有返回值得SQL命令，用于增删改时返回值为更改的行数，用于查询时返回值为-1。</p></li><li><p>ExecuteReader 返回一个DataReader对象,可以调用DataReader的方法和属性迭代处理结果集。它是一个快速枚举数据库查询结果的机制，是只读、只进的。对SqlDataReader.Read的每次调用都会从结果集中返回一行。</p></li></ul><p>使用DataReader读取数据</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> (MySqlConnection myConn = <span class="keyword">new</span> MySqlConnection(connectionString))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> sql = <span class="string">&quot;select * from test_user&quot;</span>;</span><br><span class="line">    MySqlCommand command = <span class="keyword">new</span> MySqlCommand(sql, myConn);</span><br><span class="line"></span><br><span class="line">    myConn.Open();</span><br><span class="line"></span><br><span class="line">    MySqlDataReader reader = command.ExecuteReader();</span><br><span class="line">    <span class="keyword">if</span> (reader.HasRows)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (reader.Read())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; reader.FieldCount; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(reader[i] + <span class="string">&quot;   &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使程序等待按键，并且在用户按键之前阻止屏幕，将用户按下的键输出在控制台;</span></span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为数据库中的数据按行显示。</p><h3 id="使用适配器"><a href="#使用适配器" class="headerlink" title="使用适配器"></a>使用适配器</h3><h4 id="按行操作（数据不可重复，否则会覆盖）"><a href="#按行操作（数据不可重复，否则会覆盖）" class="headerlink" title="按行操作（数据不可重复，否则会覆盖）"></a>按行操作（数据不可重复，否则会覆盖）</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(DataRow excelRow <span class="keyword">in</span> excel.Rows)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (MySqlConnection myConn = <span class="keyword">new</span> MySqlConnection(connectionString))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> sql = <span class="string">&quot;select * from test_user where user_name=@user_name&quot;</span>;</span><br><span class="line">        MySqlCommand command = <span class="keyword">new</span> MySqlCommand(sql,myConn);</span><br><span class="line">        command.Parameters.AddWithValue(<span class="string">&quot;@user_name&quot;</span>,excelRow[<span class="string">&quot;姓名&quot;</span>].ToString());</span><br><span class="line">        MySqlDataAdapter adapter = <span class="keyword">new</span> MySqlDataAdapter(command);</span><br><span class="line">        MySqlCommandBuilder cb = <span class="keyword">new</span> MySqlCommandBuilder(adapter);</span><br><span class="line"></span><br><span class="line">        myConn.Open();</span><br><span class="line"></span><br><span class="line">        DataTable dt = <span class="keyword">new</span> DataTable();</span><br><span class="line">        adapter.Fill(dt);</span><br><span class="line"></span><br><span class="line">        DataRow dr = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(dt.Rows.Count == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//新增</span></span><br><span class="line">            dr = dt.NewRow();</span><br><span class="line">            dr[<span class="string">&quot;user_name&quot;</span>] = excelRow[<span class="string">&quot;姓名&quot;</span>].ToString();</span><br><span class="line">            dt.Rows.Add(dr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//更新</span></span><br><span class="line">            dr = dt.Rows[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        dr[<span class="string">&quot;user_price&quot;</span>] = Convert.ToDecimal( excelRow[<span class="string">&quot;金额&quot;</span>].ToString() );</span><br><span class="line">        Console.WriteLine(excelRow[<span class="string">&quot;时间&quot;</span>]);</span><br><span class="line">        dr[<span class="string">&quot;user_date&quot;</span>] = DateTime.ParseExact( excelRow[<span class="string">&quot;时间&quot;</span>].ToString(),<span class="string">&quot;yyyy-MM-dd&quot;</span>,<span class="literal">null</span> );</span><br><span class="line"></span><br><span class="line">        adapter.Update(dt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="按整体操作（数据可重复）"><a href="#按整体操作（数据可重复）" class="headerlink" title="按整体操作（数据可重复）"></a>按整体操作（数据可重复）</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">HashSet&lt;<span class="built_in">string</span>&gt; names = <span class="keyword">new</span> HashSet&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line"><span class="keyword">foreach</span>(.DataRow dr <span class="keyword">in</span> excel.Rows)</span><br><span class="line">&#123;</span><br><span class="line">    names.Add(dr[<span class="string">&quot;姓名&quot;</span>].ToString());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">foreach</span>(<span class="built_in">string</span> user_name <span class="keyword">in</span> names)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span>(MySqlConnection myConn = <span class="keyword">new</span> MySqlConnection(connectionString))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> sql = <span class="string">&quot;select * from test_user where user_name=@user_name&quot;</span>;</span><br><span class="line">        MySqlCommand command = <span class="keyword">new</span> MySqlCommand(sql, myConn);</span><br><span class="line">        command.Parameters.AddWithValue(<span class="string">&quot;@user_name&quot;</span>, user_name);</span><br><span class="line">        MySqlDataAdapter adapter = <span class="keyword">new</span> MySqlDataAdapter(command);</span><br><span class="line">        MySqlCommandBuilder cb = <span class="keyword">new</span> MySqlCommandBuilder(adapter);</span><br><span class="line"></span><br><span class="line">        myConn.Open();</span><br><span class="line"></span><br><span class="line">        DataTable dt = <span class="keyword">new</span> DataTable();</span><br><span class="line">        adapter.Fill(dt);</span><br><span class="line">        DataTable excelDt = find(user_name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新</span></span><br><span class="line">        <span class="keyword">foreach</span>(DataRow dr <span class="keyword">in</span> dt.Rows)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span>(DataRow excelDr <span class="keyword">in</span> excelDt.Rows)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(excelDr.RowState == DataRowState.Deleted)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dr[<span class="string">&quot;user_price&quot;</span>] = Convert.ToDecimal(excelDr[<span class="string">&quot;金额&quot;</span>].ToString());</span><br><span class="line">                dr[<span class="string">&quot;user_date&quot;</span>] = DateTime.ParseExact(excelDr[<span class="string">&quot;时间&quot;</span>].ToString(), <span class="string">&quot;yyyy-MM-dd&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">                excelDr.Delete();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//新增</span></span><br><span class="line">        <span class="keyword">foreach</span>(DataRow excelDr <span class="keyword">in</span> excelDt.Rows)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (excelDr.RowState == DataRowState.Deleted)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            DataRow newRow = dt.NewRow();</span><br><span class="line">            newRow[<span class="string">&quot;user_name&quot;</span>] = excelDr[<span class="string">&quot;姓名&quot;</span>].ToString();</span><br><span class="line">            newRow[<span class="string">&quot;user_price&quot;</span>] = Convert.ToDecimal(excelDr[<span class="string">&quot;金额&quot;</span>].ToString());</span><br><span class="line">            newRow[<span class="string">&quot;user_date&quot;</span>] = DateTime.ParseExact(excelDr[<span class="string">&quot;时间&quot;</span>].ToString(), <span class="string">&quot;yyyy-MM-dd&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">            dt.Rows.Add(newRow);</span><br><span class="line">        &#125;</span><br><span class="line">        adapter.Update(dt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DataTable <span class="title">find</span>(<span class="params"><span class="built_in">string</span> user_name</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    DataTable excelDt = excel.Clone();</span><br><span class="line">    <span class="keyword">foreach</span> (DataRow dr <span class="keyword">in</span> excel.Rows)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dr[<span class="string">&quot;姓名&quot;</span>].ToString() == user_name)</span><br><span class="line">        &#123;</span><br><span class="line">            excelDt.Rows.Add(dr.ItemArray);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> excelDt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读取csv格式文件，使用list修改数据库"><a href="#读取csv格式文件，使用list修改数据库" class="headerlink" title="读取csv格式文件，使用list修改数据库"></a>读取csv格式文件，使用list修改数据库</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> filePath = <span class="string">&quot;C:\\Users\\baizh\\Desktop\\test_user.csv&quot;</span>;</span><br><span class="line"><span class="built_in">string</span>[] user_names = &#123; <span class="string">&quot;杨怂蛋&quot;</span>, <span class="string">&quot;杨无语&quot;</span>, <span class="string">&quot;杨难受&quot;</span>, <span class="string">&quot;杨回忆&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> reader = <span class="keyword">new</span> StreamReader(filePath, Encoding.Default))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> csv = <span class="keyword">new</span> CsvReader(reader, CultureInfo.InvariantCulture))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> items = csv.GetRecords&lt;Item&gt;().ToList();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">string</span> user_name <span class="keyword">in</span> user_names)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">using</span> (MySqlConnection myconn = <span class="keyword">new</span> MySqlConnection(connectionString))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">string</span> sql = <span class="string">&quot;select * from test_user where user_name=@user_name&quot;</span>;</span><br><span class="line">                MySqlCommand command = <span class="keyword">new</span> MySqlCommand(sql, myconn);</span><br><span class="line">                command.Parameters.AddWithValue(<span class="string">&quot;@user_name&quot;</span>, user_name);</span><br><span class="line">                MySqlDataAdapter adapter = <span class="keyword">new</span> MySqlDataAdapter(command);</span><br><span class="line">                MySqlCommandBuilder cb = <span class="keyword">new</span> MySqlCommandBuilder(adapter);</span><br><span class="line"></span><br><span class="line">                myconn.Open();</span><br><span class="line"></span><br><span class="line">                DataTable dt = <span class="keyword">new</span> DataTable();</span><br><span class="line">                adapter.Fill(dt);</span><br><span class="line">                <span class="keyword">var</span> res = (<span class="keyword">from</span> item <span class="keyword">in</span> items</span><br><span class="line">                           <span class="keyword">where</span> item.user_name == user_name</span><br><span class="line">                           <span class="keyword">select</span> item).ToList();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//更新</span></span><br><span class="line">                <span class="keyword">foreach</span> (DataRow dr <span class="keyword">in</span> dt.Rows)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">var</span> item2 = res.FirstOrDefault(p =&gt; <span class="built_in">decimal</span>.Compare(p.user_price, Convert.ToDecimal(dr[<span class="string">&quot;user_price&quot;</span>].ToString())) == <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span> (item2 == <span class="literal">null</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    dr[<span class="string">&quot;user_price&quot;</span>] = item2.user_price;</span><br><span class="line">                    dr[<span class="string">&quot;user_date&quot;</span>] = item2.user_date;</span><br><span class="line">                    res.Remove(item2);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//新增</span></span><br><span class="line">                <span class="keyword">foreach</span> (Item item <span class="keyword">in</span> res)</span><br><span class="line">                &#123;</span><br><span class="line">                    DataRow newDr = dt.NewRow();</span><br><span class="line">                    newDr[<span class="string">&quot;user_name&quot;</span>] = item.user_name;</span><br><span class="line">                    newDr[<span class="string">&quot;user_price&quot;</span>] = item.user_price;</span><br><span class="line">                    newDr[<span class="string">&quot;user_date&quot;</span>] = item.user_date;</span><br><span class="line">                    dt.Rows.Add(newDr);</span><br><span class="line">                &#125;</span><br><span class="line">                adapter.Update(dt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术连连看 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ado.net </tag>
            
            <tag> c# </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开心往前飞</title>
      <link href="/2023/02/16/%E5%BC%80%E5%BF%83%E5%BE%80%E5%89%8D%E9%A3%9E/"/>
      <url>/2023/02/16/%E5%BC%80%E5%BF%83%E5%BE%80%E5%89%8D%E9%A3%9E/</url>
      
        <content type="html"><![CDATA[<h3 id="开心往前飞"><a href="#开心往前飞" class="headerlink" title=" 开心往前飞"></a><center> 开心往前飞</center></h3><center>我唤醒大海，唤醒山脉</center><center>我唤醒沙漠处处充满色彩美丽的地方</center><center>开心往前飞</center><center>就算有一万公里一吨行李</center><center>我们不放弃前进需要勇气一直往前飞</center><center>最重要开心就好</center><center>忘记烦恼</center><center>宇宙很大 任飞翔</center><center>满载欢乐回航</center><center>闯一闯</center><center>让我们闯一闯</center><center>我们志气要比天还高</center><center>云啊</center><center>轻轻飘过来梦中轮廓一点点透露出来</center><center>飞吧飞吧</center><center>飞过黎明和夜晚 啦啦啦啦</center><center>风啊 轻轻吹过来</center><center>梦想翅膀流星空中划过</center><center>穿越时空</center><center>回到那梦想的地方</center>]]></content>
      
      
      <categories>
          
          <category> 歌词本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开心往前飞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>young for you</title>
      <link href="/2023/02/16/young-for-you/"/>
      <url>/2023/02/16/young-for-you/</url>
      
        <content type="html"><![CDATA[<h3 id="young-for-you"><a href="#young-for-you" class="headerlink" title=" young for you "></a><center> young for you </center></h3><center> Sunday's coming i wanna drive my car</center><center>周日就要到了，我想开车去你的公寓</center><center>to your apartment with a present like a star</center><center>带着晨星般的礼物</center><center>forecaster said the weathers may be rainy hard</center><center>预报说那天将会下大雨</center><center>but i know the sun will shine for us</center><center>但是我知道阳光会为我们闪耀</center><center>oh lazy seagull fly me from the dark</center><center>慵懒的海鸥带我飞出黑暗</center><center>i dress my jeans and feed my monkey banana</center><center>我穿着我的牛仔裤，喂我的猴子吃香蕉</center><center>then i think my age how old,skyline how far</center><center>那时我在想我有多大，还有地平线到底有多远</center><center>where we need each other in california</center><center>在加利福尼亚州我们彼此需要</center><center>you show me your body before night comes down</center><center>在夜幕降临前你向我展现你的 身姿</center><center>i touch your face and promise to stay ever-young</center><center>我抚摸你的 脸庞，许诺我们永远这样年轻</center><center>on this ivory beach we kissed so long</center><center>在这象牙色的海滩上我们长吻</center><center>it seems that passion's never gone</center><center>仿佛激情永不消退</center><center>you sing me your melody and i feel so please</center><center>你为我唱你的旋律，我感到如此的舒适</center><center>i want you to want me to keep your dream</center><center>我渴望你也想要我守护你的梦想</center><center>together we'll run wild by a summer symphony</center><center>我们在夏季的交响乐中肆意奔跑</center><center>this is what we enjoyed not a fantasy</center><center>这是我们的喜悦而并非幻想</center><center>the tin-man's surfing i wanna try my luck</center><center>我想尝试冲浪</center><center>to the top of tide rip like just have some drugs</center><center>像服了兴奋剂般冲上浪尖</center><center>i know you have no blame for my proud moonish heart</center><center>我知道你对我骄傲易变的心 不会有任何责备</center><center>welcome to the golden beatnik park</center><center>欢迎来到比特尼克一代的黄金花园</center><center>oh diamond seashore drag me from the yard</center><center>钻石般的海岸将我拉离花院</center><center>incredible sunward i watch as you're in photograph</center><center>我难以置信的朝着太阳看你的照片</center><center>for camera your smile's so sweet,palm trees' so lush</center><center>画面中你的微笑如此甜美，棕榈树如此青翠。</center><center>would you believe my honey it's california</center><center>你相信么，我的甜心，这就是加利福尼亚</center><center>you show me your body before night comes down</center><center>在夜幕降临前你向我展现你的身姿</center><center>i touch your face and promise to stay ever-young</center><center>我抚摸你的脸庞，承诺永远青春</center><center>on this ivory beach we kissed so long</center><center>在这象牙色的海滩上我们久久拥吻</center><center>it seems that passion's never gone</center><center>仿佛激情永不消逝</center><center>you sing me your melody and i feel so please</center><center>你为我唱出自己的旋律，我感到如此的愉悦</center><center>i want you to want me to keep your dream</center><center>我渴望你也想要我守护你的梦想</center><center>together we'll run wild by a summer symphony</center><center>我们在夏季的交响中狂野的奔跑</center><center>this is what we enjoyed not a fantasy  </center><center>这是我们的喜悦而非幻想</center>]]></content>
      
      
      <categories>
          
          <category> 歌词本 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于本博客所使用音乐播放器</title>
      <link href="/2023/02/15/%E5%85%B3%E4%BA%8E%E6%9C%AC%E5%8D%9A%E5%AE%A2%E6%89%80%E4%BD%BF%E7%94%A8%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/"/>
      <url>/2023/02/15/%E5%85%B3%E4%BA%8E%E6%9C%AC%E5%8D%9A%E5%AE%A2%E6%89%80%E4%BD%BF%E7%94%A8%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p> 博客所使用的是<code> hexo-tag-aplayer</code> 插件</p><p>github传送门：<a href="https://github.com/MoePlayer/hexo-tag-aplayer">这里</a></p><p>使用方法：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&lt;!-- 简单示例 (id, server, type)  --&gt;</span><br><span class="line">&#123;% meting &quot;60198&quot; &quot;netease&quot; &quot;playlist&quot; %&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 进阶示例 --&gt;</span><br><span class="line">&#123;% meting &quot;60198&quot; &quot;netease&quot; &quot;playlist&quot; &quot;autoplay&quot; &quot;mutex:false&quot; &quot;listmaxheight:340px&quot; &quot;preload:none&quot; &quot;theme:#ad7a86&quot;%&#125;</span><br></pre></td></tr></table></figure><p>有关选项：</p><table><thead><tr><th align="left">选项</th><th align="left">默认值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">id</td><td align="left">必须值</td><td align="left">歌曲 id &#x2F; 播放列表 id &#x2F; 相册 id &#x2F; 搜索关键字</td></tr><tr><td align="left">server</td><td align="left">必须值</td><td align="left">音乐平台: netease, tencent, kugou, xiami, baidu</td></tr><tr><td align="left">type</td><td align="left">必须值</td><td align="left">song, playlist, album, search, artist</td></tr><tr><td align="left">fixed</td><td align="left">false</td><td align="left">开启固定模式</td></tr><tr><td align="left">mini</td><td align="left">false</td><td align="left">开启迷你模式</td></tr><tr><td align="left">loop</td><td align="left">all</td><td align="left">列表循环模式：all, one,none</td></tr><tr><td align="left">order</td><td align="left">list</td><td align="left">列表播放模式： list, random</td></tr><tr><td align="left">volume</td><td align="left">0.7</td><td align="left">播放器音量</td></tr><tr><td align="left">lrctype</td><td align="left">0</td><td align="left">歌词格式类型</td></tr><tr><td align="left">listfolded</td><td align="left">false</td><td align="left">指定音乐播放列表是否折叠</td></tr><tr><td align="left">storagename</td><td align="left">metingjs</td><td align="left">LocalStorage 中存储播放器设定的键名</td></tr><tr><td align="left">autoplay</td><td align="left">true</td><td align="left">自动播放，移动端浏览器暂时不支持此功能</td></tr><tr><td align="left">mutex</td><td align="left">true</td><td align="left">该选项开启时，如果同页面有其他 aplayer 播放，该播放器会暂停</td></tr><tr><td align="left">listmaxheight</td><td align="left">340px</td><td align="left">播放列表的最大长度</td></tr><tr><td align="left">preload</td><td align="left">auto</td><td align="left">音乐文件预载入模式，可选项： none, metadata, auto</td></tr><tr><td align="left">theme</td><td align="left">#ad7a86</td><td align="left">播放器风格色彩设置</td></tr></tbody></table><p>如需在全局实现播放器，需更改主题配置文件<code>_config.yml</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="comment"># - &lt;link rel=&quot;stylesheet&quot; href=&quot;/xxx.css&quot;&gt;</span></span><br><span class="line"><span class="comment"># 以下代码调整全局播放器的收回方式，只留下侧边箭头</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">&#x27;&lt;style type=&quot;text/css&quot;&gt;.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body&#123;left:-66px!important&#125;.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover&#123;left:0!important&#125;&lt;/style&gt;&#x27;</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">    <span class="comment"># - &lt;script src=&quot;xxxx&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment"># 以下代码放开后会全局渲染音乐播放器</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">&lt;div</span> <span class="string">class=&quot;aplayer</span> <span class="literal">no</span><span class="string">-destroy&quot;</span> <span class="string">data-id=&quot;60198&quot;</span> <span class="string">data-server=&quot;netease&quot;</span> <span class="string">data-type=&quot;playlist&quot;</span> <span class="string">data-fixed=&quot;true&quot;</span> <span class="string">data-autoplay=&quot;true&quot;&gt;</span> <span class="string">&lt;/div&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在单页面显示播放器时，需在文章<code>front-matter</code>里设置</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">aplayer: true</span><br></pre></td></tr></table></figure><p>否则无法正确显示</p><hr><p><strong>THE END</strong></p>]]></content>
      
      
      <categories>
          
          <category> 技术连连看 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字典 </tag>
            
            <tag> 音乐播放器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL语法</title>
      <link href="/2023/02/14/MySQL%E8%AF%AD%E6%B3%95/"/>
      <url>/2023/02/14/MySQL%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL数据库的基本操作"><a href="#MySQL数据库的基本操作" class="headerlink" title="MySQL数据库的基本操作"></a>MySQL数据库的基本操作</h2><h3 id="MySQL-连接数据库"><a href="#MySQL-连接数据库" class="headerlink" title="MySQL 连接数据库"></a>MySQL 连接数据库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br><span class="line">Enter password:******</span><br></pre></td></tr></table></figure><h3 id="MySQL-退出数据库"><a href="#MySQL-退出数据库" class="headerlink" title="MySQL 退出数据库"></a>MySQL 退出数据库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure><h3 id="MySQL查看数据库"><a href="#MySQL查看数据库" class="headerlink" title="MySQL查看数据库"></a>MySQL查看数据库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW DATABASES [LIKE &#x27;数据库名&#x27;];</span><br></pre></td></tr></table></figure><p>语法说明如下：</p><ul><li>LIKE 从句是可选项，用于匹配指定的数据库名称。LIKE 从句可以部分匹配，也可以完全匹配。</li><li>数据库名由单引号<code>&#39; &#39;</code>包围。</li></ul><h3 id="MySQL-创建数据库"><a href="#MySQL-创建数据库" class="headerlink" title="MySQL 创建数据库"></a>MySQL 创建数据库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE [IF NOT EXISTS] &lt;数据库名&gt;</span><br><span class="line">[[DEFAULT] CHARACTER SET &lt;字符集名&gt;] </span><br><span class="line">[[DEFAULT] COLLATE &lt;校对规则名&gt;];</span><br></pre></td></tr></table></figure><p><code>[ ]</code>中的内容是可选的。语法说明如下：</p><ul><li>&lt;数据库名&gt;：创建数据库的名称。MySQL 的数据存储区将以目录方式表示 MySQL 数据库，因此数据库名称必须符合操作系统的文件夹命名规则，不能以数字开头，尽量要有实际意义。注意在 MySQL 中不区分大小写。</li><li>IF NOT EXISTS：在创建数据库之前进行判断，只有该数据库目前尚不存在时才能执行操作。此选项可以用来避免数据库已经存在而重复创建的错误。</li><li>[DEFAULT] CHARACTER SET：指定数据库的字符集。指定字符集的目的是为了避免在数据库中存储的数据出现乱码的情况。如果在创建数据库时不指定字符集，那么就使用系统的默认字符集。</li><li>[DEFAULT] COLLATE：指定字符集的默认校对规则。</li></ul><h3 id="MySQL-修改数据库"><a href="#MySQL-修改数据库" class="headerlink" title="MySQL 修改数据库"></a>MySQL 修改数据库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER DATABASE [数据库名] &#123; </span><br><span class="line">[ DEFAULT ] CHARACTER SET &lt;字符集名&gt; |</span><br><span class="line">[ DEFAULT ] COLLATE &lt;校对规则名&gt;&#125;</span><br></pre></td></tr></table></figure><p>语法说明如下：</p><ul><li>ALTER DATABASE 用于更改数据库的全局特性。</li><li>使用 ALTER DATABASE 需要获得数据库 ALTER 权限。</li><li>数据库名称可以忽略，此时语句对应于默认数据库。</li><li>CHARACTER SET 子句用于更改默认的数据库字符集。</li></ul><h3 id="MySQL-删除数据库"><a href="#MySQL-删除数据库" class="headerlink" title="MySQL 删除数据库"></a>MySQL 删除数据库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP DATABASE [ IF EXISTS ] &lt;数据库名&gt;</span><br></pre></td></tr></table></figure><p>语法说明如下：</p><ul><li>&lt;数据库名&gt;：指定要删除的数据库名。</li><li>IF EXISTS：用于防止当数据库不存在时发生错误。</li><li>DROP DATABASE：删除数据库中的所有表格并同时删除数据库。使用此语句时要非常小心，以免错误删除。如果要使用 DROP DATABASE，需要获得数据库 DROP 权限。</li></ul><h3 id="MySQL-选择数据库"><a href="#MySQL-选择数据库" class="headerlink" title="MySQL 选择数据库"></a>MySQL 选择数据库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">USE &lt;数据库名&gt;</span><br></pre></td></tr></table></figure><p>该语句可以通知 MySQL 把<code>&lt;数据库名&gt;</code>所指示的数据库作为当前数据库。该数据库保持为默认数据库，直到语段的结尾，或者直到遇见一个不同的 USE 语句。 只有使用 USE 语句来指定某个数据库作为当前数据库之后，才能对该数据库及其存储的数据对象执行操作。</p><h3 id="MySQL注释"><a href="#MySQL注释" class="headerlink" title="MySQL注释"></a>MySQL注释</h3><h4 id="MySQL-单行注释"><a href="#MySQL-单行注释" class="headerlink" title="MySQL 单行注释"></a>MySQL 单行注释</h4><p>单行注释可以使用<code>#</code>注释符，<code>#</code>注释符后直接加注释内容。格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#注释内容</span><br></pre></td></tr></table></figure><h4 id="MySQL-多行注释"><a href="#MySQL-多行注释" class="headerlink" title="MySQL 多行注释"></a>MySQL 多行注释</h4><p>多行注释使用<code>/* */</code>注释符。<code>/*</code>用于注释内容的开头，<code>*/</code>用于注释内容的结尾。多行注释格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">  第一行注释内容</span><br><span class="line">  第二行注释内容</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h2 id="MySQL-数据类型和存储引擎"><a href="#MySQL-数据类型和存储引擎" class="headerlink" title="MySQL 数据类型和存储引擎"></a>MySQL 数据类型和存储引擎</h2><h3 id="MySQL-整数类型"><a href="#MySQL-整数类型" class="headerlink" title="MySQL 整数类型"></a>MySQL 整数类型</h3><table><thead><tr><th>类型名称</th><th>说明</th><th>存储需求</th></tr></thead><tbody><tr><td>TINYINT</td><td>-128〜127</td><td>1个字节</td></tr><tr><td>SMALLINT</td><td>-32768〜32767</td><td>2个宇节</td></tr><tr><td>MEDIUMINT</td><td>-8388608〜8388607</td><td>3个字节</td></tr><tr><td>INT (INTEGHR)</td><td>-2147483648〜2147483647</td><td>4个字节</td></tr><tr><td>BIGINT</td><td>-9223372036854775808〜9223372036854775807</td><td>8个字节</td></tr></tbody></table><h3 id="MySQL-小数类型"><a href="#MySQL-小数类型" class="headerlink" title="MySQL 小数类型"></a>MySQL 小数类型</h3><table><thead><tr><th>类型名称</th><th>说明</th><th>存储需求</th></tr></thead><tbody><tr><td>FLOAT</td><td>单精度浮点数</td><td>4 个字节</td></tr><tr><td>DOUBLE</td><td>双精度浮点数</td><td>8 个字节</td></tr><tr><td>DECIMAL (M, D)，DEC</td><td>压缩的“严格”定点数</td><td>M+2 个字节</td></tr></tbody></table><h3 id="MySQL-日期和时间类型"><a href="#MySQL-日期和时间类型" class="headerlink" title="MySQL 日期和时间类型"></a>MySQL 日期和时间类型</h3><table><thead><tr><th>类型名称</th><th>日期格式</th><th>日期范围</th><th>存储需求</th></tr></thead><tbody><tr><td>YEAR</td><td>YYYY</td><td>1901 ~ 2155</td><td>1 个字节</td></tr><tr><td>TIME</td><td>HH:MM:SS</td><td>-838:59:59 ~ 838:59:59</td><td>3 个字节</td></tr><tr><td>DATE</td><td>YYYY-MM-DD</td><td>1000-01-01 ~ 9999-12-3</td><td>3 个字节</td></tr><tr><td>DATETIME</td><td>YYYY-MM-DD HH:MM:SS</td><td>1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</td><td>8 个字节</td></tr><tr><td>TIMESTAMP</td><td>YYYY-MM-DD HH:MM:SS</td><td>1980-01-01 00:00:01 UTC ~ 2040-01-19 03:14:07 UTC</td><td>4 个字节</td></tr></tbody></table><h3 id="MySQL-字符串类型"><a href="#MySQL-字符串类型" class="headerlink" title="MySQL 字符串类型"></a>MySQL 字符串类型</h3><table><thead><tr><th>类型名称</th><th>说明</th><th>存储需求</th></tr></thead><tbody><tr><td>CHAR(M)</td><td>固定长度非二进制字符串</td><td>M 字节，1&lt;&#x3D;M&lt;&#x3D;255</td></tr><tr><td>VARCHAR(M)</td><td>变长非二进制字符串</td><td>L+1字节，在此，L&lt; &#x3D; M和 1&lt;&#x3D;M&lt;&#x3D;255</td></tr><tr><td>TINYTEXT</td><td>非常小的非二进制字符串</td><td>L+1字节，在此，L&lt;2^8</td></tr><tr><td>TEXT</td><td>小的非二进制字符串</td><td>L+2字节，在此，L&lt;2^16</td></tr><tr><td>MEDIUMTEXT</td><td>中等大小的非二进制字符串</td><td>L+3字节，在此，L&lt;2^24</td></tr><tr><td>LONGTEXT</td><td>大的非二进制字符串</td><td>L+4字节，在此，L&lt;2^32</td></tr><tr><td>ENUM</td><td>枚举类型，只能有一个枚举字符串值</td><td>1或2个字节，取决于枚举值的数目 (最大值为65535)</td></tr><tr><td>SET</td><td>一个设置，字符串对象可以有零个或 多个SET成员</td><td>1、2、3、4或8个字节，取决于集合 成员的数量（最多64个成员）</td></tr></tbody></table><h3 id="MySQL-二进制类型"><a href="#MySQL-二进制类型" class="headerlink" title="MySQL 二进制类型"></a>MySQL 二进制类型</h3><table><thead><tr><th>类型名称</th><th>说明</th><th>存储需求</th></tr></thead><tbody><tr><td>BIT(M)</td><td>位字段类型</td><td>大约 (M+7)&#x2F;8 字节</td></tr><tr><td>BINARY(M)</td><td>固定长度二进制字符串</td><td>M 字节</td></tr><tr><td>VARBINARY (M)</td><td>可变长度二进制字符串</td><td>M+1 字节</td></tr><tr><td>TINYBLOB (M)</td><td>非常小的BLOB</td><td>L+1 字节，在此，L&lt;2^8</td></tr><tr><td>BLOB (M)</td><td>小 BLOB</td><td>L+2 字节，在此，L&lt;2^16</td></tr><tr><td>MEDIUMBLOB (M)</td><td>中等大小的BLOB</td><td>L+3 字节，在此，L&lt;2^24</td></tr><tr><td>LONGBLOB (M)</td><td>非常大的BLOB</td><td>L+4 字节，在此，L&lt;2^32</td></tr></tbody></table><h2 id="MySQL-数据表的基本操作"><a href="#MySQL-数据表的基本操作" class="headerlink" title="MySQL 数据表的基本操作"></a>MySQL 数据表的基本操作</h2><h3 id="MySQL-创建数据表"><a href="#MySQL-创建数据表" class="headerlink" title="MySQL 创建数据表"></a>MySQL 创建数据表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &lt;表名&gt; ([表定义选项])[表选项][分区选项];</span><br></pre></td></tr></table></figure><p>其中，<code>[表定义选项]</code>的格式为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;列名1&gt; &lt;类型1&gt; [,…] &lt;列名n&gt; &lt;类型n&gt;</span><br></pre></td></tr></table></figure><p>CREATE TABLE 语句的主要语法及使用说明如下：</p><ul><li>CREATE TABLE：用于创建给定名称的表，必须拥有表CREATE的权限。</li><li>&lt;表名&gt;：指定要创建表的名称，在 CREATE TABLE 之后给出，必须符合标识符命名规则。表名称被指定为 db_name.tbl_name，以便在特定的数据库中创建表。无论是否有当前数据库，都可以通过这种方式创建。在当前数据库中创建表时，可以省略 db-name。如果使用加引号的识别名，则应对数据库和表名称分别加引号。例如，’mydb’.’mytbl’ 是合法的，但 ‘mydb.mytbl’ 不合法。</li><li>&lt;表定义选项&gt;：表创建定义，由列名（col_name）、列的定义（column_definition）以及可能的空值说明、完整性约束或表索引组成。</li><li>默认的情况是，表被创建到当前的数据库中。若表已存在、没有当前数据库或者数据库不存在，则会出现错误。</li></ul><h3 id="MySQL-修改数据表"><a href="#MySQL-修改数据表" class="headerlink" title="MySQL 修改数据表"></a>MySQL 修改数据表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &lt;表名&gt; [修改选项]</span><br></pre></td></tr></table></figure><p>修改选项的语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; ADD COLUMN &lt;列名&gt; &lt;类型&gt;</span><br><span class="line">| CHANGE COLUMN &lt;旧列名&gt; &lt;新列名&gt; &lt;新列类型&gt;</span><br><span class="line">| ALTER COLUMN &lt;列名&gt; &#123; SET DEFAULT &lt;默认值&gt; | DROP DEFAULT &#125;</span><br><span class="line">| MODIFY COLUMN &lt;列名&gt; &lt;类型&gt;</span><br><span class="line">| DROP COLUMN &lt;列名&gt;</span><br><span class="line">| RENAME TO &lt;新表名&gt;</span><br><span class="line">| CHARACTER SET &lt;字符集名&gt;</span><br><span class="line">| COLLATE &lt;校对规则名&gt; &#125;</span><br></pre></td></tr></table></figure><h4 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名"></a>修改表名</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &lt;旧表名&gt; RENAME [TO] &lt;新表名&gt;；</span><br></pre></td></tr></table></figure><h4 id="修改表字符集"><a href="#修改表字符集" class="headerlink" title="修改表字符集"></a>修改表字符集</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 [DEFAULT] CHARACTER SET &lt;字符集名&gt; [DEFAULT] COLLATE &lt;校对规则名&gt;;</span><br></pre></td></tr></table></figure><h3 id="MySQL-修改-x2F-删除字段"><a href="#MySQL-修改-x2F-删除字段" class="headerlink" title="MySQL 修改&#x2F;删除字段"></a>MySQL 修改&#x2F;删除字段</h3><h4 id="修改字段名称"><a href="#修改字段名称" class="headerlink" title="修改字段名称"></a>修改字段名称</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &lt;表名&gt; CHANGE &lt;旧字段名&gt; &lt;新字段名&gt; &lt;新数据类型&gt;；</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>旧字段名：指修改前的字段名；</li><li>新字段名：指修改后的字段名；</li><li>新数据类型：指修改后的数据类型，如果不需要修改字段的数据类型，可以将新数据类型设置成与原来一样，但数据类型不能为空。</li></ul><h4 id="修改字段数据类型"><a href="#修改字段数据类型" class="headerlink" title="修改字段数据类型"></a>修改字段数据类型</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &lt;表名&gt; MODIFY &lt;字段名&gt; &lt;数据类型&gt;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>表名：指要修改数据类型的字段所在表的名称；</li><li>字段名：指需要修改的字段；</li><li>数据类型：指修改后字段的新数据类型。</li></ul><h4 id="删除字段"><a href="#删除字段" class="headerlink" title="删除字段"></a>删除字段</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &lt;表名&gt; DROP &lt;字段名&gt;；</span><br></pre></td></tr></table></figure><h3 id="MySQL-删除数据表"><a href="#MySQL-删除数据表" class="headerlink" title="MySQL 删除数据表"></a>MySQL 删除数据表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE [IF EXISTS] 表名1 [ ,表名2, 表名3 ...]</span><br></pre></td></tr></table></figure><p>对语法格式的说明如下：</p><ul><li><code>表名1, 表名2, 表名3 ...</code>表示要被删除的数据表的名称。DROP TABLE 可以同时删除多个表，只要将表名依次写在后面，相互之间用逗号隔开即可。</li><li>IF EXISTS 用于在删除数据表之前判断该表是否存在。如果不加 IF EXISTS，当数据表不存在时 MySQL 将提示错误，中断 SQL 语句的执行；加上 IF EXISTS 后，当数据表不存在时 SQL 语句可以顺利执行，但是会发出警告（warning）。</li></ul><h3 id="MySQL-查看表结构命令"><a href="#MySQL-查看表结构命令" class="headerlink" title="MySQL 查看表结构命令"></a>MySQL 查看表结构命令</h3><h4 id="DESCRIBE：以表格的形式展示表结构"><a href="#DESCRIBE：以表格的形式展示表结构" class="headerlink" title="DESCRIBE：以表格的形式展示表结构"></a>DESCRIBE：以表格的形式展示表结构</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DESCRIBE &lt;表名&gt;; </span><br><span class="line">或简写为 </span><br><span class="line">DESC &lt;表名&gt;;</span><br></pre></td></tr></table></figure><h4 id="SHOW-CREATE-TABLE：以SQL语句的形式展示表结构"><a href="#SHOW-CREATE-TABLE：以SQL语句的形式展示表结构" class="headerlink" title="SHOW CREATE TABLE：以SQL语句的形式展示表结构"></a>SHOW CREATE TABLE：以SQL语句的形式展示表结构</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW CREATE TABLE &lt;表名&gt;;</span><br></pre></td></tr></table></figure><h3 id="MySQL-数据表添加字段"><a href="#MySQL-数据表添加字段" class="headerlink" title="MySQL 数据表添加字段"></a>MySQL 数据表添加字段</h3><h4 id="在末尾添加字段"><a href="#在末尾添加字段" class="headerlink" title="在末尾添加字段"></a>在末尾添加字段</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &lt;表名&gt; ADD &lt;新字段名&gt;&lt;数据类型&gt;[约束条件];</span><br></pre></td></tr></table></figure><p>对语法格式的说明如下：                    </p><ul><li>&lt;表名&gt; 为数据表的名字；</li><li>&lt;新字段名&gt; 为所要添加的字段的名字；</li><li>&lt;数据类型&gt; 为所要添加的字段能存储数据的数据类型；</li><li>[约束条件] 是可选的，用来对添加的字段进行约束。</li></ul><h4 id="在开头添加字段"><a href="#在开头添加字段" class="headerlink" title="在开头添加字段"></a>在开头添加字段</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &lt;表名&gt; ADD &lt;新字段名&gt; &lt;数据类型&gt; [约束条件] FIRST;</span><br></pre></td></tr></table></figure><h4 id="在中间位置添加字段"><a href="#在中间位置添加字段" class="headerlink" title="在中间位置添加字段"></a>在中间位置添加字段</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &lt;表名&gt; ADD &lt;新字段名&gt; &lt;数据类型&gt; [约束条件] AFTER &lt;已经存在的字段名&gt;;</span><br></pre></td></tr></table></figure><h2 id="MySQL约束、函数"><a href="#MySQL约束、函数" class="headerlink" title="MySQL约束、函数"></a>MySQL约束、函数</h2><h3 id="在创建表时设置主键约束"><a href="#在创建表时设置主键约束" class="headerlink" title="在创建表时设置主键约束"></a>在创建表时设置主键约束</h3><h4 id="设置单字段主键"><a href="#设置单字段主键" class="headerlink" title="设置单字段主键"></a>设置单字段主键</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;字段名&gt; &lt;数据类型&gt; PRIMARY KEY [默认值]</span><br></pre></td></tr></table></figure><h4 id="在创建表时设置联合主键"><a href="#在创建表时设置联合主键" class="headerlink" title="在创建表时设置联合主键"></a>在创建表时设置联合主键</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PRIMARY KEY [字段1，字段2，…,字段n]</span><br></pre></td></tr></table></figure><h4 id="在修改表时添加主键约束"><a href="#在修改表时添加主键约束" class="headerlink" title="在修改表时添加主键约束"></a>在修改表时添加主键约束</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &lt;数据表名&gt; ADD PRIMARY KEY(&lt;字段名&gt;);</span><br></pre></td></tr></table></figure><h4 id="删除主键约束"><a href="#删除主键约束" class="headerlink" title="删除主键约束"></a>删除主键约束</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &lt;数据表名&gt; DROP PRIMARY KEY;</span><br></pre></td></tr></table></figure><h3 id="MySQL-主键自增长"><a href="#MySQL-主键自增长" class="headerlink" title="MySQL 主键自增长"></a>MySQL 主键自增长</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字段名 数据类型 AUTO_INCREMENT</span><br></pre></td></tr></table></figure><ul><li>默认情况下，AUTO_INCREMENT 的初始值是 1，每新增一条记录，字段值自动加 1。</li><li>一个表中只能有一个字段使用 AUTO_INCREMENT 约束，且该字段必须有唯一索引，以避免序号重复（即为主键或主键的一部分）。</li><li>AUTO_INCREMENT 约束的字段必须具备 NOT NULL 属性。</li><li>AUTO_INCREMENT 约束的字段只能是整数类型（TINYINT、SMALLINT、INT、BIGINT 等）。</li><li>AUTO_INCREMENT 约束字段的最大值受该字段的数据类型约束，如果达到上限，AUTO_INCREMENT 就会失效。</li></ul><h3 id="MySQL-默认值"><a href="#MySQL-默认值" class="headerlink" title="MySQL 默认值"></a>MySQL 默认值</h3><h4 id="在创建表时设置默认值约束"><a href="#在创建表时设置默认值约束" class="headerlink" title="在创建表时设置默认值约束"></a>在创建表时设置默认值约束</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;字段名&gt; &lt;数据类型&gt; DEFAULT &lt;默认值&gt;;</span><br></pre></td></tr></table></figure><h4 id="在修改表时添加默认值约束"><a href="#在修改表时添加默认值约束" class="headerlink" title="在修改表时添加默认值约束"></a>在修改表时添加默认值约束</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &lt;数据表名&gt;</span><br><span class="line">CHANGE COLUMN &lt;字段名&gt; &lt;数据类型&gt; DEFAULT &lt;默认值&gt;;</span><br></pre></td></tr></table></figure><h4 id="删除默认值约束"><a href="#删除默认值约束" class="headerlink" title="删除默认值约束"></a>删除默认值约束</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &lt;数据表名&gt;</span><br><span class="line">CHANGE COLUMN &lt;字段名&gt; &lt;字段名&gt; &lt;数据类型&gt; DEFAULT NULL;</span><br></pre></td></tr></table></figure><h3 id="MySQL-非空约束"><a href="#MySQL-非空约束" class="headerlink" title="MySQL 非空约束"></a>MySQL 非空约束</h3><h3 id="在创建表时设置非空约束"><a href="#在创建表时设置非空约束" class="headerlink" title="在创建表时设置非空约束"></a>在创建表时设置非空约束</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;字段名&gt; &lt;数据类型&gt; NOT NULL;</span><br></pre></td></tr></table></figure><h3 id="在修改表时添加非空约束"><a href="#在修改表时添加非空约束" class="headerlink" title="在修改表时添加非空约束"></a>在修改表时添加非空约束</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &lt;数据表名&gt;</span><br><span class="line">CHANGE COLUMN &lt;字段名&gt;</span><br><span class="line">&lt;字段名&gt; &lt;数据类型&gt; NOT NULL;</span><br></pre></td></tr></table></figure><h4 id="删除非空约束"><a href="#删除非空约束" class="headerlink" title="删除非空约束"></a>删除非空约束</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &lt;数据表名&gt;</span><br><span class="line">CHANGE COLUMN &lt;字段名&gt; &lt;字段名&gt; &lt;数据类型&gt; NULL;</span><br></pre></td></tr></table></figure><h3 id="MySQL-查看表中的约束"><a href="#MySQL-查看表中的约束" class="headerlink" title="MySQL 查看表中的约束"></a>MySQL 查看表中的约束</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW CREATE TABLE &lt;数据表名&gt;;</span><br></pre></td></tr></table></figure><h3 id="MySQL-IN-和-NOT-IN用法详解"><a href="#MySQL-IN-和-NOT-IN用法详解" class="headerlink" title="MySQL IN 和 NOT IN用法详解"></a>MySQL IN 和 NOT IN用法详解</h3><p><a href="http://c.biancheng.net/mysql/">MySQL</a> 中的 IN 运算符用来判断表达式的值是否位于给出的列表中；如果是，返回值为 1，否则返回值为 0。</p><p>NOT IN 的作用和 IN 恰好相反，NOT IN 用来判断表达式的值是否不存在于给出的列表中；如果不是，返回值为 1，否则返回值为 0。</p><p>IN 和 NOT IN 的语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">expr IN ( value1, value2, value3 ... valueN )</span><br><span class="line">expr NOT IN ( value1, value2, value3 ... valueN )</span><br></pre></td></tr></table></figure><p>expr 表示要判断的表达式，value1, value2, value3 … valueN 表示列表中的值。MySQL 会将 expr 的值和列表中的值逐一对比。</p><h2 id="MySQL-操作表中数据"><a href="#MySQL-操作表中数据" class="headerlink" title="MySQL 操作表中数据"></a>MySQL 操作表中数据</h2><h3 id="MySQL-查询数据表"><a href="#MySQL-查询数据表" class="headerlink" title="MySQL 查询数据表"></a>MySQL 查询数据表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">&#123;* | &lt;字段列名&gt;&#125;</span><br><span class="line">[</span><br><span class="line">FROM &lt;表 1&gt;, &lt;表 2&gt;…</span><br><span class="line">[WHERE &lt;表达式&gt;</span><br><span class="line">[GROUP BY &lt;group by definition&gt;</span><br><span class="line">[HAVING &lt;expression&gt; [&#123;&lt;operator&gt; &lt;expression&gt;&#125;…]]</span><br><span class="line">[ORDER BY &lt;order by definition&gt;]</span><br><span class="line">[LIMIT[&lt;offset&gt;,] &lt;row count&gt;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>其中，各条子句的含义如下：</p><ul><li><code>&#123;*|&lt;字段列名&gt;&#125;</code>包含星号通配符的字段列表，表示所要查询字段的名称。</li><li><code>&lt;表 1&gt;，&lt;表 2&gt;…</code>，表 1 和表 2 表示查询数据的来源，可以是单个或多个。</li><li><code>WHERE &lt;表达式&gt;</code>是可选项，如果选择该项，将限定查询数据必须满足该查询条件。</li><li><code>GROUP BY&lt; 字段 &gt;</code>，该子句告诉 MySQL 如何显示查询出来的数据，并按照指定的字段分组。</li><li><code>[ORDER BY&lt; 字段 &gt;]</code>，该子句告诉 MySQL 按什么样的顺序显示查询出来的数据，可以进行的排序有升序（ASC）和降序（DESC），默认情况下是升序。</li><li><code>[LIMIT[&lt;offset&gt;，]&lt;row count&gt;]</code>，该子句告诉 MySQL 每次显示查询出来的数据条数。</li></ul><h3 id="MySQL-去重"><a href="#MySQL-去重" class="headerlink" title="MySQL 去重"></a>MySQL 去重</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT DISTINCT &lt;字段名&gt; FROM &lt;表名&gt;;</span><br></pre></td></tr></table></figure><p>其中，“字段名”为需要消除重复记录的字段名称，多个字段时用逗号隔开。</p><p>使用 DISTINCT 关键字时需要注意以下几点：</p><ul><li>DISTINCT 关键字只能在 SELECT 语句中使用。</li><li>在对一个或多个字段去重时，DISTINCT 关键字必须在所有字段的最前面。</li><li>如果 DISTINCT 关键字后有多个字段，则会对多个字段进行组合去重，也就是说，只有多个字段组合起来完全是一样的情况下才会被去重。</li></ul><h3 id="MySQL-设置别名"><a href="#MySQL-设置别名" class="headerlink" title="MySQL 设置别名"></a>MySQL 设置别名</h3><h4 id="为表指定别名"><a href="#为表指定别名" class="headerlink" title="为表指定别名"></a>为表指定别名</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;表名&gt; [AS] &lt;别名&gt;</span><br></pre></td></tr></table></figure><p>其中各子句的含义如下：</p><ul><li><code>&lt;表名&gt;</code>：数据库中存储的数据表的名称。</li><li><code>&lt;别名&gt;</code>：查询时指定的表的新名称。</li><li><code>AS</code>关键字可以省略，省略后需要将表名和别名用空格隔开。</li></ul><h4 id="为字段指定别名"><a href="#为字段指定别名" class="headerlink" title="为字段指定别名"></a>为字段指定别名</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;字段名&gt; [AS] &lt;别名&gt;</span><br></pre></td></tr></table></figure><p>其中，各子句的语法含义如下：</p><ul><li><code>&lt;字段名&gt;</code>：为数据表中字段定义的名称。</li><li><code>&lt;字段别名&gt;</code>：字段新的名称。</li><li><code>AS</code>关键字可以省略，省略后需要将字段名和别名用空格隔开。</li></ul><h3 id="MySQL-限制查询结果的条数"><a href="#MySQL-限制查询结果的条数" class="headerlink" title="MySQL 限制查询结果的条数"></a>MySQL 限制查询结果的条数</h3><h4 id="指定初始位置"><a href="#指定初始位置" class="headerlink" title="指定初始位置"></a>指定初始位置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LIMIT 初始位置，记录数</span><br></pre></td></tr></table></figure><h4 id="不指定初始位置"><a href="#不指定初始位置" class="headerlink" title="不指定初始位置"></a>不指定初始位置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LIMIT 记录数</span><br></pre></td></tr></table></figure><h4 id="LIMIT和OFFSET组合使用"><a href="#LIMIT和OFFSET组合使用" class="headerlink" title="LIMIT和OFFSET组合使用"></a>LIMIT和OFFSET组合使用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LIMIT 记录数 OFFSET 初始位置  （效果与指定初始位置相同）</span><br></pre></td></tr></table></figure><h3 id="MySQL-对查询结果排序"><a href="#MySQL-对查询结果排序" class="headerlink" title="MySQL 对查询结果排序"></a>MySQL 对查询结果排序</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ORDER BY &lt;字段名&gt; [ASC|DESC]</span><br></pre></td></tr></table></figure><p>语法说明如下。</p><ul><li>字段名：表示需要排序的字段名称，多个字段时用逗号隔开。</li><li>ASC|DESC：<code>ASC</code>表示字段按升序排序；<code>DESC</code>表示字段按降序排序。其中<code>ASC</code>为默认值。</li></ul><p>使用 ORDER BY 关键字应该注意以下几个方面：</p><ul><li>ORDER BY 关键字后可以跟子查询（关于子查询后面教程会详细讲解，这里了解即可）。</li><li>当排序的字段中存在空值时，ORDER BY 会将该空值作为最小值来对待。</li><li>ORDER BY 指定多个字段进行排序时，MySQL 会按照字段的顺序从左到右依次进行排序。</li></ul><h3 id="MySQL-条件查询"><a href="#MySQL-条件查询" class="headerlink" title="MySQL 条件查询"></a>MySQL 条件查询</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WHERE 查询条件</span><br></pre></td></tr></table></figure><p>查询条件可以是：</p><ul><li>带比较运算符和逻辑运算符的查询条件</li><li>带 BETWEEN AND 关键字的查询条件</li><li>带 IS NULL 关键字的查询条件</li><li>带 IN 关键字的查询条件</li><li>带 LIKE 关键字的查询条件</li></ul><h3 id="MySQL-模糊查询"><a href="#MySQL-模糊查询" class="headerlink" title="MySQL 模糊查询"></a>MySQL 模糊查询</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[NOT] LIKE  &#x27;字符串&#x27;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>NOT ：可选参数，字段中的内容与指定的字符串不匹配时满足条件。</li><li>字符串：指定用来匹配的字符串。“字符串”可以是一个很完整的字符串，也可以包含通配符。</li></ul><h4 id="带有“-”通配符的查询"><a href="#带有“-”通配符的查询" class="headerlink" title="带有“%”通配符的查询"></a>带有“%”通配符的查询</h4><p>“%”是 MySQL 中最常用的通配符，它能代表任何长度的字符串，字符串的长度可以为 0。例如，<code>a%b</code>表示以字母 a 开头，以字母 b 结尾的任意长度的字符串。该字符串可以代表 ab、acb、accb、accrb 等字符串。</p><h4 id="带有“-”通配符的查询-1"><a href="#带有“-”通配符的查询-1" class="headerlink" title="带有“_”通配符的查询"></a>带有“_”通配符的查询</h4><p>“_”只能代表单个字符，字符的长度不能为 0。例如，<code>a_b</code>可以代表 acb、adb、aub 等字符串。</p><h4 id="LIKE-区分大小写"><a href="#LIKE-区分大小写" class="headerlink" title="LIKE 区分大小写"></a>LIKE 区分大小写</h4><p>默认情况下，LIKE 关键字匹配字符的时候是不区分大小写的。如果需要区分大小写，可以加入 BINARY 关键字。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT name FROM tb_students_info WHERE name LIKE BINARY &#x27;t%&#x27;;</span><br></pre></td></tr></table></figure><h3 id="MySQL-范围查询"><a href="#MySQL-范围查询" class="headerlink" title="MySQL 范围查询"></a>MySQL 范围查询</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[NOT] BETWEEN 取值1 AND 取值2</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>NOT：可选参数，表示指定范围之外的值。如果字段值不满足指定范围内的值，则这些记录被返回。</li><li>取值1：表示范围的起始值。</li><li>取值2：表示范围的终止值。</li></ul><h3 id="MySQL-空值查询"><a href="#MySQL-空值查询" class="headerlink" title="MySQL 空值查询"></a>MySQL 空值查询</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IS [NOT] NULL</span><br></pre></td></tr></table></figure><p>其中，“NOT”是可选参数，表示字段值不是空值时满足条件。</p><h3 id="MySQL-分组查询"><a href="#MySQL-分组查询" class="headerlink" title="MySQL 分组查询"></a>MySQL 分组查询</h3><h4 id="GROUP-BY单独使用"><a href="#GROUP-BY单独使用" class="headerlink" title="GROUP BY单独使用"></a>GROUP BY单独使用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GROUP BY  &lt;字段名&gt;</span><br></pre></td></tr></table></figure><h4 id="GROUP-BY-与-GROUP-CONCAT"><a href="#GROUP-BY-与-GROUP-CONCAT" class="headerlink" title="GROUP BY 与 GROUP_CONCAT()"></a>GROUP BY 与 GROUP_CONCAT()</h4><p>GROUP BY 关键字可以和 GROUP_CONCAT() 函数一起使用。GROUP_CONCAT() 函数会把每个分组的字段值都显示出来。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT `sex`, GROUP_CONCAT(name) FROM tb_students_info </span><br><span class="line">GROUP BY sex;</span><br></pre></td></tr></table></figure><p>结果如下：</p><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+------+----------------------------+</span><br><span class="line">| sex  | GROUP_CONCAT(name)         |</span><br><span class="line">+------+----------------------------+</span><br><span class="line">| 女   | Henry,Jim,John,Thomas,Tom  |</span><br><span class="line">| 男   | Dany,Green,Jane,Lily,Susan |</span><br><span class="line">+------+----------------------------+</span><br></pre></td></tr></table></figure></blockquote><h4 id="GROUP-BY-与聚合函数"><a href="#GROUP-BY-与聚合函数" class="headerlink" title="GROUP BY 与聚合函数"></a>GROUP BY 与聚合函数</h4><p>聚合函数包括 COUNT()，SUM()，AVG()，MAX() 和 MIN()。其中，COUNT() 用来统计记录的条数；SUM() 用来计算字段值的总和；AVG() 用来计算字段值的平均值；MAX() 用来查询字段的最大值；MIN() 用来查询字段的最小值。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT sex,COUNT(sex) FROM tb_students_info </span><br><span class="line">GROUP BY sex;</span><br></pre></td></tr></table></figure><p>结果如下：</p><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+------+------------+</span><br><span class="line">| sex  | COUNT(sex) |</span><br><span class="line">+------+------------+</span><br><span class="line">| 女   |          5 |</span><br><span class="line">| 男   |          5 |</span><br><span class="line">+------+------------+</span><br></pre></td></tr></table></figure></blockquote><h3 id="MySQL-过滤分组"><a href="#MySQL-过滤分组" class="headerlink" title="MySQL 过滤分组"></a>MySQL 过滤分组</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HAVING &lt;查询条件&gt;</span><br></pre></td></tr></table></figure><p>HAVING 关键字和 WHERE 关键字都可以用来过滤数据，且 HAVING 支持 WHERE 关键字中所有的操作符和语法。</p><p>但是 WHERE 和 HAVING 关键字也存在以下几点差异：</p><ul><li>一般情况下，WHERE 用于过滤数据行，而 HAVING 用于过滤分组。</li><li>WHERE 查询条件中不可以使用聚合函数，而 HAVING 查询条件中可以使用聚合函数。</li><li>WHERE 在数据分组前进行过滤，而 HAVING 在数据分组后进行过滤 。</li><li>WHERE 针对数据库文件进行过滤，而 HAVING 针对查询结果进行过滤。也就是说，WHERE 根据数据表中的字段直接进行过滤，而 HAVING 是根据前面已经查询出的字段进行过滤。</li><li>WHERE 查询条件中不可以使用字段别名，而 HAVING 查询条件中可以使用字段别名。</li></ul><h3 id="MySQL-交叉连接"><a href="#MySQL-交叉连接" class="headerlink" title="MySQL 交叉连接"></a>MySQL 交叉连接</h3><p>交叉连接（CROSS JOIN）一般用来返回连接表的笛卡尔积。</p><p>交叉连接的语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT &lt;字段名&gt; FROM &lt;表1&gt; CROSS JOIN &lt;表2&gt; [WHERE子句]</span><br><span class="line">或</span><br><span class="line">SELECT &lt;字段名&gt; FROM &lt;表1&gt;, &lt;表2&gt; [WHERE子句] </span><br></pre></td></tr></table></figure><p>语法说明如下：</p><ul><li>字段名：需要查询的字段名称。</li><li>&lt;表1&gt;&lt;表2&gt;：需要交叉连接的表名。</li><li>WHERE 子句：用来设置交叉连接的查询条件。</li></ul><blockquote><h2 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h2><p>笛卡尔积（Cartesian product）是指两个集合 X 和 Y 的乘积。</p><p>例如，有 A 和 B 两个集合，它们的值如下：</p><p>A &#x3D; {1,2}<br>B &#x3D; {3,4,5}</p><p>集合 A×B 和 B×A 的结果集分别表示为：</p><p>A×B&#x3D;{(1,3), (1,4), (1,5), (2,3), (2,4), (2,5) };<br>B×A&#x3D;{(3,1), (3,2), (4,1), (4,2), (5,1), (5,2) };</p><p>以上 A×B 和 B×A 的结果就叫做两个集合的笛卡尔积。</p><p>并且，从以上结果我们可以看出：</p><ul><li>两个集合相乘，不满足交换率，即 A×B≠B×A。</li><li>A 集合和 B 集合的笛卡尔积是 A 集合的元素个数 × B 集合的元素个数。</li></ul><p>多表查询遵循的算法就是以上提到的笛卡尔积，表与表之间的连接可以看成是在做乘法运算。在实际应用中，应避免使用笛卡尔积，因为笛卡尔积中容易存在大量的不合理数据，简单来说就是容易导致查询结果重复、混乱。</p></blockquote><h3 id="MySQL-内连接"><a href="#MySQL-内连接" class="headerlink" title="MySQL 内连接"></a>MySQL 内连接</h3><p>内连接使用 <strong>INNER JOIN</strong> 关键字连接两张表，并使用 ON 子句来设置连接条件。如果没有连接条件，INNER JOIN 和 CROSS JOIN 在语法上是等同的，两者可以互换。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT &lt;字段名&gt; FROM &lt;表1&gt; INNER JOIN &lt;表2&gt; [ON子句]</span><br></pre></td></tr></table></figure><p>语法说明如下。</p><ul><li>字段名：需要查询的字段名称。</li><li>&lt;表1&gt;&lt;表2&gt;：需要内连接的表名。</li><li>INNER JOIN ：内连接中可以省略 INNER 关键字，只用关键字 JOIN。</li><li>ON 子句：用来设置内连接的连接条件。</li></ul><h3 id="MySQL-外连接"><a href="#MySQL-外连接" class="headerlink" title="MySQL 外连接"></a>MySQL 外连接</h3><h4 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT &lt;字段名&gt; FROM &lt;表1&gt; LEFT OUTER JOIN &lt;表2&gt; &lt;ON子句&gt;</span><br></pre></td></tr></table></figure><p>语法说明如下。</p><ul><li>字段名：需要查询的字段名称。</li><li>&lt;表1&gt;&lt;表2&gt;：需要左连接的表名。</li><li>LEFT OUTER JOIN：左连接中可以省略 OUTER 关键字，只使用关键字 LEFT JOIN。</li><li>ON 子句：用来设置左连接的连接条件，不能省略。</li></ul><p>上述语法中，“表1”为基表，“表2”为参考表。左连接查询时，可以查询出“表1”中的所有记录和“表2”中匹配连接条件的记录。如果“表1”的某行在“表2”中没有匹配行，那么在返回结果中，“表2”的字段值均为空值（NULL）。</p><h4 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT &lt;字段名&gt; FROM &lt;表1&gt; RIGHT OUTER JOIN &lt;表2&gt; &lt;ON子句&gt;</span><br></pre></td></tr></table></figure><p>语法说明如下。</p><ul><li>字段名：需要查询的字段名称。</li><li>&lt;表1&gt;&lt;表2&gt;：需要右连接的表名。</li><li>RIGHT OUTER JOIN：右连接中可以省略 OUTER 关键字，只使用关键字 RIGHT JOIN。</li><li>ON 子句：用来设置右连接的连接条件，不能省略。</li></ul><p>与左连接相反，右连接以“表2”为基表，“表1”为参考表。右连接查询时，可以查询出“表2”中的所有记录和“表1”中匹配连接条件的记录。如果“表2”的某行在“表1”中没有匹配行，那么在返回结果中，“表1”的字段值均为空值（NULL）。</p><h3 id="MySQL-子查询"><a href="#MySQL-子查询" class="headerlink" title="MySQL 子查询"></a>MySQL 子查询</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WHERE &lt;表达式&gt; &lt;操作符&gt; (子查询)</span><br></pre></td></tr></table></figure><p>其中，操作符可以是比较运算符和 IN、NOT IN、EXISTS、NOT EXISTS 等关键字。</p><p><strong>1）IN | NOT IN</strong></p><p>当表达式与子查询返回的结果集中的某个值相等时，返回 TRUE，否则返回 FALSE；若使用关键字 NOT，则返回值正好相反。</p><p><strong>2）EXISTS | NOT EXISTS</strong></p><p>用于判断子查询的结果集是否为空，若子查询的结果集不为空，返回 TRUE，否则返回 FALSE；若使用关键字 NOT，则返回的值正好相反。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT name FROM tb_students_info </span><br><span class="line">WHERE course_id IN (SELECT id FROM tb_course WHERE course_name = &#x27;Java&#x27;);</span><br></pre></td></tr></table></figure><p>结果如下：</p><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-------+</span><br><span class="line">| name  |</span><br><span class="line">+-------+</span><br><span class="line">| Dany  |</span><br><span class="line">| Henry |</span><br><span class="line">+-------+</span><br></pre></td></tr></table></figure></blockquote><h3 id="MySQL-插入数据"><a href="#MySQL-插入数据" class="headerlink" title="MySQL 插入数据"></a>MySQL 插入数据</h3><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO &lt;表名&gt; [ &lt;列名1&gt; [ , … &lt;列名n&gt;] ]</span><br><span class="line">VALUES (值1) [… , (值n) ];</span><br></pre></td></tr></table></figure><p>语法说明如下。</p><ul><li><code>&lt;表名&gt;</code>：指定被操作的表名。</li><li><code>&lt;列名&gt;</code>：指定需要插入数据的列名。若向表中的所有列插入数据，则全部的列名均可以省略，直接采用 INSERT&lt;表名&gt;VALUES(…) 即可。</li><li><code>VALUES</code> 或 <code>VALUE</code> 子句：该子句包含要插入的数据清单。数据清单中数据的顺序要和列的顺序相对应。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO &lt;表名&gt;</span><br><span class="line">SET &lt;列名1&gt; = &lt;值1&gt;,</span><br><span class="line">        &lt;列名2&gt; = &lt;值2&gt;,</span><br><span class="line">        …</span><br></pre></td></tr></table></figure><h4 id="向表中的全部字段添加值"><a href="#向表中的全部字段添加值" class="headerlink" title="向表中的全部字段添加值"></a>向表中的全部字段添加值</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO tb_courses</span><br><span class="line">(course_id,course_name,course_grade,course_info)</span><br><span class="line">VALUES(1,&#x27;Network&#x27;,3,&#x27;Computer Network&#x27;);</span><br></pre></td></tr></table></figure><h4 id="向表中指定字段添加值"><a href="#向表中指定字段添加值" class="headerlink" title="向表中指定字段添加值"></a>向表中指定字段添加值</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO tb_courses</span><br><span class="line">(course_name,course_grade,course_info)</span><br><span class="line">VALUES(&#x27;System&#x27;,3,&#x27;Operation System&#x27;);</span><br></pre></td></tr></table></figure><h4 id="使用-INSERT-INTO…FROM-语句复制表数据"><a href="#使用-INSERT-INTO…FROM-语句复制表数据" class="headerlink" title="使用 INSERT INTO…FROM 语句复制表数据"></a>使用 INSERT INTO…FROM 语句复制表数据</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO tb_courses_new</span><br><span class="line">(course_id,course_name,course_grade,course_info)</span><br><span class="line">SELECT course_id,course_name,course_grade,course_info</span><br><span class="line">FROM tb_courses;</span><br></pre></td></tr></table></figure><h3 id="MySQL-修改数据"><a href="#MySQL-修改数据" class="headerlink" title="MySQL 修改数据"></a>MySQL 修改数据</h3><h4 id="UPDATE-语句的基本语法"><a href="#UPDATE-语句的基本语法" class="headerlink" title="UPDATE 语句的基本语法"></a>UPDATE 语句的基本语法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE &lt;表名&gt; SET 字段 1=值 1 [,字段 2=值 2… ] [WHERE 子句 ]</span><br><span class="line">[ORDER BY 子句] [LIMIT 子句]</span><br></pre></td></tr></table></figure><p>语法说明如下：</p><ul><li><code>&lt;表名&gt;</code>：用于指定要更新的表名称。</li><li><code>SET</code> 子句：用于指定表中要修改的列名及其列值。其中，每个指定的列值可以是表达式，也可以是该列对应的默认值。如果指定的是默认值，可用关键字 DEFAULT 表示列值。</li><li><code>WHERE</code> 子句：可选项。用于限定表中要修改的行。若不指定，则修改表中所有的行。</li><li><code>ORDER BY</code> 子句：可选项。用于限定表中的行被修改的次序。</li><li><code>LIMIT</code> 子句：可选项。用于限定被修改的行数。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE tb_courses_new</span><br><span class="line">SET course_name=&#x27;DB&#x27;,course_grade=3.5</span><br><span class="line">WHERE course_id=2;</span><br></pre></td></tr></table></figure><h3 id="MySQL-删除数据"><a href="#MySQL-删除数据" class="headerlink" title="MySQL 删除数据"></a>MySQL 删除数据</h3><h4 id="删除单个表中的数据"><a href="#删除单个表中的数据" class="headerlink" title="删除单个表中的数据"></a>删除单个表中的数据</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE FROM &lt;表名&gt; [WHERE 子句] [ORDER BY 子句] [LIMIT 子句]</span><br></pre></td></tr></table></figure><p>语法说明如下：</p><ul><li><code>&lt;表名&gt;</code>：指定要删除数据的表名。</li><li><code>ORDER BY</code> 子句：可选项。表示删除时，表中各行将按照子句中指定的顺序进行删除。</li><li><code>WHERE</code> 子句：可选项。表示为删除操作限定删除条件，若省略该子句，则代表删除该表中的所有行。</li><li><code>LIMIT</code> 子句：可选项。用于告知服务器在控制命令被返回到客户端前被删除行的最大值。</li></ul><p><strong>注意：在不使用 WHERE 条件的时候，将删除所有数据。</strong></p><h3 id="MySQL-清空表数据"><a href="#MySQL-清空表数据" class="headerlink" title="MySQL 清空表数据"></a>MySQL 清空表数据</h3><p><strong>TRUNCATE</strong> 关键字用于完全清空一个表</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TRUNCATE [TABLE] 表名</span><br></pre></td></tr></table></figure><p>其中，TABLE 关键字可省略。</p><h4 id="TRUNCATE-和-DELETE-的区别"><a href="#TRUNCATE-和-DELETE-的区别" class="headerlink" title="TRUNCATE 和 DELETE 的区别"></a>TRUNCATE 和 DELETE 的区别</h4><p>从逻辑上说，TRUNCATE 语句与 DELETE 语句作用相同，但是在某些情况下，两者在使用上有所区别。</p><ul><li>DELETE 是 DML 类型的语句；TRUNCATE 是 DDL 类型的语句。它们都用来清空表中的数据。</li><li>DELETE 是逐行一条一条删除记录的；TRUNCATE 则是直接删除原来的表，再重新创建一个一模一样的新表，而不是逐行删除表中的数据，执行数据比 DELETE 快。因此需要删除表中全部的数据行时，尽量使用 TRUNCATE 语句， 可以缩短执行时间。</li><li>DELETE 删除数据后，配合事件回滚可以找回数据；TRUNCATE 不支持事务的回滚，数据删除后无法找回。</li><li>DELETE 删除数据后，系统不会重新设置自增字段的计数器；TRUNCATE 清空表记录后，系统会重新设置自增字段的计数器。</li><li>DELETE 的使用范围更广，因为它可以通过 WHERE 子句指定条件来删除部分数据；而 TRUNCATE 不支持 WHERE 子句，只能删除整体。</li><li>DELETE 会返回删除数据的行数，但是 TRUNCATE 只会返回 0，没有任何意义。</li></ul><hr><p><strong>THE END</strong></p>]]></content>
      
      
      <categories>
          
          <category> 技术连连看 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown基础语法</title>
      <link href="/2023/02/12/MarkDown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2023/02/12/MarkDown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="首先就是快捷键"><a href="#首先就是快捷键" class="headerlink" title="首先就是快捷键"></a>首先就是快捷键</h3><p><strong>Ctrl + 1~6 :</strong> 就是在文字前加上1~6个 <strong>#</strong> ，表示1~6级<strong>标题</strong></p><p><strong>Ctrl + B :</strong>  文字两侧加上  <strong>*</strong>* ，表示<strong>粗体</strong></p><p><strong>Ctrl + I :</strong>  文字两侧加上  <strong>*</strong> ，表示<strong>斜体</strong></p><p><strong>Ctrl + K :</strong>  生成 <strong>[]()</strong> ，表示<strong>插入链接</strong></p><h3 id="然后是基础语法"><a href="#然后是基础语法" class="headerlink" title="然后是基础语法"></a>然后是基础语法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**文字** 粗体</span><br></pre></td></tr></table></figure><p><strong>文字</strong>  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*文字* 斜体</span><br></pre></td></tr></table></figure><p><em>文字</em></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; 文字  引用（可嵌套）</span><br></pre></td></tr></table></figure><blockquote><p>文字</p><blockquote><p>文字</p></blockquote></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 文字   有序列表（按Tab键可嵌套，退出当前层按 Shift + Tab）</span><br></pre></td></tr></table></figure><ol><li>文字</li><li>文字<ol><li>文字</li></ol></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 文字  无序列表（按Tab键可嵌套，退出当前层按 Shift + Tab）</span><br></pre></td></tr></table></figure><ul><li>文字</li><li>文字<ul><li>文字</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`代码`  表示代码</span><br></pre></td></tr></table></figure><p><code>HelloWorld</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">``代码`` 转义反引号，在代码中显示反引号时使用</span><br></pre></td></tr></table></figure><p><code>For programmers, `Hello World` is a must </code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">***    分割线，三个以上的 * 或 - 或 _(效果相同)</span><br></pre></td></tr></table></figure><hr><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[标题（可选）](链接地址)   链接</span><br></pre></td></tr></table></figure><p><a href="http://www.baidu.com/">百度</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![标题](图片地址)  图片链接</span><br></pre></td></tr></table></figure><img src="cover.jpg" alt="图片链接" style="zoom:25%;" /><h3 id="最后是拓展语法"><a href="#最后是拓展语法" class="headerlink" title="最后是拓展语法"></a>最后是拓展语法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">| Syntax      | Description |</span><br><span class="line">| ----------- | ----------- |</span><br><span class="line">| Header      | Title       |</span><br><span class="line">| Paragraph   | Text        |   </span><br><span class="line"></span><br><span class="line">要添加表，请使用三个或多个连字符（---）创建每列的标题，并使用管道（|）分隔每列。您可以选择在表的任一端添加管道。</span><br><span class="line"></span><br><span class="line">| Syntax      | Description | Test Text     |</span><br><span class="line">| :---        |    :----:   |          ---: |</span><br><span class="line">| Header      | Title       | Here&#x27;s this   |</span><br><span class="line">| Paragraph   | Text        | And more      |</span><br><span class="line"></span><br><span class="line">您可以通过在标题行中的连字符的左侧，右侧或两侧添加冒号（:），将列中的文本对齐到左侧，右侧或中心。</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">id</th><th align="left">name</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">lisa</td></tr><tr><td align="left">2</td><td align="left">crazy</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">``` Enter   插入代码块，使用三个的 ~ 或 ` </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~~文字~~   删除线</span><br></pre></td></tr></table></figure><p><del>文字</del></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- [x] Write the press release   任务列表（方框中填入X表示勾选,填入空格表示不勾选，不可为空）</span><br></pre></td></tr></table></figure><ul><li><input checked="" disabled="" type="checkbox"> 任务1</li><li><input disabled="" type="checkbox"> 任务2</li></ul><hr><p><strong>THE END</strong></p>]]></content>
      
      
      <categories>
          
          <category> 技术连连看 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MarkDown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>任务书</title>
      <link href="/2023/02/09/%E4%BB%BB%E5%8A%A1%E4%B9%A6/"/>
      <url>/2023/02/09/%E4%BB%BB%E5%8A%A1%E4%B9%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="任务书（2024-01-11）"><a href="#任务书（2024-01-11）" class="headerlink" title="任务书（2024-01-11）"></a>任务书（2024-01-11）</h2>]]></content>
      
      
      <categories>
          
          <category> 任务 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo常用命令</title>
      <link href="/2023/02/09/Hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2023/02/09/Hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="hexo-init-folder"><a href="#hexo-init-folder" class="headerlink" title="hexo init [folder]"></a>hexo init [folder]</h3><p>新建一个网站。如果没有设置<code>folder</code>，Hexo默认再当前文件夹建立网站。</p><h3 id="hexo-g-或-hexo-generate"><a href="#hexo-g-或-hexo-generate" class="headerlink" title="hexo  g  或  hexo generate"></a>hexo  g  或  hexo generate</h3><p>该命令执行后在hexo站点根目录下生成public文件夹</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-d, –deploy</td><td>文件生成后立即部署网站</td></tr><tr><td>-w, –watch</td><td>监视文件变动</td></tr><tr><td>-b, –bail</td><td>生成过程中如果发生任何未处理的异常则抛出异常</td></tr><tr><td>-f, –force</td><td>强制重新生成文件Hexo 引入了差分机制，如果 public 目录存在，那么 hexo g 只会重新生成改动的文件。使用该参数的效果接近 hexo clean &amp;&amp; hexo generate</td></tr><tr><td>-c, –concurrency</td><td>最大同时生成文件的数量，默认无限制</td></tr></tbody></table><p>启动 hexo 服务，默认地址为  <code>http://localhost:4000 </code></p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-p, –port</td><td>重设端口</td></tr><tr><td>-s, –static</td><td>使用静态文件</td></tr><tr><td>-l, –log</td><td>启动日记记录，使用覆盖记录格式</td></tr></tbody></table><h3 id="hexo-clean"><a href="#hexo-clean" class="headerlink" title="hexo clean"></a>hexo clean</h3><p>把（1）中生成的public文件夹删除，也就是删除生成的静态文件</p><h3 id="hexo-new-layout-lt-title-gt"><a href="#hexo-new-layout-lt-title-gt" class="headerlink" title="hexo new [layout] &lt;title&gt;"></a>hexo new [layout] &lt;title&gt;</h3><p>例如：<code>hexo new post &quot;Hello World&quot;</code>  (new 可简写为 n)</p><p>[layout] 可选值：post , draft  , page  ,不写时默认为post</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-p ,–path</td><td>自定义新文章的路径</td></tr><tr><td>-r,–replace</td><td>如果存在同名文章，将其替换</td></tr><tr><td>-s,–slug</td><td>文章的Slug，作为新文章的文件名和发布后的URL</td></tr></tbody></table><p>默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 <code>index.md</code> 文件。你可以使用 <code>--path</code> 参数来覆盖上述行为、自行决定文件的目录</p><p>例如：<code>hexo new page --path about/me &quot;About me&quot;</code></p><p>以上命令会创建一个 <code>source/about/me.md</code> 文件，同时 Front Matter 中的 title 为 <code>&quot;About me&quot;</code></p><h3 id="删除文章"><a href="#删除文章" class="headerlink" title="删除文章"></a>删除文章</h3><p>直接再本地<code>source/_post</code>文件夹中删除文章源文件后重新部署即可。</p><p>参考命令：<code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo s  //clean  防止灵异事件发生</code></p><h3 id="hexo-public-layout-lt-filename-gt"><a href="#hexo-public-layout-lt-filename-gt" class="headerlink" title="hexo  public  [layout]  &lt;filename&gt;"></a>hexo  public  [layout]  &lt;filename&gt;</h3><p>发布草稿</p><h3 id="hexo-list-lt-type-gt"><a href="#hexo-list-lt-type-gt" class="headerlink" title="hexo list &lt;type&gt;"></a>hexo list &lt;type&gt;</h3><p><code> type  Available types: page, post, route, tag, category</code></p><p>列出网站资料 </p><h3 id="hexo-version"><a href="#hexo-version" class="headerlink" title="hexo version"></a>hexo version</h3><p>显示Hexo版本</p><h3 id="hexo-–safe"><a href="#hexo-–safe" class="headerlink" title="hexo  –safe"></a>hexo  –safe</h3><p>进入安全模式，在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。</p><h3 id="hexo-–debug"><a href="#hexo-–debug" class="headerlink" title="hexo  –debug"></a>hexo  –debug</h3><p>进入调试模式，在终端中显示调试信息并记录到debug.log。当您碰到问题时，可以尝试用调试模式重新执行一次，并提交调试信息到GitHub。</p><h3 id="hexo-–silent"><a href="#hexo-–silent" class="headerlink" title="hexo  –silent"></a>hexo  –silent</h3><p>进入简洁模式，隐藏终端信息。</p><h3 id="hexo-–draft"><a href="#hexo-–draft" class="headerlink" title="hexo  –draft"></a>hexo  –draft</h3><p>显示<code>source/_ </code>文件夹中的草稿文章。</p><hr><p><strong>The  End</strong></p>]]></content>
      
      
      <categories>
          
          <category> 技术连连看 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字典 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
