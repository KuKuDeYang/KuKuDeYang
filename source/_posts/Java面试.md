---
title: Java面试
tags: [Java,面试]
copyright: true
typora-root-url: Java面试 
date: 2023-03-07 10:59:12
categories: 技术连连看
description: Java面试问题
cover: cover.png
---

 # java面试题笔记

## 面向对象

面向对象相对于面向过程，更加注重事件有哪些参与者，各自需要做些什么。更加的易于复用，拓展和维护。

**封装：**封装的意义在于明确标示出外部使用的所有成员函数和数据项，内部细节全部对外透明，外部调用无需修改或者关心内部实现

**继承：**继承基类的方法，做出自己的改变或拓展。

**多态：**基于对象所属类的不同，外部对象对同一方法的调用，实际执行的逻辑不同。

## JDK、JRE、JVM 三者的区别和联系

**JDK：** java Development Kit java开发工具

**JRE：**Java Runtime Environment java运行时环境

**JVM：**java Virtual Machine java虚拟机

![image-20220510170809934](627a2e5609475431295bae3a-16781581775101.jpg)

JDK–(include)–>JRE–(include)–>JVM

## == 和 equals

**== ：**对比的是栈中的值，基本数据类型是变量值，引用数据类型是堆中内存对象的地址。

**equals：**object中默认采用 `==` 比较，通常会重写（String重写了equals()方法）。

## finall

**最终的**

- 修饰类：表示方法不可被继承
- 修饰方法：表示方法不可被子类覆盖，但可以重载
- 修饰变量：表示变量一旦赋值不可改变它的值（修饰成员变量一定要赋初始值，修饰局部变量可以不赋初始值，但在使用前一定要赋值）

**为什么局部内部类中和匿名内部类中只能访问局部final变量**

内部类中为了防止局部变量被回收导致异常，采用将局部变量复制一份的方法保存在自己的类中，为了保证内部类中成员变量和方法的成员变量保持一致，所以使用final关键字。

## String、StringBuffer、StringBuilder的区别及使用场景

String是final修饰的，不可变，每次操作都会生成新的String对象

StringBuffer和StringBuilder都是在原对象上操作的

StringBuffer是线程安全的，StringBuilder是线程不安全的

StringBuffer和StringBuilder方法都是synchronized修饰的

性能：StringBuilder > StringBuffer > String

场景：经常用到字符串改变使用后边两个，多线程使用StringBuffer，追求效率使用StringBuilder

**重载：**发生在同一个类中，方法名必须相同，参数类型不同，个数不同，顺序不同都叫重载，方法返回值不同，访问修饰符不同不叫重载，发生在编译时。

**重写：**发生在父子类中，方法名，参数列表必须相同，返回值范围小于等于父类，异常抛出范围大于等于父类，访问修饰符范围大于等于父类；如果父类方法为private，则子类不能重写。

## 接口和抽象类的区别

- 抽象类可以存在普通成员函数，接口只能存在public abstract方法
- 抽象类只能继承一个，接口可以继承多个
- 抽象类中成员变量可以是各种类型，接口中成员变量只能是public static final类型

接口的目的是对类的行为进行约束，抽象类的目的是代码复用

**使用场景：**当你关注一个事物的本质时使用抽象类，关注一个操作时，使用接口

## List和Set的区别

**List：**有序可重复，顺序为对象进入的顺序，允许多个`null`元素出现，可以用迭代器（Iterator）取出所有对象，也可使用下标取出元素。

**Set：**无序不可重复，只能有一个`null`，只能使用迭代器取出元素。

## hashCode 和 equals

hashCode()的作用是获取哈希码（散列码），返回一个整数，使用哈希码确定对象在哈希表中的位置。

hashSet来检查是否重复，就是先对比hashCode的值，不相等则不重复，相等就使用equal方法，这样就大大减少了equal的次数。

## ArrayList 和 LinkedList的区别

**ArrayLIst：**基于动态数组，连续内存存储，扩容时需要新建一个数组，将老数组的数据复制到新数组，扩容到原来的**1.5**倍。

**LinkedList：**基于链表，可以存储在散列的内存中，不适合查询，适合插入与删除。只能使用迭代器遍历，不可使用for循环，因为for的每次get都需要重新遍历，性能消耗极大。

## HashMap 和 HashTable 的区别和底层实现

**区别：**

HashMap是线程不安全的，HashTable是线程安全的

HashMap允许key和value为null，hashTable不允许

**底层实现（HashMap）：**

jdk8开始链表高度到8，数组长度超过64，链表转为红黑树（自平衡的二叉排序树），元素以内部Node节点存在。

数组扩容：默认容量为16，加载因子默认0.75，阈值=容量*加载因子，默认12，当元素数量超过阈值时，扩容到原来的**2**倍。

## ConcurrentHashMap原理，在 jdk7和jdk8版本的区别

ConcurrentHashMap是线程安全的，使用分段锁，而HashTable是使用全局锁，所以前者效率要高。

## 如何实现一个IOC容器

1. 配置文件配置包扫描路径
2. 递归包扫描获取.class文件
3. 反射、确定需要交给ioc管理的类
4. 对需要注入的类进行依赖注入

## 什么是字节码，使用字节码的好处是什么

java源程序经过编译器编译后变成字节码（.class文件），字节码由虚拟机解释运行，采用字节码可以实现一处编译，到处运行的效果。

**java源代码–>编译器–>jvm可执行的java字节码–>jvm–>jvm中的解释器–>及其可执行的二进机器码–>程序运行**

## java类加载器有哪些

jdk自带的三个类加载器：bootstrap ClassLoader、ExtClassLoader 、AppClassLoader

前者是后者的父类（并非继承关系，而是有一个变量控制的），继承ClassLoader实现自定义类加载器。

## 双亲委派（委托）模型

![img](627b7ca0094754312999af06.jpg)

向上委派查找缓存，向下查找加载路径。

好处：为了安全性，避免用户自己编写的类替换java核心类同时避免了类的重复加载。类名和类加载器确定一个类。

## java中的异常体系

java中异常都来自顶级父类Throwable

Throwable有两个子类Error和Exception

Error是程序无法处理的错误，一旦出现则程序终止运行

Exception不会导致程序停止，又分为RunTimeException和CheckedException

## GC如何判断对象可以被回收

- 引用计数法：每一个对象有一个引用计数属性，新增一个引用时计数加一，释放一个引用时计数减一，当计数为零是回收。（效率十分高，但会出现相互引用的情况，此时永远无法回收）
- 可达性分析法：从GC Roots（根）开始向下搜索，可以被搜索到的不回收，不可以被搜索到的可回收。（不可达对象不会立即销毁，有一次自我拯救的机会）

GC Roots对象有：

- 虚拟机栈中引用的对象
- 方法去中类静态属性引用的对象
- 方法去中常量引用的对象
- 本地方法栈中引用的对象

## 线程的生命周期、线程的几种状态

线程一般有五种状态：创建，就绪，运行，阻塞，死亡

## sleep()、wait()、join()、yield()的区别

sleep是Thread类的静态本地方法，wait是Object类的本地方法

sleep方法不会释放lock（锁），但是wait会释放，并加入等待队列中

sleep方法不依赖同步器synchronized，wait需要

sleep不需要被唤醒，wait需要（不指定时间时）

sleep一般用于当前线程休眠，或者轮询暂停操作，wait用于多线程通信

sleep会让出cpu并强制上下文切换，wait进入等待队列后被唤醒仍有机会重新竞争cpu

yiele执行后会进入就绪状态，释放cpu但保留执行资格

join执行后会进入阻塞状态

## 对线程安全的理解

线程安全实际上指的是内存安全，因为堆是共享的，可以被所有线程所访问，当多个线程访问一个对象时，如果不用进行额外的同步控制或其他协调操作，调用这个对象的行为都可以获得正确的结果，我们就说这个对象是线程安全的。

## Thread、Runable的区别

Thread是一个类，Runable是一个接口

Thread实现了Runable

## 对守护线程的理解

**守护线程：**为所有非守护线程提供服务的线程；用户线程就属于非守护线程。当所有非守护线程结束后，守护线程也会被中断。

**应用场景**

- 为其他线程提供服务支持
- 在任何情况下，程序结束后，线程必须正常且立刻关闭，就可以使用守护线程。反之当一个正在执行某个操作的线程必须要正确关闭时则不可用守护线程，而应使用用户线程。

## ThreadLocal的原理和使用场景

每一个Thread对象中均含有一个ThreadLocalMap类型的成员变量，threadlocals，它存储了本线程中所有的ThreadLocal对象及其对应的值

使用场景：

1. 在进行对象跨层传递的时候，使用ThreadLocal可以避免多次传递，打破层次间的约束。
2. 线程间数据隔离
3. 进行事务操作，用于存储线程事务信息
4. 数据库连接，Session会话管理

## ThreadL内存泄露的原因，如何避免

**内存泄漏：**不再会被使用的对象或变量无法被回收，一直占用内存

Threadl内存泄漏的根源是：由于ThreadLocalMap的生命周期和Thread一样长，如果没有手动删除，对应的key就会导致内存泄露，而不是因为弱引用。

ThreadLocal正确使用方法

- 每次使用完Threadlocal都调用它的remove()方法清除数据
- 将ThreadLocal变量定义成private static ，这样就一直存在ThreadLocal的强引用，也能保证任何时候都能通过Threadlocal的弱引用访问到值，进而清除掉。

## 并发、并行、串行的区别

**串行**在时间上不可能发生重叠前一个任务没有完成，后一个任务就不会执行

**并行**在时间上是重叠的，两个任务在同一时刻互不干扰的同时执行

**并发**允许两个任务彼此干扰，同一时间点只有一个任务运行，人物之间交替执行

## 并发的三大特性

**原子性：**原子性是指在一个操作中cpu不可以中途暂停然后再调度，即不可被中断操作，要么全部执行成功，要么都不执行。

**可见性：**当多个线程访问同一变量时，一个线程修改了这个变量的值，其他线程能够立即看到修改的值。

**持续性：**虚拟机在进行代码编译时，对于那些改变顺序之后不会对最终结果造成影响的代码，虚拟机可能将他们重排序，实际上，对于代码重排序后，虽然变量的值没有影响，但可能造成线程安全问题。

## 为什么使用线程池、解释下线程池参数

1. 降低资源消耗
2. 提高响应速度
3. 提高线程的可管理性

**参数：**

- corePoolSize：核心线程数；指正常工作时创建的线程数。属于常驻线程。
- maxinumPoolSize：最大线程数；与核心线程想对应，指线程池中能够创建的最大线程数。
- keepAliveTime、unit：表示除核心线程之外的线程的空闲存活时间，超出时间则会被消除。
- workQueue：用来存放待执行的任务。
- ThreadFactory：实际上是一个创建线程的线程工厂，用来生产线程执行任务。

## 简述线程池处理流程

![img](627c63f609475431299e05cc-16781582321103.jpg)

当达到最大线程数时，根据拒绝策略来处理任务

## 线程池中阻塞队列的作用是什么、为什么先添加队列而不是先创建最大线程

阻塞队列的作用：没搞懂。。。

先添加队列的原因：在创建新线程时，是要获取全局锁的，这个时候就要阻塞其他线程，影响效率。

## 线程池中线程复用原理

线程池将线程和任务解耦，拜托了之前创建一个线程必须对应一个任务的限制

在线程池中，一个线程可以不断从阻塞队列中获取新任务来执行，其原理就是线程池对Thread进行了封装，并不是每次执行任务都会调用start()方法来创建新县城，而是让每个线程执行一个循环任务，在这个循环任务中不停检查是否有任务要执行，有则调用run()方法直接执行。

```
start()是创建一个线程，run()是使用当前线程
```

## Spring是什么

spring是一个轻量级的开源的J2ee框架。它是一个容器框架，用来装javabean对象。

spring是一个轻量级的控制翻转（ioc）和面向切面（aop）的容器框架

- 从大小和开销方面来说是轻量级的
- 通过ioc实现了解耦合的目的
- 提供了aop，允许通过分离应用的业务逻辑与系统级服务进行内聚性的开发
- 包含并管理应用对象的生命周期，这个意义上来说是个容器
- 将简单的组件配置、组合成为复杂的应用，这个意义上来说是一个框架

## 对AOP的理解

将程序中的交叉业务逻辑（比如安全，日志，事务等），封装成一个切面，然后注入到业务逻辑中，这样就可以再不改变源代码的前提下，对对象中的方法进行增强，在执行对象方法前后都可以额外做一些事。

## 对IOC的理解

ioc容器实际上是一个存放bean的map，在项目启动时会读取配置文件，然后通过反射将bean对象创建好并放入map集合中。这样我们就可以通过依赖注入获取到这些对象。

使用ioc容器后，对象的创建就从一开始我们去new一个新对象变成了ioc帮我们去创建一个对象，创建对象从主动变成了被动。这就是控制反转。

## BeanFactory和ApplicationContext有什么区别

ApplicationContext是BeanFactory的子接口，ApplicationContext提供了更完整的功能：

1. 继承MessageSource，因此支持国际化
2. 统一的资源文件访问方式
3. 提供在监听器中注册bean的事件
4. 同时加载多个配置文件
5. 载入多个有继承关系的上下文，使得每一个上下文都专注于一个特定的层次

BeanFactory采用了延迟加载形式注入bean，即只有在使用bean时才会进行加载实例化，而ApplicationContext在容器启动时一次性创建所有bean，可以才容器启动时就发现spirngboot中存在的配置错误，有利于检查依赖属性是否注入。同时确保使用时不需要等待，直接使用即可。相对于BeanFactory的不足就是内存占用大，程序启动慢。

BeanFactory通常以编程方式被创建，ApplicationContext还能以声明的方式被创建

BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，区别是前者需要手动注册，后者自动注册

## 描述一下Spring Bean的生命周期

大体生命周期为 实例化–>属性赋值–>初始化–>销毁

1. 实例化对象：通过反射的方式进行对象的创建
2. 设置对象属性
3. 检查Aware相关接口并设置相关依赖
4. BeanPostprocessor的前置处理
5. 调用初始化方法
6. BeanPostProcessing后置处理
7. 使用bean
8. 调用DisposableBean中的destroy()方法

## 简述一下Spring支持的几种bean的作用于

- singleton：单例，默认。每一个容器中只有一个bean的实例
- prototype：多例，为每一个bean请求提供一个实例，每次注入时都会创建新的对象
- request：在每一个HTTP请求中创建一个可复用的单例对象
- session：确保每一个session中有一个可复用的单例对象
- application：每一个ServletContext的生命周期中有一个可复用的单例对象
- websocket：每一个websocket的生命周期中有一个可复用的单例对象
- global-session：全局作用域

## Spring框架中的单例Bean是线程安全的么

不是的

如果bean是有状态的（存储了数据），就需要开发人员来保证线程安全，最简单的方法就是改变bena的作用域，把singleton改成prototype，这样每次bean请求都会创建一个新对象，保证线程安全。

所以尽量不要在bena中声明任何有状态的实例变量或者类变量，如果必须这样做，则只能使用synchronized、lock、CAS等实现线程同步。

## Spring框架中都用到了哪些设计模式

单例模式、工厂模式、适配器模式、动态代理、装饰器模式、观察者模式、策略模式

## Spring事务的实现方式和原理以及隔离级别

两种使用事务的方式：一种是编程式，一种是声明式，@Transactional就是生命式的

在方法上加入@Transactional注解后，Spring会基于这个类生成代理对象，在使用这个方法时，代理逻辑会吧事务中的自动提交设置为false，再去执行业务逻辑代码，如果业务逻辑出现异常，则回滚，没有则提交。

隔离级别：

- read uncommitted(未提交读、脏读) 读取到未提交的内容
- read committed(提交读，不可重复读)
  - **A：**启动事务，此时数据为初始状态
  - **B：**启动事务，更新数据，但不提交
  - **A：**再次读数据，发现数据未被修改
  - **B：**提交事务
  - **A：**再次读取数据，发现数据已发生变化，说明B提交的修改被事务中的A读到了，这就是所谓的“不可重复读”
- repeatable read (可重复读、幻读) 当用户读取某一范围的数据时，其他事务有插入了新行，当用户再次读取时发现有新的“幻”影行。
  - **A：**启动事务，此时数据为初始状态
  - **B：启动事务，更新数据，但不提交**
  - **A：**再次读取数据，发现数据未被修改
  - **B：**提交事务
  - **A：**再次读取数据，发现数据依然未发生变化，这说明这次可以重复读了
  - **B：**插入一条新的数据，并提交
  - **A：**再次读取数据，发现数据依然未发生变化，虽然可以重复读了，但是却发现读的不是最新数据，这就是所谓的“幻读”
  - **A：**提交本次事务，再次读取数据，发现读取正常了
- serializable(可串行化)

不可重复读和幻读的区别：前者的重点是修改，后者的重点是增加或删除，两者都是在一个事物过程中，两次读取读到了不同的值。

## spirng事物的传播机制

**REQUIRED（默认）：**如果当前有事务，则加入，没有则自己创建

**SUPPORTS：**如果当前有事务就加入，没有就不以事物运行

**MANDATORY：**如果当前有事务就加入，没有抛出异常

**REQUIRES_NEW：**创建一个新事务，如果存在当前事务，则挂起该事务（a调用b，如果a有事务，则b将a的事务挂起，自己创建一个新事务运行，简单来说就是各跑各的事务）

**NOT_SUPPORTED：**以非事务的方式运行，如果当前存在事务，则挂起该事务

**NEVER：**不使用事务，如果有事务，则抛异常

**NESTED：**如果当前事务存在，则在嵌套事务中执行，否则开启一个新事务（嵌套事务中父事务回滚，子事务回滚，子事务回滚，父事务不一定）

## spring事务什么时候失效

spring事务的原理就是AOP，失效的原因就是AOP不起作用

1. 发生自调用。自调用时调用对象是UserService对象本身，而不是代理类
2. 方法不是public。@Transactional注解只能用在public方法上
3. 数据库不支持事务
4. bean对象没有被spring管理
5. 异常没有抛出或者跑出的异常没有被定义

## 什么是bean的自动装配，有哪些方式

开启自动装配，只需要在xml配置文件中定义autowire属性

```
<bean id="customer" class="com.XXX.XXX.Customer" autowire=""></bean>
```

autowire属性有五种装配方式

- no -缺省情况下，默认使用ref属性手动设定
- byName -根据属性名称自动装配
- byType -根据属性类型自动装配
- constructor -类似于byType，不过应用于构造器参数，如果一个bean与构造器参数的类型相同，则自动装配
- autodetect -如果有默认构造器，则通过constructor自动装配，否则使用byType

@Autowired默认使用byType；@Resource默认使用byName

## Spring Boot 、Spring、Spring MVC有什么区别

Spring是一个ioc容器用来管理bean，使用依赖注入实现控制反转，提供了aop机制来解决oop的代码重复的问题。

springmvc是spring对web框架的一个解决方案，提供了一个总的前端控制器servlet用来接收请求，定义了一系列路由策略及适配执行的handle，将结果生成视图返回给前端。

spring boot是spring提供的一个快速开发的工具包，让程序员更快速方便的开发spring+springmvc的应用，简化了配置，整合了一系列的解决方案（start机制）比如redis，mongodb等，开箱即用

## Spring MVC的工作流程

1. 用户发送请求到前端控制器DispatcherServlet
2. DispatcherServlet收到请求后调用HandlerMapping处理器映射器
3. 处理器映射器找到具体的处理器，生成处理器及处理器拦截器一并返回给DispatcherServlet
4. DispatcherServlet调用HandlerAdapter处理器适配器
5. HandlerAdapter经过适配调用具体的处理器Controller
6. controller执行完成后返回ModelAndView
7. HandlerAdapter将controller执行的结果ModelAndView返回给DIspatcherServlet
8. DIspatcherServlet将ModelAndView传给ViewReslover视图解析器
9. ViewReslover解析后返回具体VIew
10. DispatcherServlet根据View进行渲染视图
11. DIspatcherServlet响应客户

## Spring MVC的主要组件

1. HandlerMapping：处理器映射器。根据用户请求的资源url查找handler
2. HandlerAdapter：适配器。让servlet能够调用handler来进行处理
3. HandlerExceptionResolver：异常处理器
4. ViewResolver：视图解析器
5. RequestToViewNameTranslator：
6. LocaleResolver
7. ThemeResolver：用于解析主题
8. MultipartResolver：用于处理上传请求
9. FlashMapManager：用来管理FlashMap的

## Spring Boot自动配置原理

搞不懂。。。

## 如何理解Spring Boot中的starter

starter就是定义一个sterter的jar包，写一个@configuration配置类，将这些bean定义到里面，然后在starter的META-INF/spring.factories中写入该配置类，spirngboot就会按照约定加载该配置类

开发人员只需要引入starter包，就直接可以进行代码开发。

## 什么是嵌入式服务器、为什么要使用嵌入式服务器

普通的spring springmvc应用要使用tomcat外部服务器，而springboot将tomcat打成jar包，直接在jvm上运行即可，这就是嵌入式服务器

节省了下载安装tomcat，应用也不需要再打war包，放到webapp目录下运行了，只需安装jvm就可以直接运行

springboot已经内置了tomcat.jar，运行main方法就会启动tomcat，然后加载mvc

## mybatis的优缺点

优点

1. 基于sql语句编程，相当灵活，不会对应用程序或者数据库现有的设计造成影响，sql写在xml文件中，解除sql与程序代码的耦合，支持编写动态sql语句，可复用。
2. 可以很好的和各种数据库兼容
3. 能够与spring很好地集成

缺点

1. sql语句编写的工作量巨大
2. sql语句依赖于数据库，导致数据库移植性差，不能随意更换数据库

## #{}和${}的区别

\#{}是预编译处理、是占位符，${}是字符串替换，是拼接符。

\#{}在变量替换后，会加上单引号，${}不会

\#{}可以有效地防止sql注入

## 索引的基本原理

索引用来快速寻找那些具有特定值的记录，没有索引一般执行查询时会遍历整张表

索引的原理：就是把无序的数据变成有序的数据

1. 把创建了索引的列的内容进行排序
2. 堆排序结果生成倒排表
3. 在倒排表内容上拼上数据地址链
4. 在查询时，先拿到倒排表内容，再取出地址链，在拿到具体数据

```
倒排表：使用内容去查找id    正排表：使用id去查找内容
```

## mysql索引的数据结构、各自优劣

索引的数据结构和具体的存储引擎的实现有关，mysql中有hash索引，B+树索引等，InnoDB默认为B+树，对于哈希索引来说，底层的数据结构就是哈希表，因此绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询速度最快，其余大部分情况，可以选择BTree索引。

**B+树**

B+树是一个平衡的多叉树，从根节点到每一个叶子节点的高度差值不超过1，根节点通过双向指针链接，效率非常高，与B树不同的是，B+树的内部节点不保存数据，只是起到索引的作用，只有叶子节点保存数据

**哈希索引**

哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，只需一次哈希算法，就能够找到数据的位置，速度十分快。

## 索引设计的原则

1. 适合索引的列是出现在where子句中的列，或者链接子句中指定的列
2. 基数较小的表，索引效果较差，没有必要在此列建立索引
3. 使用短索引。
4. 不要过度索引。
5. 定义有外间的数据列一定要建立索引
6. 更新频繁的字段不适合建立索引
7. 若是不能有效区分数据的列不适合做索引，比如性别，只有男女，区分度很低
8. 尽量的拓展索引，不要建立新索引。
9. 对于那些查询中很少涉及的列，重复比较多的咧不适合做索引
10. 对于定义为text、image和bit数据类型的列不要建立索引

## mysql锁的类型有哪些

基于锁的属性分类：共享锁，排它锁

基于锁的粒度分类：行级锁、表级索、页级索、记录锁、间隙锁、临建锁

基于锁的状态分类：意向共享锁、意向排它锁

## 事务的基本特性和隔离级别

**ACID**

**原子性**指的是一个事务中的操作要么全部成功，要么全部失败

**一致性**指的是数据库总是从一个一致性状态转换到另一个一致性状态，例如转账中转入账户和转出账户的金额总数不变

**隔离性**指的是一个事务的修改在提交前，对其他事务是不可见的

**持久性**指的是一旦事务提交，所做的修改会永久保存在数据库中

**隔离级别：**

- read uncommitted(未提交读、脏读) 读取到未提交的内容
- read committed(提交读，不可重复读)
  - **A：**启动事务，此时数据为初始状态
  - **B：**启动事务，更新数据，但不提交
  - **A：**再次读数据，发现数据未被修改
  - **B：**提交事务
  - **A：**再次读取数据，发现数据已发生变化，说明B提交的修改被事务中的A读到了，这就是所谓的“不可重复读”
- repeatable read (可重复读、幻读) 当用户读取某一范围的数据时，其他事务有插入了新行，当用户再次读取时发现有新的“幻”影行。
  - **A：**启动事务，此时数据为初始状态
  - **B：启动事务，更新数据，但不提交**
  - **A：**再次读取数据，发现数据未被修改
  - **B：**提交事务
  - **A：**再次读取数据，发现数据依然未发生变化，这说明这次可以重复读了
  - **B：**插入一条新的数据，并提交
  - **A：**再次读取数据，发现数据依然未发生变化，虽然可以重复读了，但是却发现读的不是最新数据，这就是所谓的“幻读”
  - **A：**提交本次事务，再次读取数据，发现读取正常了
- serializable(可串行化)

## 关心过业务系统里面的sql耗时么，统计过慢查询么，怎么优化慢查询

慢查询的优化首先要搞明白慢的原因是什么，是索引命中率不高？是加载了不需要的数据列？是数据量太大？

- 首先分析语句，看看是否是加载了多余的数据列，对语句进行分析以及重写
- 分析语句的执行计划，获取其使用的索引情况，之后修改语句或者修改索引，使得语句尽可能的命中
- 如果因为数据量太大，可以进行横向或纵向的分表

## ACID靠什么保证

A 原子性由undo log日志保证，他记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql

C 一致性由其他三大特性保证，程序代码要保证业务上的一致性

I 隔离性是由MVCC来保证

D持久性是由内存+redo log来保证，mysql修改数据同时在内存和redo log记录这次操作，宕机时可以从redo log恢复

## 什么是MVCC

MVCC多版本并发控制：
读取数据时通过一种类似快照的方式将数据保存下来，这样读锁就和写锁不冲突了，不同的事务session会看到自己特定版本的数据，版本链

mvcc只在READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作，其他两个不兼容

## mysql主从同步原理

mysql的主从复制主要由三个线程：master（binlog dump thread）、slave（IO thread，sql thread），master一条线程和slave中的两条线程。

- 主节点binlog，主从复制的基础是主数据库的所有变更记录到binlog中，binlog是数据库启动时就保存所有修改数据库结构或内容的一个文件
- 主节点log dump线程，当binlog文件发生修改时，log dump线程读取其内容并发送到各个从节点
- 从节点io线程接受binlog内容，将其写入relay log文件中
- 从节点的sql线程读取relay log文件内容对数据库进行重放，最终保证数据一致性

由于mysql默认的复制方式是异步的，主节点将日志交给从节点后就不管了，如果此时从数据库写入失败，主数据库挂了，日志就丢失了，由此产生了两个概念：

**全同步复制**

主库写入日志后，会强制同步到从库，当所有从库全部写入成功后，才能返回客户端，显然这种方法效率会受到严重影响

**半同步复制**

与全同步不同，半同步只需要一个库成功返回，主库就认为写操作完成

## 简述mysql中索引类型对数据库性能的影响

普通索引：允许被索引的数据列包含重复的值

唯一索引：可以保证数据记录的唯一性

主键：是一种特殊的唯一索引，在一张表中只能有一个主键索引，用于唯一标识一条记录

联合索引：索引可以覆盖多个数据列

全文索引：通过建立倒排索引，可以极大地提升检索效率，解决判断字段是否包含的问题

使用索引可以极大地提高数据的查询速度，但是会降低插入、删除、更新表的速度，因为在执行这些操作时，还要额外的去维护索引表，并且索引需要占物理空间。

## Redis过期键的删除策略

- 定时删除
  - 含义：在设置key的过期时间的同时，为该key创建一个定时器，让定时器在key的过期时间来临时，对key进行删除
  - 优点：保证内存被尽快释放
  - 缺点：
    - 若过期key很多，删除这些key会占用很多的CPU时间，在CPU时间紧张的情况下，CPU不能把所有的时间用来做要紧的事儿，还需要去花时间删除这些key
    - 定时器的创建耗时，若为每一个设置过期时间的key创建一个定时器（将会有大量的定时器产生），性能影响严重
    - 没人用
- 惰性删除
  - 含义：key过期的时候不删除，每次从数据库获取key的时候去检查是否过期，若过期，则删除，返回null。
  - 优点：删除操作只发生在从数据库取出key的时候发生，而且只删除当前key，所以对CPU时间的占用是比较少的，而且此时的删除是已经到了非做不可的地步（如果此时还不删除的话，我们就会获取到了已经过期的key了）
  - 缺点：若大量的key在超出超时时间后，很久一段时间内，都没有被获取过，那么可能发生内存泄露（无用的垃圾占用了大量的内存）
- 定期删除
  - 含义：每隔一段时间执行一次删除(在redis.conf配置文件设置hz，1s刷新的频率)过期key操作
  - 优点：
    - 通过限制删除操作的时长和频率，来减少删除操作对CPU时间的占用–处理”定时删除”的缺点
    - 定期删除过期key–处理”惰性删除”的缺点
  - 缺点
    - 在内存友好方面，不如”定时删除”
    - 在CPU时间友好方面，不如”惰性删除”
  - 难点
    - 合理设置删除操作的执行时长（每次删除执行多长时间）和执行频率（每隔多长时间做一次删除）（这个要根据服务器运行情况来定了）

## Redis线程模型，单线程为什么快

redis是单线程模型，采用io多路复用机制

单线程快的原因：

1. 纯内存操作
2. 核心是基于非阻塞的io多路复用机制
3. 单线程避免了多线程中频繁上下文切换带来得性能问题

## 缓存雪崩、缓存穿透、缓存击穿

缓存雪崩是指缓存同一时间大面积失效，所有请求都直接访问数据库，造成数据库短时间内大量承受访问请求而崩掉

解决方案：

- 缓存数据的过期时间设置为随机，防止同一时间大量数据过期
- 给每一个数据加上一个相应的缓存标记，记录是否失效，若失效则更新缓存
- 缓存预热
- 互斥锁

缓存穿透是指缓存和数据库中都没有数据，导致所有请求落在数据库中，导致数据库崩掉

解决方案：

- 接口层增加校验，如用户权限校验，id做基础校验
- 从缓存娶不到的数据，在数据库中也没有取到，这是将对应的key-value设置为key-null，将缓存时间缩短，如30秒，这样可以防止攻击用户反复使用同一个id暴力攻击
- 采用布隆过滤器

缓存击穿是指缓存中没有但是数据库中有的数据，一般是缓存时间到期。这时并发用户特别多时， 大量用户去访问数据库导致数据库崩掉。与缓存雪崩不同，缓存击穿一般指并发的查找同一条热点数据，雪崩是由于大量缓存过期导致。

解决方案：

- 设置热点数据永不过期
- 加互斥锁

## CAP理论，BASE理论

Consistency（一致性）：更新操作成功后，同一时间所有节点的数据完全一致

Availability（可用性）：服务一只可用，不会出现用户操作失败或访问超时等现象

Partition Tolerance（分区容错性）：要求虽然是分布式系统，但使用时要像在使用一个系统一样，当其中有一个或几个机器宕机时，剩下的机器仍能够正常运转，不会对用户的使用体验造成影响

CAP中p是必须要保证的，c和a中只能二选一

BASE是Basically Available（基本可用）、Soft state（软状态）、Eventually consistent（最终一致性）

## 负载均衡算法、类型

1. 轮询法：按照请求顺序轮流地分配到后端服务器上
2. 随机法：随机算法分配
3. 源地址哈希法：根据客户端的ip地址，通过哈希算法得到一个值，用该数值对服务器列表大小进行取模运算，得到的结果就是访问的服务系序号
4. 加权轮询法：为服务器附上权值，权值大的会多次被分配。如1234 12 1
5. 加权随机法：类似加权轮询，不过分配方式随机 。如 1324 21 1
6. 最小连接数法：选择连接数最小的服务器分配

类型：

DNS方式实现负载均衡

硬件负载均衡：F5和A10

软件负载均衡：Nginx、HAproxy、LVS。

## 分布式架构下，Session共享有什么方案

1. 采用无状态服务，抛弃session
2. 存入cookie（有安全风险）
3. 服务器之间进行session同步，不过当服务器数量较多时，同步会有延迟甚至失败
4. ip绑定策略：同一个ip只能同一个服务器进行访问，但这样就失去了负载均衡的意义
5. 使用redis存储，有多种好处
   1. 实现了session共享
   2. 可以水平拓展（增加redis服务器）
   3. 服务器重启sesson不丢失
   4. 不仅可以跨服务器session共享，甚至可以跨平台

## 分布式id生成方案

- uuid

  1. 当前日期和时间 时间戳
  2. 时钟序列 计数器
  3. 全局唯一的IEEE机器识别号。

  优点：代码简单，性能好，保证唯一

  缺点：每次生成的id都是无序的，而且不是全数字，且无法保证趋势递增

   生成的是字符串，查询慢，长度过长，不适合存储，有信息安全问题

- 数据库自增序列

- Leaf-segment

- 基于redis、mongodb、zk等中间件生成

- 雪花算法

  生成一个64位的整形数字

  第一位符号位固定为0,41位时间戳，10位workId，12为序列号

  位数可以有不同实现

  优点：

   每一个毫秒值包含的id值有很多，不够可以变动位数来增加，性能佳。

   时间戳值在高位，中间是固定的机器码，自增的序列号在低位，整个id是趋势递增的

   能够根据业务场景数据库节点布置灵活的bit位划分，灵活度高

  缺点：

   强依赖与机器时钟，如果时钟回拨，会导致id重复，因此一般基于此算法发现时钟回拨时会抛出异 常，阻止id生成，这可能导致服务不可用

## 分布式锁的解决方案

需要这个锁独立于每一个服务之外 ，而不是在服务内

1. 数据库：利用主键冲突控制一次只有一个线程才能获取锁，非阻塞、不可重入、单点、失效时间
2. zookeeper分布式锁：
3. redis分布式锁：setNX（只有当key不存在时才能设置成功），单线程处理网络请求，不需要考虑并发的安全性，所有服务节点设置相同的key，返回值为0、则锁获取失败
4. 删除锁：判断线程唯一标志，再删除
5. redlock

## 如何实现接口的幂等性

- 唯一id。每次操作，根据操作和内容生成唯一id，执行前判断id是否存在
- 建去重表。将业务中有唯一标识的字段保存到去重表，如果表中存在，表示已经处理过了
- 版本控制。增加版本号，当版本号符合时才更新数据
- 状态控制。
- 服务端提供发送token接口，业务调用时携带token，当业务执行完成后，将token从redis中删除

## zk的数据模型和节点类型

数据模型：树形结构

树中每一个节点被称为Znode

znode兼具文件和目录两种特点

znode具有原子性操作，度操作获取与节点相关的所有数据，写操作替换节点所有数据

znode存储数据大小有限制

znode通过路径引用，如同Unix中的文件路径。

节点类型：

 持久节点：一旦创建，该节点会只存在zk服务器上，即使该节点的客户端与服务器端会话关闭，节点也 不会删除

 临时节点：当创建该节点的客户端会话关闭时，节点删除

 有序节点：不是一种单独种类的节点，而是在前两种节点的基础上，加上了有序的特性

## zk和eureka的区别

zk:cp设计（强一致性），目标是一个分布式协调系统，用于资源的统一管理，当节点不可用时，需要进行选举，期间zk服务不可用

eureka：ap设计（高可用），目标是一个服务注册发现系统，专门用于微服务发现注册

eureka的各个节点都是平等的，一个不可用会自动切换到其他的节点，只要还要一个eureka在工作，就能保证注册服务可用，不过查询到的信息能不是最新的

## Spring Cloud和Dubbo的区别

底层协议：前者基于http协议，后者基于tcp协议

注册中心：前者使用eureka，后者使用zk

模型定义：前者将一个应用定义为一个服务，后者将一个接口定义为一个服务

前者是一个生态，后者只是前者生态中关于微服务调用额一种解决方案

## 什么是Hystrix，简述实现机制

分布式容错框架

- 阻止故障的连锁反应，实现熔断
- 快速失败，实现优雅降级
- 提供实时的监控和告警

熔断和降级：调用服务失败后快速失败

熔断是为了防止异常扩散，保证系统的稳定性

降级：编写好调用失败的补救逻辑，然后对服务直接停止运行，这样接口就无法直接调用，但又不至于报错，只是服务水平下降

## Spring Cloud核心组件及作用

Eureka：服务注册与发现

Ribbon：负载均衡

Feign：动态代理，调用远程就想调用本地服务一样

Hystrix：服务熔断和降级

Zuul：微服务网关，负责网络路由

## Dubbo的整体架构设计及分层

五个角色

注册中心registry：服务注册与发现

服务提供者provider：暴露服务

服务消费者consumer：调用远程服务

监控中心monitor：统计服务的调用次数和调用时间

容器container：服务允许容器

调用流程：

1. container容器负责启动、加载、运行provider
2. provider在启动时，向registry中心注册自己提供的服务
3. consumer在启动时，向registry中心订阅自己需要的服务
4. registry返回服务提供者列表给consumer
5. consumer调用provider服务，基于负载均衡算法进行调用
6. consumer调用provider的统计，基于短链接定时每分钟一次统计到monitor

分层

- 接口服务层（Service）：面向开发者，业务代码，接口，实现等
- 配置层（Config）：对外配置接口，以ServiceConfig和ReferenceConfig为中心
- 服务代理层（Proxy）：对生产者和消费者、dubbo都会产生一个代理类封装调用细节，业务层对远程调用无感
- 服务注册层（Registry）：封装服务地址的注册和发现，以服务URL为中心
- 路由层（Cluster）：封装多个提供者的路由和负载均衡，并桥接注册中心
- 监控层（Monitor）：RPC调用次数和调用时间监控
- 远程调用层（Protocal）：封装RPC调用
- 信息交换层（Exchange）：封装请求响应模式，同步转异步
- 网络传输层（Transport）:抽象main和hetty为统一接口，同一网络传输接口
- 数据序列化层（Serialize）：数据传输的序列化和反序列化
